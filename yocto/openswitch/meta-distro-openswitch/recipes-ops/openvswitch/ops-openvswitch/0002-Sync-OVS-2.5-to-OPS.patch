From 6e529353e4f6073f23fc56edd2dfdf268dbd7327 Mon Sep 17 00:00:00 2001
From: "Marcelo E. Magallon" <marcelo.magallon@hpe.com>
Date: Mon, 23 May 2016 13:19:39 -0600
Subject: [PATCH] Sync OVS 2.5 to OPS

Starting commit is 976b441345df85dd7adb973f8ae208f588d764a0

Signed-off-by: Marcelo E. Magallon <marcelo.magallon@hpe.com>
Signed-off-by: Javier Albornoz <javier.albornoz@hpe.com>
---
 .gitignore                                        |    6 +-
 Makefile.am                                       |  121 +-
 appveyor.yml                                      |    2 +-
 configure.ac                                      |   20 +-
 datapath-windows/ovsext/Flow.c                    |    2 +-
 datapath-windows/ovsext/Netlink/Netlink.h         |    2 +-
 datapath-windows/ovsext/User.h                    |    2 +-
 datapath/linux/compat/include/linux/openvswitch.h |    1 +
 include/openflow/automake.mk                      |    4 +
 include/openvswitch/automake.mk                   |    4 +
 lib/automake.mk                                   |  636 ++-
 lib/command-line.h                                |    5 +
 lib/daemon-unix.c                                 |    7 +
 lib/daemon.c                                      |    5 +
 lib/daemon.h                                      |    5 +
 lib/dirs.c.in                                     |   11 +
 lib/dpif-netlink.c                                |    3 +
 lib/dpif.c                                        |    3 +
 lib/libovscommon.pc                               |   11 +
 lib/libovscommon.pc.in                            |   11 +
 lib/libovscommon.sym.in                           |    4 +
 lib/netdev-bsd.c                                  |    5 +
 lib/netdev-dummy.c                                |    5 +
 lib/netdev-linux.c                                |    8 +-
 lib/netdev-provider.h                             |   19 +
 lib/netdev-vport.c                                |   15 +
 lib/netdev.c                                      |   97 +-
 lib/netdev.h                                      |    5 +
 lib/odp-util.c                                    |    2 +-
 lib/ovsdb-data.c                                  |   30 +
 lib/ovsdb-data.h                                  |    8 +
 lib/ovsdb-idl-provider.h                          |   13 +
 lib/ovsdb-idl.c                                   |   31 +
 lib/poll-loop.c                                   |   17 +
 lib/poll-loop.h                                   |   29 +
 lib/socket-util-unix.c                            |   17 +
 lib/vlan-bitmap.h                                 |    5 +
 lib/vlandev.c                                     |    6 +-
 lib/vswitch-idl.ann                               |    2 +
 m4/openvswitch.m4                                 |  132 +-
 manpages.mk                                       |   38 -
 ofproto/automake.mk                               |   10 +
 ofproto/bond.c                                    |   32 +-
 ofproto/bond.h                                    |    8 +
 ofproto/ofproto-dpif-sflow.h                      |    2 +-
 ofproto/ofproto-dpif.c                            |   13 +
 ofproto/ofproto-provider.h                        |   47 +
 ofproto/ofproto.c                                 |  199 +-
 ofproto/ofproto.h                                 |  140 +
 ops/DESIGN.md                                     |  106 +
 ops/README.md                                     |   24 +
 ops/docs/AUTHORS                                  |   44 +
 ops/docs/COPYING                                  |   11 +
 ops/tests/ops-openvswitch_test.md                 |   26 +
 ovn/lib/automake.mk                               |    1 -
 ovsdb/automake.mk                                 |   54 +-
 ovsdb/ovsdb-client.c                              |    9 +
 ovsdb/ovsdb-doc                                   |    2 +
 ovsdb/ovsdb-idlc.in                               |  105 +-
 ovsdb/ovsdb-server.c                              |    5 +
 python/ovs/db/data.py                             |   22 +
 python/ovs/db/schema.py                           |   10 +-
 python/ovs/db/types.py                            |   15 +
 tests/ofproto-dpif.at                             |    2 +-
 tests/ofproto.at                                  |    2 +-
 tests/ovsdb-idl.at                                |   71 +
 tutorial/ovn/env2/setup.sh                        |    8 +-
 utilities/automake.mk                             |   28 +-
 utilities/ovs-appctl.c                            |    5 +
 utilities/ovs-ofctl.8.in                          |    2 +-
 utilities/ovs-sim.1.xml                           |    4 +-
 utilities/ovs-sim.in                              |    2 +-
 utilities/ovs-vsctl.c                             | 1254 +++++-
 vswitchd/vswitch.ovsschema                        |  610 ---
 vswitchd/vswitch.xml                              | 4724 ---------------------
 vtep/automake.mk                                  |    2 +-
 76 files changed, 3108 insertions(+), 5840 deletions(-)
 create mode 100644 lib/libovscommon.pc
 create mode 100644 lib/libovscommon.pc.in
 create mode 100644 lib/libovscommon.sym.in
 create mode 100644 ops/DESIGN.md
 create mode 100644 ops/README.md
 create mode 100644 ops/docs/AUTHORS
 create mode 100644 ops/docs/COPYING
 create mode 100644 ops/tests/ops-openvswitch_test.md
 delete mode 100644 vswitchd/vswitch.ovsschema
 delete mode 100644 vswitchd/vswitch.xml

diff --git a/.gitignore b/.gitignore
index 71bb21b..2e883b4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -49,13 +49,14 @@
 /configure-stamp
 /depcomp
 /distfiles
-/dist-docs
 /install-sh
 /libtool
 /manpage-check
 /missing
 /missing-distfiles
 /package.m4
+/m4/ltargz.m4
+/m4/ltdl.m4
 /stamp-h1
 /_build-gcc
 /_build-clang
@@ -67,4 +68,5 @@ _debian
 odp-netlink.h
 OvsDpInterface.h
 /.vagrant/
-testsuite.tmp.orig
+/build
+/libltdl/
diff --git a/Makefile.am b/Makefile.am
index 95087a5..60ac9c4 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -7,7 +7,11 @@
 
 AUTOMAKE_OPTIONS = foreign subdir-objects
 ACLOCAL_AMFLAGS = -I m4
-SUBDIRS = datapath
+if OPS
+SUBDIRS = libltdl
+else
+SUBDIRS = datapath libltdl
+endif
 
 AM_CPPFLAGS = $(SSL_CFLAGS)
 AM_LDFLAGS = $(SSL_LDFLAGS)
@@ -26,10 +30,12 @@ AM_CPPFLAGS += -I $(top_srcdir)/include
 AM_CPPFLAGS += -I $(top_builddir)/include
 AM_CPPFLAGS += -I $(top_srcdir)/lib
 AM_CPPFLAGS += -I $(top_builddir)/lib
+AM_CPPFLAGS += -I $(top_srcdir)/libltdl
+AM_CPPFLAGS += -I $(top_builddir)/libltdl
 
 AM_CPPFLAGS += $(SSL_INCLUDES)
 
-AM_CFLAGS = -Wstrict-prototypes
+AM_CFLAGS = -Wstrict-prototypes -DOPS -DOPS_TEMP
 AM_CFLAGS += $(WARNING_FLAGS)
 AM_CFLAGS += $(OVS_CFLAGS)
 
@@ -141,6 +147,7 @@ SUFFIXES =
 check_DATA =
 check_SCRIPTS =
 pkgconfig_DATA =
+FLAKE8_PYFILES =
 
 scriptsdir = $(pkgdatadir)/scripts
 completiondir = $(sysconfdir)/bash_completion.d
@@ -209,21 +216,21 @@ CLEAN_LOCAL += clean-pycov
 # Makefile in datapath/linux, needed to get the list of files to
 # distribute, requires GNU make extensions.
 if GNU_MAKE
-ALL_LOCAL += dist-hook-git
-dist-hook-git: distfiles
-	@if test -e $(srcdir)/.git && (git --version) >/dev/null 2>&1; then \
-	  (cd datapath && $(MAKE) distfiles);				    \
-	  (cat distfiles; sed 's|^|datapath/|' datapath/distfiles) |	    \
-	    LC_ALL=C sort -u > all-distfiles;				    \
-	  (cd $(srcdir) && git ls-files) | grep -v '\.gitignore$$' |	    \
-	    LC_ALL=C sort -u > all-gitfiles;				    \
-	  LC_ALL=C comm -1 -3 all-distfiles all-gitfiles > missing-distfiles; \
-	  if test -s missing-distfiles; then				    \
-	    echo "The following files are in git but not the distribution:"; \
-	    cat missing-distfiles;					    \
-	    exit 1;							    \
-	  fi;								    \
-	fi
+#ALL_LOCAL += dist-hook-git
+#dist-hook-git: distfiles
+#	@if test -e $(srcdir)/.git && (git --version) >/dev/null 2>&1; then \
+#	  (cd datapath && $(MAKE) distfiles);				    \
+#	  (cat distfiles; sed 's|^|datapath/|' datapath/distfiles) |	    \
+#	    LC_ALL=C sort -u > all-distfiles;				    \
+#	  (cd $(srcdir) && git ls-files) | grep -v '\.gitignore$$' |	    \
+#	    LC_ALL=C sort -u > all-gitfiles;				    \
+#	  LC_ALL=C comm -1 -3 all-distfiles all-gitfiles > missing-distfiles; \
+#	  if test -s missing-distfiles; then				    \
+#	    echo "The following files are in git but not the distribution:"; \
+#	    cat missing-distfiles;					    \
+#	    exit 1;							    \
+#	  fi;								    \
+#	fi
 CLEANFILES += all-distfiles all-gitfiles missing-distfiles
 # The following is based on commands for the Automake "distdir" target.
 distfiles: Makefile
@@ -239,17 +246,17 @@ endif
 .PHONY: dist-hook-git
 
 # Check that every .c file includes <config.h>.
-ALL_LOCAL += config-h-check
-config-h-check:
-	@cd $(srcdir); \
-	if test -e .git && (git --version) >/dev/null 2>&1 && \
-	   git --no-pager grep -L '#include <config\.h>' `git ls-files | grep '\.c$$' | \
-               grep -vE '^datapath|^lib/sflow|^third-party|^datapath-windows'`; \
-	then \
-	    echo "See above for list of violations of the rule that"; \
-	    echo "every C source file must #include <config.h>."; \
-	    exit 1; \
-	fi
+#ALL_LOCAL += config-h-check
+#config-h-check:
+#	@cd $(srcdir); \
+#	if test -e .git && (git --version) >/dev/null 2>&1 && \
+#	   git --no-pager grep -L '#include <config\.h>' `git ls-files | grep '\.c$$' | \
+#               grep -vE '^datapath|^lib/sflow|^third-party|^datapath-windows'`; \
+#	then \
+#	    echo "See above for list of violations of the rule that"; \
+#	    echo "every C source file must #include <config.h>."; \
+#	    exit 1; \
+#	fi
 .PHONY: config-h-check
 
 # Check for printf() type modifiers that MSVC doesn't support.
@@ -309,19 +316,19 @@ check-endian:
 	 fi
 .PHONY: check-endian
 
-ALL_LOCAL += thread-safety-check
-thread-safety-check:
-	@cd $(srcdir); \
-	if test -e .git && (git --version) >/dev/null 2>&1 && \
-	   grep -n -f build-aux/thread-safety-blacklist \
-	       `git ls-files | grep '\.[ch]$$' \
-                | $(EGREP) -v '^datapath|^lib/sflow|^third-party'` /dev/null \
-	       | $(EGREP) -v ':[ 	]*/?\*'; \
-	then \
-	    echo "See above for list of calls to functions that are"; \
-	    echo "blacklisted due to thread safety issues"; \
-	    exit 1; \
-	fi
+#ALL_LOCAL += thread-safety-check
+#thread-safety-check:
+#	@cd $(srcdir); \
+#	if test -e .git && (git --version) >/dev/null 2>&1 && \
+#	   grep -n -f build-aux/thread-safety-blacklist \
+#	       `git ls-files | grep '\.[ch]$$' \
+#                | $(EGREP) -v '^datapath|^lib/sflow|^third-party'` /dev/null \
+#	       | $(EGREP) -v ':[ 	]*/?\*'; \
+#	then \
+#	    echo "See above for list of calls to functions that are"; \
+#	    echo "blacklisted due to thread safety issues"; \
+#	    exit 1; \
+#	fi
 EXTRA_DIST += build-aux/thread-safety-blacklist
 .PHONY: thread-safety-check
 
@@ -350,19 +357,6 @@ $(srcdir)/manpages.mk: $(MAN_ROOTS) build-aux/sodepends.pl
 	fi
 CLEANFILES += manpage-dep-check
 
-if VSTUDIO_DDK
-ALL_LOCAL += ovsext_make
-ovsext_make: datapath-windows/ovsext.sln
-	MSBuild.exe datapath-windows/ovsext.sln /target:Build /property:Configuration="Win8$(VSTUDIO_CONFIG)"
-	MSBuild.exe datapath-windows/ovsext.sln /target:Build /property:Configuration="Win8.1$(VSTUDIO_CONFIG)"
-
-CLEAN_LOCAL += ovsext_clean
-ovsext_clean: datapath-windows/ovsext.sln
-	MSBuild.exe datapath-windows/ovsext.sln /target:Clean /property:Configuration="Win8$(VSTUDIO_CONFIG)"
-	MSBuild.exe datapath-windows/ovsext.sln /target:Clean /property:Configuration="Win8.1$(VSTUDIO_CONFIG)"
-.PHONY: ovsext_make
-endif
-
 dist-hook: $(DIST_HOOKS)
 all-local: $(ALL_LOCAL)
 clean-local: $(CLEAN_LOCAL)
@@ -379,23 +373,20 @@ dist-docs:
 	VERSION=$(VERSION) $(srcdir)/build-aux/dist-docs $(srcdir) $(docs)
 .PHONY: dist-docs
 
-include Documentation/automake.mk
+if OPS
+nodist_ovslibincludedir = $(includedir)/ovs
+nodist_ovslibinclude_HEADERS = config.h
+#nodist_ovslibinclude_HEADERS += include/odp-netlink.h
+endif
+
 include m4/automake.mk
 include lib/automake.mk
 include ofproto/automake.mk
 include utilities/automake.mk
-include tests/automake.mk
 include include/automake.mk
-include third-party/automake.mk
-include debian/automake.mk
+if OVS_VSWITCHD
 include vswitchd/automake.mk
+endif
 include ovsdb/automake.mk
-include rhel/automake.mk
-include xenserver/automake.mk
 include python/automake.mk
-include tutorial/automake.mk
 include vtep/automake.mk
-include datapath-windows/automake.mk
-include datapath-windows/include/automake.mk
-include windows/automake.mk
-include ovn/automake.mk
diff --git a/appveyor.yml b/appveyor.yml
index d3d87b3..25b72bb 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -1,6 +1,6 @@
 version: 1.0.{build}
 branches:
-  only: 
+  only:
   - master
 clone_folder: C:\openvswitch
 init:
diff --git a/configure.ac b/configure.ac
index 1ac3b5f..6d2a235 100644
--- a/configure.ac
+++ b/configure.ac
@@ -78,6 +78,14 @@ AC_SUBST([LT_REVISION])
 LT_AGE=libopenvswitch_lt_age
 AC_SUBST([LT_AGE])
 
+LT_CONFIG_LTDL_DIR([libltdl])
+LTDL_INIT([subproject])
+
+AC_CHECK_HEADER([ltdl.h],
+    [AC_CHECK_LIB([ltdl], [lt_dladvise_init],
+        [LIBLTDL=-lltdl], [LIBLTDL=])],
+    [LIBLTDL=])
+
 AC_SEARCH_LIBS([pow], [m])
 AC_SEARCH_LIBS([clock_gettime], [rt])
 AC_SEARCH_LIBS([timer_create], [rt])
@@ -138,7 +146,7 @@ AC_CONFIG_FILES([
     ofproto/libofproto.sym
     lib/libsflow.sym
     lib/libopenvswitch.sym
-    ovn/lib/libovn.sym
+    lib/libovscommon.sym
     vtep/libvtep.sym])
 
 OVS_ENABLE_OPTION([-Wall])
@@ -166,16 +174,26 @@ AC_ARG_VAR(KARCH, [Kernel Architecture String])
 AC_SUBST(KARCH)
 OVS_CHECK_LINUX
 OVS_CHECK_DPDK
+OVS_CHECK_SIMULATOR_PROVIDER
+AC_SUBST([OPS_BUILD])
+AM_CONDITIONAL([OPS], [test "$OPS_BUILD" = "1" || test "x$enable_simulator_provider" = "xyes"])
+AC_SUBST([BUILD_OVS_VSWITCHD])
+AM_CONDITIONAL([OVS_VSWITCHD], [test "$BUILD_OVS_VSWITCHD" = "1"])
 OVS_CHECK_PRAGMA_MESSAGE
 AC_SUBST([OVS_CFLAGS])
 AC_SUBST([OVS_LDFLAGS])
 
+PKG_CHECK_MODULES([YAML], [yaml-0.1])
+AC_SUBST([YAML_CFLAGS])
+AC_SUBST([YAML_LDFLAGS])
+
 AC_CONFIG_FILES(Makefile)
 AC_CONFIG_FILES(datapath/Makefile)
 AC_CONFIG_FILES(datapath/linux/Kbuild)
 AC_CONFIG_FILES(datapath/linux/Makefile)
 AC_CONFIG_FILES(datapath/linux/Makefile.main)
 AC_CONFIG_FILES(tests/atlocal)
+AC_CONFIG_FILES(lib/libovscommon.pc)
 AC_CONFIG_FILES(lib/libopenvswitch.pc)
 AC_CONFIG_FILES(lib/libsflow.pc)
 AC_CONFIG_FILES(ofproto/libofproto.pc)
diff --git a/datapath-windows/ovsext/Flow.c b/datapath-windows/ovsext/Flow.c
index 31ddc66..bd33576 100644
--- a/datapath-windows/ovsext/Flow.c
+++ b/datapath-windows/ovsext/Flow.c
@@ -485,7 +485,7 @@ _FlowNlGetCmdHandler(POVS_USER_PARAMS_CONTEXT usrParamsCtx,
         /* Get tunnel keys attributes */
         if ((NlAttrParseNested(nlMsgHdr, tunnelKeyAttrOffset,
                                NlAttrLen(keyAttrs[OVS_KEY_ATTR_TUNNEL]),
-                               nlFlowTunnelKeyPolicy, 
+                               nlFlowTunnelKeyPolicy,
                                ARRAY_SIZE(nlFlowTunnelKeyPolicy),
                                tunnelAttrs, ARRAY_SIZE(tunnelAttrs)))
                                != TRUE) {
diff --git a/datapath-windows/ovsext/Netlink/Netlink.h b/datapath-windows/ovsext/Netlink/Netlink.h
index d270737..26d0c7b 100644
--- a/datapath-windows/ovsext/Netlink/Netlink.h
+++ b/datapath-windows/ovsext/Netlink/Netlink.h
@@ -133,7 +133,7 @@ const PNL_ATTR NlAttrFindNested(const PNL_ATTR nla,
                                 UINT16 type);
 BOOLEAN NlAttrParse(const PNL_MSG_HDR nlMsg, UINT32 attrOffset,
                     UINT32 totalAttrLen, const NL_POLICY policy[],
-                    const UINT32 numPolicy, PNL_ATTR attrs[], 
+                    const UINT32 numPolicy, PNL_ATTR attrs[],
                     UINT32 numAttrs);
 BOOLEAN NlAttrParseNested(const PNL_MSG_HDR nlMsg, UINT32 attrOffset,
                           UINT32 totalAttrLen, const NL_POLICY policy[],
diff --git a/datapath-windows/ovsext/User.h b/datapath-windows/ovsext/User.h
index 3a42888..3db7d31 100644
--- a/datapath-windows/ovsext/User.h
+++ b/datapath-windows/ovsext/User.h
@@ -72,7 +72,7 @@ VOID OvsCleanupPacketQueue(struct _OVS_OPEN_INSTANCE *instance);
 
 POVS_PACKET_QUEUE_ELEM OvsCreateQueueNlPacket(PVOID userData,
                                               UINT32 userDataLen,
-                                              UINT32 cmd, 
+                                              UINT32 cmd,
                                               POVS_VPORT_ENTRY vport,
                                               OvsFlowKey *key,
                                               PNET_BUFFER_LIST nbl,
diff --git a/datapath/linux/compat/include/linux/openvswitch.h b/datapath/linux/compat/include/linux/openvswitch.h
index ea76e93..d26052a 100644
--- a/datapath/linux/compat/include/linux/openvswitch.h
+++ b/datapath/linux/compat/include/linux/openvswitch.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2007-2014 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * This file is offered under your choice of two licenses: Apache 2.0 or GNU
  * GPL 2.0 or later.  The permission statements for each of these licenses is
diff --git a/include/openflow/automake.mk b/include/openflow/automake.mk
index d7dac91..9d44840 100644
--- a/include/openflow/automake.mk
+++ b/include/openflow/automake.mk
@@ -1,4 +1,8 @@
+if OPS
+openflowincludedir = $(includedir)/ovs/openflow
+else
 openflowincludedir = $(includedir)/openflow
+endif
 openflowinclude_HEADERS = \
 	include/openflow/netronome-ext.h \
 	include/openflow/nicira-ext.h \
diff --git a/include/openvswitch/automake.mk b/include/openvswitch/automake.mk
index 90a45cb..5d87ad3 100644
--- a/include/openvswitch/automake.mk
+++ b/include/openvswitch/automake.mk
@@ -1,4 +1,8 @@
+if OPS
+openvswitchincludedir = $(includedir)/ovs/openvswitch
+else
 openvswitchincludedir = $(includedir)/openvswitch
+endif
 openvswitchinclude_HEADERS = \
 	include/openvswitch/compiler.h \
 	include/openvswitch/list.h \
diff --git a/lib/automake.mk b/lib/automake.mk
index 5387d51..c9805d1 100644
--- a/lib/automake.mk
+++ b/lib/automake.mk
@@ -1,303 +1,535 @@
-# Copyright (C) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+# Copyright (C) 2009, 2010, 2011, 2012, 2013, 2014 Nicira, Inc.
 #
 # Copying and distribution of this file, with or without modification,
 # are permitted in any medium without royalty provided the copyright
 # notice and this notice are preserved.  This file is offered as-is,
 # without warranty of any kind.
 
-lib_LTLIBRARIES += lib/libopenvswitch.la
-
-lib_libopenvswitch_la_LIBADD = $(SSL_LIBS)
-lib_libopenvswitch_la_LIBADD += $(CAPNG_LDADD)
-
-if WIN32
-lib_libopenvswitch_la_LIBADD += ${PTHREAD_LIBS}
-endif
-
-lib_libopenvswitch_la_LDFLAGS = \
-        -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
-        -Wl,--version-script=$(top_builddir)/lib/libopenvswitch.sym \
-        $(AM_LDFLAGS)
-
-lib_libopenvswitch_la_SOURCES = \
-	lib/aes128.c \
+if OPS
+ovslibincludedir = $(includedir)/ovs
+ovslibinclude_HEADERS = \
 	lib/aes128.h \
 	lib/async-append.h \
-	lib/backtrace.c \
 	lib/backtrace.h \
-	lib/bfd.c \
 	lib/bfd.h \
 	lib/bitmap.h \
-	lib/bundle.c \
 	lib/bundle.h \
 	lib/byte-order.h \
-	lib/byteq.c \
 	lib/byteq.h \
-	lib/cfm.c \
 	lib/cfm.h \
-	lib/classifier.c \
 	lib/classifier.h \
-	lib/classifier-private.h \
-	lib/cmap.c \
 	lib/cmap.h \
-	lib/command-line.c \
 	lib/command-line.h \
 	lib/compiler.h \
-	lib/connectivity.c \
 	lib/connectivity.h \
-	lib/coverage.c \
 	lib/coverage.h \
-	lib/crc32c.c \
 	lib/crc32c.h \
-	lib/csum.c \
 	lib/csum.h \
-	lib/ct-dpif.c \
 	lib/ct-dpif.h \
-	lib/daemon.c \
 	lib/daemon.h \
-	lib/daemon-private.h \
-	lib/db-ctl-base.c \
 	lib/db-ctl-base.h \
 	lib/dhcp.h \
-	lib/dummy.c \
-	lib/dummy.h \
 	lib/dhparams.h \
 	lib/dirs.h \
-	lib/dpctl.c \
 	lib/dpctl.h \
-	lib/dp-packet.h \
-	lib/dp-packet.c \
-	lib/dpif-netdev.c \
+	lib/dpif.h \
 	lib/dpif-netdev.h \
+	lib/dpif-netlink.h \
 	lib/dpif-provider.h \
-	lib/dpif.c \
-	lib/dpif.h \
-	lib/heap.c \
-	lib/heap.h \
-	lib/dynamic-string.c \
+	lib/dp-packet.h \
+	lib/dummy.h \
 	lib/dynamic-string.h \
-	lib/entropy.c \
 	lib/entropy.h \
-	lib/fat-rwlock.c \
-	lib/fat-rwlock.h \
-	lib/fatal-signal.c \
 	lib/fatal-signal.h \
-	lib/flow.c \
+	lib/fat-rwlock.h \
 	lib/flow.h \
 	lib/geneve.h \
-	lib/guarded-list.c \
 	lib/guarded-list.h \
-	lib/hash.c \
 	lib/hash.h \
-	lib/hindex.c \
+	lib/heap.h \
 	lib/hindex.h \
-	lib/hmap.c \
 	lib/hmap.h \
-	lib/hmapx.c \
 	lib/hmapx.h \
-	lib/id-pool.c \
 	lib/id-pool.h \
-	lib/jhash.c \
+	lib/if-notifier.h \
 	lib/jhash.h \
-	lib/json.c \
 	lib/json.h \
-	lib/jsonrpc.c \
 	lib/jsonrpc.h \
-	lib/lacp.c \
 	lib/lacp.h \
 	lib/latch.h \
-	lib/learn.c \
 	lib/learn.h \
-	lib/learning-switch.c \
 	lib/learning-switch.h \
 	lib/list.h \
-	lib/lockfile.c \
 	lib/lockfile.h \
-	lib/mac-learning.c \
 	lib/mac-learning.h \
-	lib/match.c \
 	lib/match.h \
-	lib/mcast-snooping.c \
 	lib/mcast-snooping.h \
-	lib/memory.c \
 	lib/memory.h \
-	lib/meta-flow.c \
 	lib/meta-flow.h \
-	lib/multipath.c \
 	lib/multipath.h \
-	lib/netdev-dummy.c \
+	lib/netdev-dpdk.h \
+	lib/netdev.h \
+	lib/netdev-linux.h \
 	lib/netdev-provider.h \
-	lib/netdev-vport.c \
 	lib/netdev-vport.h \
-	lib/netdev.c \
-	lib/netdev.h \
 	lib/netflow.h \
-	lib/netlink.c \
+	lib/netlink-conntrack.h \
 	lib/netlink.h \
-	lib/nx-match.c \
+	lib/netlink-notifier.h \
+	lib/netlink-protocol.h \
+	lib/netlink-socket.h \
 	lib/nx-match.h \
-	lib/odp-execute.c \
 	lib/odp-execute.h \
-	lib/odp-util.c \
 	lib/odp-util.h \
-	lib/ofp-actions.c \
 	lib/ofp-actions.h \
-	lib/ofp-errors.c \
+	lib/ofpbuf.h \
 	lib/ofp-errors.h \
-	lib/ofp-msgs.c \
 	lib/ofp-msgs.h \
-	lib/ofp-parse.c \
 	lib/ofp-parse.h \
-	lib/ofp-print.c \
 	lib/ofp-print.h \
-	lib/ofp-util.c \
 	lib/ofp-util.h \
 	lib/ofp-version-opt.h \
-	lib/ofp-version-opt.c \
-	lib/ofpbuf.c \
-	lib/ofpbuf.h \
 	lib/ovs-atomic-c11.h \
 	lib/ovs-atomic-clang.h \
 	lib/ovs-atomic-flag-gcc4.7+.h \
-	lib/ovs-atomic-gcc4+.h \
 	lib/ovs-atomic-gcc4.7+.h \
+	lib/ovs-atomic-gcc4+.h \
+	lib/ovs-atomic.h \
 	lib/ovs-atomic-i586.h \
-	lib/ovs-atomic-locked.c \
 	lib/ovs-atomic-locked.h \
 	lib/ovs-atomic-msvc.h \
 	lib/ovs-atomic-pthreads.h \
 	lib/ovs-atomic-x86_64.h \
-	lib/ovs-atomic.h \
-	lib/ovs-lldp.c \
-	lib/ovs-lldp.h \
-	lib/ovs-rcu.c \
-	lib/ovs-rcu.h \
-	lib/ovs-router.h \
-	lib/ovs-router.c \
-	lib/ovs-thread.c \
-	lib/ovs-thread.h \
-	lib/ovsdb-data.c \
 	lib/ovsdb-data.h \
-	lib/ovsdb-error.c \
 	lib/ovsdb-error.h \
-	lib/ovsdb-idl-provider.h \
-	lib/ovsdb-idl.c \
 	lib/ovsdb-idl.h \
-	lib/ovsdb-parser.c \
+	lib/ovsdb-idl-provider.h \
 	lib/ovsdb-parser.h \
-	lib/ovsdb-types.c \
 	lib/ovsdb-types.h \
-	lib/packets.c \
+	lib/ovs-lldp.h \
+	lib/ovs-numa.h \
+	lib/ovs-rcu.h \
+	lib/ovs-router.h \
+	lib/ovs-thread.h \
 	lib/packets.h \
-	lib/pcap-file.c \
 	lib/pcap-file.h \
 	lib/perf-counter.h \
-	lib/perf-counter.c \
-	lib/poll-loop.c \
 	lib/poll-loop.h \
-	lib/process.c \
 	lib/process.h \
-	lib/pvector.c \
 	lib/pvector.h \
-	lib/random.c \
 	lib/random.h \
-	lib/rconn.c \
 	lib/rconn.h \
 	lib/rculist.h \
-	lib/reconnect.c \
 	lib/reconnect.h \
-	lib/rstp.c \
-	lib/rstp.h \
+	lib/route-table.h \
 	lib/rstp-common.h \
-	lib/rstp-state-machines.c \
+	lib/rstp.h \
 	lib/rstp-state-machines.h \
+	lib/rtbsd.h \
+	lib/rtnetlink.h \
 	lib/sat-math.h \
-	lib/seq.c \
 	lib/seq.h \
-	lib/sha1.c \
+	lib/sflow_api.h \
+	lib/sflow.h \
 	lib/sha1.h \
-	lib/shash.c \
 	lib/shash.h \
-	lib/simap.c \
+	lib/signals.h \
 	lib/simap.h \
-	lib/smap.c \
 	lib/smap.h \
-	lib/socket-util.c \
 	lib/socket-util.h \
-	lib/sort.c \
 	lib/sort.h \
-	lib/sset.c \
 	lib/sset.h \
-	lib/stp.c \
 	lib/stp.h \
-	lib/stream-fd.c \
 	lib/stream-fd.h \
+	lib/stream.h \
 	lib/stream-provider.h \
 	lib/stream-ssl.h \
-	lib/stream-tcp.c \
-	lib/stream.c \
-	lib/stream.h \
-	lib/stdio.c \
-	lib/string.c \
-	lib/svec.c \
 	lib/svec.h \
-	lib/syslog-direct.c \
 	lib/syslog-direct.h \
-	lib/syslog-libc.c \
 	lib/syslog-libc.h \
 	lib/syslog-provider.h \
-	lib/table.c \
 	lib/table.h \
-	lib/timer.c \
 	lib/timer.h \
-	lib/timeval.c \
 	lib/timeval.h \
-	lib/tnl-neigh-cache.c \
 	lib/tnl-neigh-cache.h \
-	lib/tnl-ports.c \
 	lib/tnl-ports.h \
-	lib/token-bucket.c \
-	lib/tun-metadata.c \
 	lib/tun-metadata.h \
 	lib/type-props.h \
 	lib/unaligned.h \
-	lib/unicode.c \
 	lib/unicode.h \
-	lib/unixctl.c \
 	lib/unixctl.h \
-	lib/util.c \
 	lib/util.h \
-	lib/uuid.c \
 	lib/uuid.h \
 	lib/valgrind.h \
 	lib/vconn-provider.h \
-	lib/vconn-stream.c \
-	lib/vconn.c \
+	lib/vlan-bitmap.h \
+	lib/vlandev.h \
+	lib/vswitch-idl.h \
+	include/odp-netlink.h
+
+endif
+
+lib_LTLIBRARIES += lib/libovscommon.la
+
+lib_libovscommon_la_LIBADD = $(SSL_LIBS)
+
+if WIN32
+lib_libovscommon_la_LIBADD += ${PTHREAD_LIBS}
+endif
+
+lib_libovscommon_la_LIBADD += libltdl/libltdlc.la
+lib_libovscommon_la_LDFLAGS = \
+        -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
+        -Wl,--version-script=$(top_builddir)/lib/libovscommon.sym \
+        $(AM_LDFLAGS)
+
+lib_libovscommon_la_SOURCES = \
+        lib/aes128.c \
+        lib/aes128.h \
+        lib/async-append.h \
+        lib/backtrace.c \
+        lib/backtrace.h \
+        lib/bitmap.h \
+        lib/byte-order.h \
+        lib/byteq.c \
+        lib/byteq.h \
+        lib/cmap.c \
+        lib/cmap.h \
+        lib/command-line.c \
+        lib/command-line.h \
+        lib/compiler.h \
+        lib/connectivity.c \
+        lib/connectivity.h \
+        lib/coverage.c \
+        lib/coverage.h \
+        lib/crc32c.c \
+        lib/crc32c.h \
+        lib/csum.c \
+        lib/csum.h \
+        lib/daemon.c \
+        lib/daemon.h \
+        lib/daemon-private.h \
+	lib/db-ctl-base.c \
+	lib/db-ctl-base.h \
+        lib/dhcp.h \
+        lib/dummy.h \
+        lib/dhparams.h \
+        lib/dirs.h \
+	lib/dp-packet.h \
+	lib/dp-packet.c \
+        lib/heap.c \
+        lib/heap.h \
+        lib/dynamic-string.c \
+        lib/dynamic-string.h \
+        lib/entropy.c \
+        lib/entropy.h \
+        lib/fat-rwlock.c \
+        lib/fat-rwlock.h \
+        lib/fatal-signal.c \
+        lib/fatal-signal.h \
+        lib/guarded-list.c \
+        lib/guarded-list.h \
+        lib/hash.c \
+        lib/hash.h \
+        lib/hindex.c \
+        lib/hindex.h \
+        lib/hmap.c \
+        lib/hmap.h \
+        lib/hmapx.c \
+        lib/hmapx.h \
+        lib/jhash.c \
+        lib/json.c \
+        lib/json.h \
+        lib/jhash.h \
+        lib/list.h \
+        lib/lockfile.c \
+        lib/lockfile.h \
+        lib/memory.c \
+        lib/memory.h \
+        lib/ofp-util.def \
+        lib/ofp-util.h \
+        lib/ovs-atomic-c11.h \
+        lib/ovs-atomic-clang.h \
+        lib/ovs-atomic-flag-gcc4.7+.h \
+        lib/ovs-atomic-gcc4+.h \
+        lib/ovs-atomic-gcc4.7+.h \
+	lib/ovs-atomic-i586.h \
+        lib/ovs-atomic-locked.c \
+        lib/ovs-atomic-locked.h \
+	lib/ovs-atomic-msvc.h \
+        lib/ovs-atomic-pthreads.h \
+	lib/ovs-atomic-x86_64.h \
+        lib/ovs-atomic.h \
+        lib/ovs-rcu.c \
+        lib/ovs-rcu.h \
+        lib/ovs-thread.c \
+        lib/ovs-thread.h \
+	lib/packets.c \
+	lib/packets.h \
+        lib/poll-loop.c \
+        lib/poll-loop.h \
+        lib/process.c \
+        lib/process.h \
+        lib/random.c \
+        lib/random.h \
+        lib/reconnect.c \
+        lib/reconnect.h \
+        lib/sat-math.h \
+        lib/seq.c \
+        lib/seq.h \
+        lib/sha1.c \
+        lib/sha1.h \
+        lib/shash.c \
+        lib/shash.h \
+        lib/simap.c \
+        lib/simap.h \
+        lib/smap.c \
+        lib/smap.h \
+        lib/socket-util.c \
+        lib/socket-util.h \
+        lib/sort.c \
+        lib/sort.h \
+        lib/sset.c \
+        lib/sset.h \
+        lib/stream-fd.h \
+        lib/stream-fd.c \
+        lib/stream-provider.h \
+        lib/stream-ssl.h \
+        lib/stream-tcp.c \
+        lib/stream.c \
+        lib/stream.h \
+        lib/stdio.c \
+        lib/string.c \
+        lib/svec.c \
+        lib/svec.h \
+	lib/syslog-direct.c \
+	lib/syslog-direct.h \
+	lib/syslog-libc.c \
+	lib/syslog-libc.h \
+	lib/syslog-provider.h \
+        lib/timer.c \
+        lib/timer.h \
+        lib/timeval.c \
+        lib/timeval.h \
+        lib/token-bucket.c \
+        lib/token-bucket.h \
+        lib/type-props.h \
+        lib/unaligned.h \
+        lib/unicode.c \
+        lib/unicode.h \
+        lib/util.c \
+        lib/util.h \
+        lib/uuid.c \
+        lib/uuid.h \
+        lib/unixctl.c \
+        lib/unixctl.h \
+        lib/ofpbuf.c \
+        lib/ofpbuf.h \
+        lib/jsonrpc.c \
+        lib/jsonrpc.h \
+        lib/valgrind.h \
 	lib/vlan-bitmap.c \
 	lib/vlan-bitmap.h \
+        lib/vlog.c \
+        lib/vlog.h \
+        lib/ovsdb-idl.c \
+        lib/ovsdb-idl.h \
+        lib/ovsdb-parser.c \
+        lib/ovsdb-parser.h \
+        lib/ovsdb-data.c \
+        lib/ovsdb-data.h \
+        lib/ovsdb-error.c \
+        lib/ovsdb-error.h \
+        lib/ovsdb-idl-provider.h \
+        lib/ovsdb-types.c \
+        lib/ovsdb-types.h \
+        lib/table.c \
+        lib/table.h
+
+# libovsdb
+lib_LTLIBRARIES += ovsdb/libovsdb.la
+ovsdb_libovsdb_la_LDFLAGS = \
+        -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
+        -Wl,--version-script=$(top_builddir)/ovsdb/libovsdb.sym \
+        $(AM_LDFLAGS)
+
+ovsdb_libovsdb_la_LIBADD = lib/libovscommon.la
+ovsdb_libovsdb_la_SOURCES = \
+        ovsdb/column.c \
+        ovsdb/column.h \
+        ovsdb/condition.c \
+        ovsdb/condition.h \
+        ovsdb/execution.c \
+        ovsdb/file.c \
+        ovsdb/file.h \
+        ovsdb/jsonrpc-server.c \
+        ovsdb/jsonrpc-server.h \
+        ovsdb/log.c \
+        ovsdb/log.h \
+        ovsdb/mutation.c \
+        ovsdb/mutation.h \
+        ovsdb/ovsdb.c \
+        ovsdb/ovsdb.h \
+	ovsdb/monitor.c \
+	ovsdb/monitor.h \
+        ovsdb/query.c \
+        ovsdb/query.h \
+        ovsdb/row.c \
+        ovsdb/row.h \
+        ovsdb/server.c \
+        ovsdb/server.h \
+        ovsdb/table.c \
+        ovsdb/table.h \
+        ovsdb/trigger.c \
+        ovsdb/trigger.h \
+        ovsdb/transaction.c \
+        ovsdb/transaction.h \
+        lib/vswitch-idl.c \
+        lib/vswitch-idl.h
+
+ovsdb_libovsdb_la_CFLAGS = $(AM_CFLAGS)
+ovsdb_libovsdb_la_CPPFLAGS = $(AM_CPPFLAGS)
+
+pkgconfig_DATA += \
+        $(srcdir)/ovsdb/libovsdb.pc
+
+MAN_FRAGMENTS += \
+        ovsdb/remote-active.man \
+        ovsdb/remote-passive.man
+
+lib_LTLIBRARIES += lib/libopenvswitch.la
+
+lib_libopenvswitch_la_LIBADD = $(SSL_LIBS) lib/libovscommon.la ovsdb/libovsdb.la
+
+if WIN32
+lib_libopenvswitch_la_LIBADD += ${PTHREAD_LIBS}
+endif
+
+lib_libopenvswitch_la_LDFLAGS = \
+        -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
+        -Wl,--version-script=$(top_builddir)/lib/libopenvswitch.sym \
+        $(AM_LDFLAGS)
+
+lib_libopenvswitch_la_SOURCES = \
+	lib/bfd.c \
+	lib/bfd.h \
+	lib/bitmap.h \
+	lib/bundle.c \
+	lib/bundle.h \
+	lib/cfm.c \
+	lib/cfm.h \
+	lib/classifier.c \
+	lib/classifier.h \
+	lib/classifier-private.h \
+	lib/compiler.h \
+	lib/dhcp.h \
+	lib/dummy.c \
+	lib/dummy.h \
+	lib/dhparams.h \
+	lib/dirs.h \
+	lib/dpctl.c \
+	lib/dpctl.h \
+	lib/dpif-netdev.c \
+	lib/dpif-netdev.h \
+	lib/dpif-provider.h \
+	lib/dpif.c \
+	lib/dpif.h \
+	lib/flow.c \
+	lib/flow.h \
+	lib/id-pool.c \
+	lib/id-pool.h \
+	lib/lacp.c \
+	lib/lacp.h \
+	lib/latch.h \
+	lib/learn.c \
+	lib/learn.h \
+	lib/learning-switch.c \
+	lib/learning-switch.h \
+	lib/list.h \
+	lib/mac-learning.c \
+	lib/mac-learning.h \
+	lib/match.c \
+	lib/match.h \
+	lib/mcast-snooping.c \
+	lib/mcast-snooping.h \
+	lib/meta-flow.c \
+	lib/meta-flow.h \
+	lib/multipath.c \
+	lib/multipath.h \
+	lib/netdev-dummy.c \
+	lib/netdev-provider.h \
+	lib/netdev-vport.c \
+	lib/netdev-vport.h \
+	lib/netdev.c \
+	lib/netdev.h \
+	lib/netflow.h \
+	lib/netlink.c \
+	lib/netlink.h \
+	lib/nx-match.c \
+	lib/nx-match.h \
+	lib/odp-execute.c \
+	lib/odp-execute.h \
+	lib/odp-util.c \
+	lib/odp-util.h \
+	lib/ofp-actions.c \
+	lib/ofp-actions.h \
+	lib/ofp-errors.c \
+	lib/ofp-errors.h \
+	lib/ofp-msgs.c \
+	lib/ofp-msgs.h \
+	lib/ofp-parse.c \
+	lib/ofp-parse.h \
+	lib/ofp-print.c \
+	lib/ofp-print.h \
+	lib/ofp-util.c \
+	lib/ofp-util.h \
+	lib/ofp-version-opt.h \
+	lib/ofp-version-opt.c \
+	lib/ofpbuf.h \
+	lib/ovs-router.h \
+	lib/ovs-router.c \
+	lib/pcap-file.c \
+	lib/pcap-file.h \
+	lib/perf-counter.h \
+	lib/perf-counter.c \
+	lib/pvector.c \
+	lib/pvector.h \
+	lib/rconn.c \
+	lib/rconn.h \
+	lib/rculist.h \
+	lib/rstp.c \
+	lib/rstp.h \
+	lib/rstp-common.h \
+	lib/rstp-state-machines.c \
+	lib/rstp-state-machines.h \
+	lib/sat-math.h \
+	lib/seq.c \
+	lib/seq.h \
+	lib/stp.c \
+	lib/stp.h \
+	lib/stream-provider.h \
+	lib/stream-ssl.h \
+	lib/tnl-ports.c \
+	lib/tnl-ports.h \
+	lib/token-bucket.c \
+	lib/type-props.h \
+	lib/unaligned.h \
+	lib/vconn-provider.h \
+	lib/vconn-stream.c \
+	lib/vconn.c \
 	lib/vlandev.c \
-	lib/vlandev.h \
-	lib/vlog.c \
-	lib/lldp/aa-structs.h \
-	lib/lldp/lldp.c \
-	lib/lldp/lldp-const.h \
-	lib/lldp/lldp-tlv.h \
-	lib/lldp/lldpd.c \
-	lib/lldp/lldpd.h \
-	lib/lldp/lldpd-structs.c \
-	lib/lldp/lldpd-structs.h
+	lib/vlandev.h
 
 if WIN32
-lib_libopenvswitch_la_SOURCES += \
+lib_libovscommon_la_SOURCES += \
 	lib/daemon-windows.c \
 	lib/getopt_long.c \
 	lib/getrusage-windows.c \
 	lib/latch-windows.c \
 	lib/route-table-stub.c \
-	lib/if-notifier-stub.c \
 	lib/strsep.c
 else
-lib_libopenvswitch_la_SOURCES += \
+lib_libovscommon_la_SOURCES += \
 	lib/daemon-unix.c \
 	lib/latch-unix.c \
 	lib/signals.c \
@@ -310,11 +542,9 @@ EXTRA_DIST += \
 	lib/stdio.h.in \
 	lib/string.h.in
 
-nodist_lib_libopenvswitch_la_SOURCES = \
-	lib/dirs.c \
-	lib/vswitch-idl.c \
-	lib/vswitch-idl.h
-CLEANFILES += $(nodist_lib_libopenvswitch_la_SOURCES)
+nodist_lib_libovscommon_la_SOURCES = \
+	lib/dirs.c
+CLEANFILES += $(nodist_lib_libovscommon_la_SOURCES)
 
 lib_LTLIBRARIES += lib/libsflow.la
 lib_libsflow_la_LDFLAGS = \
@@ -339,31 +569,44 @@ endif
 
 if LINUX
 lib_libopenvswitch_la_SOURCES += \
+	lib/ct-dpif.c \
+	lib/ct-dpif.h \
 	lib/dpif-netlink.c \
 	lib/dpif-netlink.h \
-	lib/if-notifier.c \
-	lib/if-notifier.h \
+	lib/geneve.h \
 	lib/netdev-linux.c \
 	lib/netdev-linux.h \
-	lib/netlink-conntrack.c \
-	lib/netlink-conntrack.h \
 	lib/netlink-notifier.c \
 	lib/netlink-notifier.h \
 	lib/netlink-protocol.h \
 	lib/netlink-socket.c \
 	lib/netlink-socket.h \
+	lib/ovs-lldp.c \
+	lib/ovs-lldp.h \
 	lib/ovs-numa.c \
 	lib/ovs-numa.h \
+	lib/route-table.c \
+	lib/route-table.h \
 	lib/rtnetlink.c \
 	lib/rtnetlink.h \
-	lib/route-table.c \
-	lib/route-table.h
+	lib/tun-metadata.c \
+	lib/tun-metadata.h \
+	lib/tnl-neigh-cache.c \
+	lib/tnl-neigh-cache.h \
+	lib/lldp/aa-structs.h \
+	lib/lldp/lldp.c \
+	lib/lldp/lldp-const.h \
+	lib/lldp/lldp-tlv.h \
+	lib/lldp/lldpd.c \
+	lib/lldp/lldpd.h \
+	lib/lldp/lldpd-structs.c \
+	lib/lldp/lldpd-structs.h
 endif
 
 if DPDK_NETDEV
 lib_libopenvswitch_la_SOURCES += \
-       lib/netdev-dpdk.c \
-       lib/netdev-dpdk.h
+	lib/netdev-dpdk.c \
+	lib/netdev-dpdk.h
 endif
 
 if WIN32
@@ -379,20 +622,18 @@ lib_libopenvswitch_la_SOURCES += \
 endif
 
 if HAVE_POSIX_AIO
-lib_libopenvswitch_la_SOURCES += lib/async-append-aio.c
+lib_libovscommon_la_SOURCES += lib/async-append-aio.c
 else
-lib_libopenvswitch_la_SOURCES += lib/async-append-null.c
+lib_libovscommon_la_SOURCES += lib/async-append-null.c
 endif
 
 if ESX
 lib_libopenvswitch_la_SOURCES += \
-	lib/route-table-stub.c \
-	lib/if-notifier-stub.c
+        lib/route-table-stub.c
 endif
 
 if HAVE_IF_DL
 lib_libopenvswitch_la_SOURCES += \
-	lib/if-notifier-bsd.c \
 	lib/netdev-bsd.c \
 	lib/rtbsd.c \
 	lib/rtbsd.h \
@@ -400,8 +641,8 @@ lib_libopenvswitch_la_SOURCES += \
 endif
 
 if HAVE_OPENSSL
-lib_libopenvswitch_la_SOURCES += lib/stream-ssl.c
-nodist_lib_libopenvswitch_la_SOURCES += lib/dhparams.c
+lib_libovscommon_la_SOURCES += lib/stream-ssl.c
+nodist_lib_libovscommon_la_SOURCES += lib/dhparams.c
 lib/dhparams.c: lib/dh1024.pem lib/dh2048.pem lib/dh4096.pem
 	$(AM_V_GEN)(echo '#include "lib/dhparams.h"' &&                 \
 	 openssl dhparam -C -in $(srcdir)/lib/dh1024.pem -noout &&	\
@@ -410,10 +651,11 @@ lib/dhparams.c: lib/dh1024.pem lib/dh2048.pem lib/dh4096.pem
 	| sed 's/\(get_dh[0-9]*\)()/\1(void)/' > lib/dhparams.c.tmp &&  \
 	mv lib/dhparams.c.tmp lib/dhparams.c
 else
-lib_libopenvswitch_la_SOURCES += lib/stream-nossl.c
+lib_libovscommon_la_SOURCES += lib/stream-nossl.c
 endif
 
 pkgconfig_DATA += \
+	$(srcdir)/lib/libovscommon.pc \
 	$(srcdir)/lib/libopenvswitch.pc \
 	$(srcdir)/lib/libsflow.pc
 
@@ -429,7 +671,6 @@ MAN_FRAGMENTS += \
 	lib/coverage-unixctl.man \
 	lib/daemon.man \
 	lib/daemon-syn.man \
-	lib/db-ctl-base.man \
 	lib/dpctl.man \
 	lib/memory-unixctl.man \
 	lib/ofp-version.man \
@@ -439,7 +680,6 @@ MAN_FRAGMENTS += \
 	lib/ssl-bootstrap.man \
 	lib/ssl-bootstrap-syn.man \
 	lib/ssl-peer-ca-cert.man \
-	lib/ssl-peer-ca-cert-syn.man \
 	lib/ssl.man \
 	lib/ssl-syn.man \
 	lib/table.man \
@@ -452,11 +692,18 @@ MAN_FRAGMENTS += \
 	lib/vlog.man
 
 # vswitch IDL
-OVSIDL_BUILT += lib/vswitch-idl.c lib/vswitch-idl.h lib/vswitch-idl.ovsidl
+OVSIDL_BUILT += \
+	$(srcdir)/lib/vswitch-idl.c \
+	$(srcdir)/lib/vswitch-idl.h \
+	$(srcdir)/lib/vswitch-idl.ovsidl
 
-EXTRA_DIST += lib/vswitch-idl.ann
-lib/vswitch-idl.ovsidl: vswitchd/vswitch.ovsschema lib/vswitch-idl.ann
-	$(AM_V_GEN)$(OVSDB_IDLC) annotate $(srcdir)/vswitchd/vswitch.ovsschema $(srcdir)/lib/vswitch-idl.ann > $@.tmp && mv $@.tmp $@
+EXTRA_DIST += $(srcdir)/lib/vswitch-idl.ann
+VSWITCH_IDL_FILES = \
+	$(srcdir)/vswitchd/vswitch.ovsschema \
+	$(srcdir)/lib/vswitch-idl.ann
+$(srcdir)/lib/vswitch-idl.ovsidl: $(VSWITCH_IDL_FILES)
+	$(AM_V_GEN)$(OVSDB_IDLC) annotate $(VSWITCH_IDL_FILES) > $@.tmp && \
+	mv $@.tmp $@
 
 lib/dirs.c: lib/dirs.c.in Makefile
 	$(AM_V_GEN)($(ro_c) && sed < $(srcdir)/lib/dirs.c.in \
@@ -465,6 +712,7 @@ lib/dirs.c: lib/dirs.c.in Makefile
 		-e 's,[@]RUNDIR[@],"$(RUNDIR)",g' \
 		-e 's,[@]DBDIR[@],"$(DBDIR)",g' \
 		-e 's,[@]bindir[@],"$(bindir)",g' \
+		-e 's,[@]libdir[@],"$(libdir)",g' \
 		-e 's,[@]sysconfdir[@],"$(sysconfdir)",g' \
 		-e 's,[@]pkgdatadir[@],"$(pkgdatadir)",g') \
 	     > lib/dirs.c.tmp && \
@@ -487,22 +735,22 @@ lib/ofp-actions.lo: lib/ofp-actions.inc1 lib/ofp-actions.inc2
 CLEANFILES += lib/ofp-actions.inc1 lib/ofp-actions.inc2
 EXTRA_DIST += build-aux/extract-ofp-actions
 
-lib/ofp-errors.inc: lib/ofp-errors.h include/openflow/openflow-common.h \
+$(srcdir)/lib/ofp-errors.inc: \
+	lib/ofp-errors.h include/openflow/openflow-common.h \
 	$(srcdir)/build-aux/extract-ofp-errors
 	$(AM_V_GEN)$(run_python) $(srcdir)/build-aux/extract-ofp-errors \
 		$(srcdir)/lib/ofp-errors.h \
 		$(srcdir)/include/openflow/openflow-common.h > $@.tmp && \
 	mv $@.tmp $@
-lib/ofp-errors.lo: lib/ofp-errors.inc
-CLEANFILES += lib/ofp-errors.inc
-EXTRA_DIST += build-aux/extract-ofp-errors
+$(srcdir)/lib/ofp-errors.c: $(srcdir)/lib/ofp-errors.inc
+EXTRA_DIST += build-aux/extract-ofp-errors lib/ofp-errors.inc
 
-lib/ofp-msgs.inc: lib/ofp-msgs.h $(srcdir)/build-aux/extract-ofp-msgs
+$(srcdir)/lib/ofp-msgs.inc: \
+	lib/ofp-msgs.h $(srcdir)/build-aux/extract-ofp-msgs
 	$(AM_V_GEN)$(run_python) $(srcdir)/build-aux/extract-ofp-msgs \
 		$(srcdir)/lib/ofp-msgs.h $@ > $@.tmp && mv $@.tmp $@
-lib/ofp-msgs.lo: lib/ofp-msgs.inc
-CLEANFILES += lib/ofp-msgs.inc
-EXTRA_DIST += build-aux/extract-ofp-msgs
+$(srcdir)/lib/ofp-msgs.c: $(srcdir)/lib/ofp-msgs.inc
+EXTRA_DIST += build-aux/extract-ofp-msgs lib/ofp-msgs.inc
 
 INSTALL_DATA_LOCAL += lib-install-data-local
 lib-install-data-local:
diff --git a/lib/command-line.h b/lib/command-line.h
index e9e3b7b..99f46cf 100644
--- a/lib/command-line.h
+++ b/lib/command-line.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -57,4 +58,8 @@ void ovs_cmdl_proctitle_set(const char *, ...)
 #endif
 void ovs_cmdl_proctitle_restore(void);
 
+#ifdef OPS
+#define long_options_to_short_options ovs_cmdl_long_options_to_short_options
+#define proctitle_init ovs_cmdl_proctitle_init
+#endif
 #endif /* command-line.h */
diff --git a/lib/daemon-unix.c b/lib/daemon-unix.c
index 182f76b..829c3af 100644
--- a/lib/daemon-unix.c
+++ b/lib/daemon-unix.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -434,15 +435,21 @@ monitor_daemon(pid_t daemon_pid)
  * daemon_complete()) or that it failed to start up (by exiting with a nonzero
  * exit code). */
 void
+#ifdef OPS
+daemonize_start(void)
+#else
 daemonize_start(bool access_datapath)
+#endif
 {
     assert_single_threaded();
     daemonize_fd = -1;
 
+#ifndef OPS
     if (switch_user) {
         daemon_become_new_user__(access_datapath);
         switch_user = false;
     }
+#endif
 
     if (detach) {
         pid_t pid;
diff --git a/lib/daemon.c b/lib/daemon.c
index b8313d4..d5163ef 100644
--- a/lib/daemon.c
+++ b/lib/daemon.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2014 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -41,7 +42,11 @@ get_detach(void)
 void
 daemonize(void)
 {
+#ifdef OPS
+    daemonize_start();
+#else
     daemonize_start(false);
+#endif
     daemonize_complete();
 }
 
diff --git a/lib/daemon.h b/lib/daemon.h
index 4990415..c1ad4a4 100644
--- a/lib/daemon.h
+++ b/lib/daemon.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2012 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -133,7 +134,11 @@ void set_pipe_handle(const char *pipe_handle);
 bool get_detach(void);
 void daemon_save_fd(int fd);
 void daemonize(void);
+#ifdef OPS
+void daemonize_start(void);
+#else
 void daemonize_start(bool access_datapath);
+#endif
 void daemonize_complete(void);
 void daemon_set_new_user(const char * user_spec);
 void daemon_become_new_user(bool access_datapath);
diff --git a/lib/dirs.c.in b/lib/dirs.c.in
index 85c49ee..f063648 100644
--- a/lib/dirs.c.in
+++ b/lib/dirs.c.in
@@ -110,3 +110,14 @@ ovs_bindir(void)
 
     return get_dir(&d);
 }
+
+#ifdef OPS
+const char *
+ovs_pluginsdir(void)
+{
+    static const char *dbdir;
+
+    dbdir = xasprintf("%s/openvswitch/plugins", @libdir@);
+    return dbdir;
+}
+#endif
diff --git a/lib/dpif-netlink.c b/lib/dpif-netlink.c
index 5e48393..83ee53b 100644
--- a/lib/dpif-netlink.c
+++ b/lib/dpif-netlink.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -57,6 +58,7 @@
 #include "openvswitch/vlog.h"
 
 VLOG_DEFINE_THIS_MODULE(dpif_netlink);
+#ifndef OPS_TEMP
 #ifdef _WIN32
 enum { WINDOWS = 1 };
 #else
@@ -2988,3 +2990,4 @@ report_loss(struct dpif_netlink *dpif, struct dpif_channel *ch, uint32_t ch_idx,
               dpif_name(&dpif->dpif), ch_idx, handler_id);
     ds_destroy(&s);
 }
+#endif
diff --git a/lib/dpif.c b/lib/dpif.c
index 38e40ba..cd28321 100644
--- a/lib/dpif.c
+++ b/lib/dpif.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -65,10 +66,12 @@ COVERAGE_DEFINE(dpif_purge);
 COVERAGE_DEFINE(dpif_execute_with_help);
 
 static const struct dpif_class *base_dpif_classes[] = {
+#ifndef OPS_TEMP
 #if defined(__linux__) || defined(_WIN32)
     &dpif_netlink_class,
 #endif
     &dpif_netdev_class,
+#endif
 };
 
 struct registered_dpif_class {
diff --git a/lib/libovscommon.pc b/lib/libovscommon.pc
new file mode 100644
index 0000000..c1f62cc
--- /dev/null
+++ b/lib/libovscommon.pc
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libovscommon
+Description: Open vSwitch common library
+Version: 2.5.0
+Libs: -L${libdir} -lovscommon
+Libs.private: @LIBS@
+Cflags: -I${includedir}/ovs
diff --git a/lib/libovscommon.pc.in b/lib/libovscommon.pc.in
new file mode 100644
index 0000000..18992e0
--- /dev/null
+++ b/lib/libovscommon.pc.in
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libovscommon
+Description: Open vSwitch common library
+Version: @VERSION@
+Libs: -L${libdir} -lovscommon
+Libs.private: @LIBS@
+Cflags: -I${includedir}/ovs
diff --git a/lib/libovscommon.sym.in b/lib/libovscommon.sym.in
new file mode 100644
index 0000000..fdfc5bb
--- /dev/null
+++ b/lib/libovscommon.sym.in
@@ -0,0 +1,4 @@
+libopenvswitch_@LT_CURRENT@ {
+global:
+        *;
+};
diff --git a/lib/netdev-bsd.c b/lib/netdev-bsd.c
index edf04bf..1dfb1b3 100644
--- a/lib/netdev-bsd.c
+++ b/lib/netdev-bsd.c
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2011, 2013, 2014 Gaetano Catalli.
  * Copyright (c) 2013, 2014 YAMAMOTO Takashi.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1557,6 +1558,10 @@ netdev_bsd_update_flags(struct netdev *netdev_, enum netdev_flags off,
     netdev_bsd_dealloc,                              \
     NULL, /* get_config */                           \
     NULL, /* set_config */                           \
+#ifdef OPS
+    NULL, /* set_hw_intf_info */                     \
+    NULL, /* set_hw_intf_config */                   \
+#endif
     NULL, /* get_tunnel_config */                    \
     NULL, /* build header */                         \
     NULL, /* push header */                          \
diff --git a/lib/netdev-dummy.c b/lib/netdev-dummy.c
index 5cd50a1..bf1efc8 100644
--- a/lib/netdev-dummy.c
+++ b/lib/netdev-dummy.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2010, 2011, 2012, 2013, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1119,6 +1120,10 @@ static const struct netdev_class dummy_class = {
     netdev_dummy_dealloc,
     netdev_dummy_get_config,
     netdev_dummy_set_config,
+#ifdef OPS
+    NULL,                       /* set_hw_intf_info */
+    NULL,                       /* set_hw_intf_config */
+#endif
     NULL,                       /* get_tunnel_config */
     NULL,                       /* build header */
     NULL,                       /* push header */
diff --git a/lib/netdev-linux.c b/lib/netdev-linux.c
index 393b4cc..dba9c92e 100644
--- a/lib/netdev-linux.c
+++ b/lib/netdev-linux.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -75,7 +76,7 @@
 #include "openvswitch/vlog.h"
 
 VLOG_DEFINE_THIS_MODULE(netdev_linux);
-
+#ifndef OPS_TEMP
 COVERAGE_DEFINE(netdev_set_policing);
 COVERAGE_DEFINE(netdev_arp_lookup);
 COVERAGE_DEFINE(netdev_get_ifindex);
@@ -2842,6 +2843,10 @@ netdev_linux_update_flags(struct netdev *netdev_, enum netdev_flags off,
     netdev_linux_dealloc,                                       \
     NULL,                       /* get_config */                \
     NULL,                       /* set_config */                \
+#ifdef OPS
+    NULL,                       /* set_hw_intf_info */          \
+    NULL,                       /* set_hw_intf_config */        \
+#endif
     NULL,                       /* get_tunnel_config */         \
     NULL,                       /* build header */              \
     NULL,                       /* push header */               \
@@ -5666,3 +5671,4 @@ af_packet_sock(void)
 
     return sock;
 }
+#endif
diff --git a/lib/netdev-provider.h b/lib/netdev-provider.h
index a33bb3b..e441216 100644
--- a/lib/netdev-provider.h
+++ b/lib/netdev-provider.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,6 +28,7 @@
 #include "seq.h"
 #include "shash.h"
 #include "smap.h"
+#include "ovs-atomic.h"
 
 #ifdef  __cplusplus
 extern "C" {
@@ -57,6 +59,9 @@ struct netdev {
     int n_rxq;
     int ref_cnt;                        /* Times this devices was opened. */
     struct shash_node *node;            /* Pointer to element in global map. */
+#ifdef OPS
+    struct shash_node *refd_node;  /* Pointer to element in netdev_refd map */
+#endif
     struct ovs_list saved_flags_list; /* Contains "struct netdev_saved_flags". */
 };
 
@@ -248,6 +253,20 @@ struct netdev_class {
      * pointer. */
     int (*set_config)(struct netdev *netdev, const struct smap *args);
 
+#ifdef OPS
+    /* Sets the device 'netdev''s hw_intf_info to 'args'.
+     *
+     * If this netdev class does not support hardware info, this may be a null
+     * pointer. */
+    int (*set_hw_intf_info)(struct netdev *netdev, const struct smap *args);
+
+    /* Changes the device 'netdev''s hw_intf_config to 'args'.
+     *
+     * If this netdev class does not support hardware configuration,
+     * this may be a null pointer. */
+    int (*set_hw_intf_config)(struct netdev *netdev, const struct smap *args);
+
+#endif
     /* Returns the tunnel configuration of 'netdev'.  If 'netdev' is
      * not a tunnel, returns null.
      *
diff --git a/lib/netdev-vport.c b/lib/netdev-vport.c
index 88f5022..e408220 100644
--- a/lib/netdev-vport.c
+++ b/lib/netdev-vport.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2010, 2011, 2012, 2013, 2014 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1467,6 +1468,18 @@ netdev_vport_range(struct unixctl_conn *conn, int argc,
     unixctl_command_reply(conn, "OK");
 }
 
+#ifdef OPS
+#define SET_HW_INTF_CONFIG NULL,
+#define SET_HW_INTF_INFO NULL,
+#define ENABLE_L3 NULL,
+#define DISABLE_L3 NULL,
+#else
+#define SET_HW_INTF_CONFIG
+#define SET_HW_INTF_INFO
+#define ENABLE_L3
+#define DISABLE_L3
+#endif
+
 
 #define VPORT_FUNCTIONS(GET_CONFIG, SET_CONFIG,             \
                         GET_TUNNEL_CONFIG, GET_STATUS,      \
@@ -1482,6 +1495,8 @@ netdev_vport_range(struct unixctl_conn *conn, int argc,
     netdev_vport_dealloc,                                   \
     GET_CONFIG,                                             \
     SET_CONFIG,                                             \
+    SET_HW_INTF_INFO            /* set_hw_intf_info */      \
+    SET_HW_INTF_CONFIG          /* set_hw_intf_config */    \
     GET_TUNNEL_CONFIG,                                      \
     BUILD_HEADER,                                           \
     PUSH_HEADER,                                            \
diff --git a/lib/netdev.c b/lib/netdev.c
index e3b70b1..7bfe618 100644
--- a/lib/netdev.c
+++ b/lib/netdev.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -67,6 +68,14 @@ static struct ovs_mutex netdev_mutex = OVS_MUTEX_INITIALIZER;
 static struct shash netdev_shash OVS_GUARDED_BY(netdev_mutex)
     = SHASH_INITIALIZER(&netdev_shash);
 
+#ifdef OPS
+/* Contains alls netdevs, even those that are "netdev_remove"d, but are
+ * still not unrefed and freed. Allows netdev_open to resurrect those netdevs
+ * avoiding creation of duplicates */
+static struct shash netdev_refd_shash OVS_GUARDED_BY(netdev_mutex)
+    = SHASH_INITIALIZER(&netdev_refd_shash);
+#endif
+
 /* Protects 'netdev_classes' against insertions or deletions.
  *
  * This is a recursive mutex to allow recursive acquisition when calling into
@@ -139,12 +148,13 @@ netdev_initialize(void)
         fatal_signal_add_hook(restore_all_flags, NULL, NULL, true);
         netdev_vport_patch_register();
 
-#ifdef __linux__
+#if defined (__linux__) && ! defined (OPS_TEMP)
         netdev_register_provider(&netdev_linux_class);
         netdev_register_provider(&netdev_internal_class);
         netdev_register_provider(&netdev_tap_class);
         netdev_vport_tunnel_register();
 #endif
+#ifndef OPS_TEMP
 #if defined(__FreeBSD__) || defined(__NetBSD__)
         netdev_register_provider(&netdev_tap_class);
         netdev_register_provider(&netdev_bsd_class);
@@ -155,7 +165,7 @@ netdev_initialize(void)
         netdev_vport_tunnel_register();
 #endif
         netdev_dpdk_register();
-
+#endif
         ovsthread_once_done(&once);
     }
 }
@@ -363,6 +373,11 @@ netdev_open(const char *name, const char *type, struct netdev **netdevp)
     if (!netdev) {
         struct netdev_registered_class *rc;
 
+#ifdef OPS
+        /* may be netdev was "netdev_remove"d, but still exists */
+        netdev = shash_find_data(&netdev_refd_shash, name);
+        if (!netdev) {
+#endif
         rc = netdev_lookup_class(type && type[0] ? type : "system");
         if (rc) {
             netdev = rc->class->alloc();
@@ -373,6 +388,9 @@ netdev_open(const char *name, const char *type, struct netdev **netdevp)
                 netdev->change_seq = 1;
                 netdev->node = shash_add(&netdev_shash, name, netdev);
 
+#ifdef OPS
+                    netdev->refd_node = shash_add(&netdev_refd_shash, name, netdev);
+#endif
                 /* By default enable one tx and rx queue per netdev. */
                 netdev->n_txq = netdev->netdev_class->send ? 1 : 0;
                 netdev->n_rxq = netdev->netdev_class->rxq_alloc ? 1 : 0;
@@ -387,6 +405,9 @@ netdev_open(const char *name, const char *type, struct netdev **netdevp)
                     free(netdev->name);
                     ovs_assert(list_is_empty(&netdev->saved_flags_list));
                     shash_delete(&netdev_shash, netdev->node);
+#ifdef OPS
+                        shash_delete(&netdev_refd_shash, netdev->refd_node);
+#endif
                     rc->class->dealloc(netdev);
                 }
             } else {
@@ -397,6 +418,13 @@ netdev_open(const char *name, const char *type, struct netdev **netdevp)
                       name, type);
             error = EAFNOSUPPORT;
         }
+#ifdef OPS
+        } else {
+            /* netdev is resurrected after it was previously "netdev_remove"d */
+            netdev->node = shash_add(&netdev_shash, name, netdev);
+            error = 0;
+        }
+#endif
     } else {
         error = 0;
     }
@@ -454,6 +482,52 @@ netdev_set_config(struct netdev *netdev, const struct smap *args, char **errp)
     return 0;
 }
 
+#ifdef OPS
+int
+netdev_set_hw_intf_info(struct netdev *netdev, const struct smap *args)
+    OVS_EXCLUDED(netdev_mutex)
+{
+    if (netdev->netdev_class->set_hw_intf_info) {
+        const struct smap no_args = SMAP_INITIALIZER(&no_args);
+        int error;
+
+        error = netdev->netdev_class->set_hw_intf_info(netdev,
+                                                       args ? args : &no_args);
+        if (error) {
+            VLOG_WARN("%s: could not set hardware info (%s)",
+                      netdev_get_name(netdev), ovs_strerror(error));
+        }
+        return error;
+    } else if (args && !smap_is_empty(args)) {
+        VLOG_WARN("%s: arguments provided to device that doesn't support hardware info",
+                  netdev_get_name(netdev));
+    }
+    return 0;
+}
+
+int
+netdev_set_hw_intf_config(struct netdev *netdev, const struct smap *args)
+    OVS_EXCLUDED(netdev_mutex)
+{
+    if (netdev->netdev_class->set_hw_intf_config) {
+        const struct smap no_args = SMAP_INITIALIZER(&no_args);
+        int error;
+
+        error = netdev->netdev_class->set_hw_intf_config(netdev,
+                                                         args ? args : &no_args);
+        if (error) {
+            VLOG_WARN("%s: could not set hardware config (%s)",
+                      netdev_get_name(netdev), ovs_strerror(error));
+        }
+        return error;
+    } else if (args && !smap_is_empty(args)) {
+        VLOG_WARN("%s: arguments provided to device that doesn't support hardware config",
+                  netdev_get_name(netdev));
+    }
+    return 0;
+}
+
+#endif
 /* Returns the current configuration for 'netdev' in 'args'.  The caller must
  * have already initialized 'args' with smap_init().  Returns 0 on success, in
  * which case 'args' will be filled with 'netdev''s configuration.  On failure
@@ -517,6 +591,13 @@ netdev_unref(struct netdev *dev)
         if (dev->node) {
             shash_delete(&netdev_shash, dev->node);
         }
+
+#ifdef OPS
+        if (dev->refd_node) {
+            shash_delete(&netdev_refd_shash, dev->refd_node);
+        }
+#endif
+
         free(dev->name);
         dev->netdev_class->dealloc(dev);
         ovs_mutex_unlock(&netdev_mutex);
@@ -1155,9 +1236,21 @@ do_update_flags(struct netdev *netdev, enum netdev_flags off,
     error = netdev->netdev_class->update_flags(netdev, off & ~on, on,
                                                &old_flags);
     if (error) {
+#ifdef OPS
+        if (error == EOPNOTSUPP) {
+            VLOG_DBG_RL(&rl, "%s flags for network device %s: %s not supported",
+                         off || on ? "set" : "get", netdev_get_name(netdev),
+                         ovs_strerror(error));
+        } else {
+            VLOG_WARN_RL(&rl, "failed to %s flags for network device %s: %s",
+                         off || on ? "set" : "get", netdev_get_name(netdev),
+                         ovs_strerror(error));
+        }
+#else
         VLOG_WARN_RL(&rl, "failed to %s flags for network device %s: %s",
                      off || on ? "set" : "get", netdev_get_name(netdev),
                      ovs_strerror(error));
+#endif
         old_flags = 0;
     } else if ((off || on) && sfp) {
         enum netdev_flags new_flags = (old_flags & ~off) | on;
diff --git a/lib/netdev.h b/lib/netdev.h
index 622e2ae..824dad6 100644
--- a/lib/netdev.h
+++ b/lib/netdev.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -156,6 +157,10 @@ void netdev_parse_name(const char *netdev_name, char **name, char **type);
 /* Options. */
 int netdev_set_config(struct netdev *, const struct smap *args, char **errp);
 int netdev_get_config(const struct netdev *, struct smap *);
+#ifdef OPS
+int netdev_set_hw_intf_info(struct netdev *, const struct smap *args);
+int netdev_set_hw_intf_config(struct netdev *, const struct smap *args);
+#endif
 const struct netdev_tunnel_config *
     netdev_get_tunnel_config(const struct netdev *);
 int netdev_get_numa_id(const struct netdev *);
diff --git a/lib/odp-util.c b/lib/odp-util.c
index 645a8f9..d398b26 100644
--- a/lib/odp-util.c
+++ b/lib/odp-util.c
@@ -510,7 +510,7 @@ format_odp_tnl_push_header(struct ds *ds, struct ovs_action_push_tnl *data)
                       gnh->oam ? "oam," : "",
                       gnh->critical ? "crit," : "",
                       ntohl(get_16aligned_be32(&gnh->vni)) >> 8);
- 
+
         if (gnh->opt_len) {
             ds_put_cstr(ds, ",options(");
             format_geneve_opts(gnh->options, NULL, gnh->opt_len * 4,
diff --git a/lib/ovsdb-data.c b/lib/ovsdb-data.c
index a62e92e..f04fa55 100644
--- a/lib/ovsdb-data.c
+++ b/lib/ovsdb-data.c
@@ -1642,6 +1642,36 @@ ovsdb_datum_find_key(const struct ovsdb_datum *datum,
     return UINT_MAX;
 }
 
+#ifdef OPS
+/*
+ * very specific data extraction function.  Given a "string" key,
+ * return the int64_t value.  It is assumed that the types of
+ * key & data are known and correct.  The requested value is
+ * returned in "value_extracted" but ONLY if the function
+ * returns 0 (no error).  If any errors are encountered, or
+ * the key does not exist in datum, function will return a
+ * non 0 value (error).
+ */
+int
+ovsdb_datum_get_int64_value_given_string_key (const struct ovsdb_datum *datum,
+    char *key, int64_t *value_extracted)
+{
+    unsigned int idx;
+    union ovsdb_atom key_atom;
+
+    if (NULL == datum) {
+        return -1;
+    }
+    key_atom.string = key;
+    idx = ovsdb_datum_find_key(datum, &key_atom, OVSDB_TYPE_STRING);
+    if (UINT_MAX == idx) {
+        return -1;
+    }
+    *value_extracted = datum->values[idx].integer;
+    return 0;
+}
+#endif
+
 /* If 'key' and 'value' is one of the key-value pairs in 'datum', returns its
  * index within 'datum', otherwise UINT_MAX.  'key.type' must be the type of
  * the atoms stored in the 'keys' array in 'datum'.  'value_type' may be the
diff --git a/lib/ovsdb-data.h b/lib/ovsdb-data.h
index e144c70..d93d014 100644
--- a/lib/ovsdb-data.h
+++ b/lib/ovsdb-data.h
@@ -189,6 +189,14 @@ bool ovsdb_datum_equals(const struct ovsdb_datum *,
 unsigned int ovsdb_datum_find_key(const struct ovsdb_datum *,
                                   const union ovsdb_atom *key,
                                   enum ovsdb_atomic_type key_type);
+#ifdef OPS
+/*
+ * given a string key, returns the corresponding int64_t value,
+ * but ONLY if function return value is 0 (no error).
+ */
+int ovsdb_datum_get_int64_value_given_string_key (const struct ovsdb_datum *datum,
+    char *key, int64_t *value_extracted);
+#endif
 unsigned int ovsdb_datum_find_key_value(const struct ovsdb_datum *,
                                         const union ovsdb_atom *key,
                                         enum ovsdb_atomic_type key_type,
diff --git a/lib/ovsdb-idl-provider.h b/lib/ovsdb-idl-provider.h
index 099535e..dd35e5a 100644
--- a/lib/ovsdb-idl-provider.h
+++ b/lib/ovsdb-idl-provider.h
@@ -1,4 +1,5 @@
 /* Copyright (c) 2009, 2010, 2011, 2012 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -36,6 +37,10 @@ struct ovsdb_idl_row {
     unsigned long int *prereqs; /* Bitmap of columns to verify in "old". */
     unsigned long int *written; /* Bitmap of columns from "new" to write. */
     struct hmap_node txn_node;  /* Node in ovsdb_idl_txn's list. */
+#ifdef OPS
+    unsigned int insert_seqno;
+    unsigned int modify_seqno;
+#endif
 
     unsigned int change_seqno[OVSDB_IDL_CHANGE_MAX];
     struct ovs_list track_node;
@@ -47,6 +52,9 @@ struct ovsdb_idl_column {
     bool mutable;
     void (*parse)(struct ovsdb_idl_row *, const struct ovsdb_datum *);
     void (*unparse)(struct ovsdb_idl_row *);
+#ifdef OPS
+    unsigned int modify_seqno;
+#endif
 };
 
 struct ovsdb_idl_table_class {
@@ -66,6 +74,11 @@ struct ovsdb_idl_table {
     struct shash columns;    /* Contains "const struct ovsdb_idl_column *"s. */
     struct hmap rows;        /* Contains "struct ovsdb_idl_row"s. */
     struct ovsdb_idl *idl;   /* Containing idl. */
+#ifdef OPS
+    unsigned int insert_seqno;
+    unsigned int modify_seqno;
+    unsigned int delete_seqno;
+#endif
     unsigned int change_seqno[OVSDB_IDL_CHANGE_MAX];
     struct ovs_list track_list; /* Tracked rows (ovsdb_idl_row.track_node). */
 };
diff --git a/lib/ovsdb-idl.c b/lib/ovsdb-idl.c
index 8f75bf0..0001f66 100644
--- a/lib/ovsdb-idl.c
+++ b/lib/ovsdb-idl.c
@@ -1,4 +1,5 @@
 /* Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -238,6 +239,9 @@ ovsdb_idl_create(const char *remote, const struct ovsdb_idl_class *class,
             = table->change_seqno[OVSDB_IDL_CHANGE_MODIFY]
             = table->change_seqno[OVSDB_IDL_CHANGE_DELETE] = 0;
         table->idl = idl;
+#ifdef OPS
+        table->insert_seqno = table->modify_seqno = table->delete_seqno = 0;
+#endif
     }
 
     idl->state_seqno = UINT_MAX;
@@ -994,6 +998,9 @@ ovsdb_idl_parse_update__(struct ovsdb_idl *idl,
 
             if (ovsdb_idl_process_update(table, &uuid, old_json, new_json)) {
                 idl->change_seqno++;
+#ifdef OPS
+                table->modify_seqno = idl->change_seqno;
+#endif
             }
         }
     }
@@ -1080,7 +1087,11 @@ ovsdb_idl_row_update(struct ovsdb_idl_row *row, const struct json *row_json,
 
     SHASH_FOR_EACH (node, json_object(row_json)) {
         const char *column_name = node->name;
+#ifdef OPS
+        struct ovsdb_idl_column *column;
+#else
         const struct ovsdb_idl_column *column;
+#endif
         struct ovsdb_datum datum;
         struct ovsdb_error *error;
 
@@ -1100,6 +1111,9 @@ ovsdb_idl_row_update(struct ovsdb_idl_row *row, const struct json *row_json,
                 ovsdb_datum_swap(old, &datum);
                 if (table->modes[column_idx] & OVSDB_IDL_ALERT) {
                     changed = true;
+#ifdef OPS
+                    column->modify_seqno = (row->table->idl->change_seqno + 1);
+#endif
                     row->change_seqno[change]
                         = row->table->change_seqno[change]
                         = row->table->idl->change_seqno + 1;
@@ -1348,6 +1362,12 @@ ovsdb_idl_insert_row(struct ovsdb_idl_row *row, const struct json *row_json)
     ovsdb_idl_row_parse(row);
 
     ovsdb_idl_row_reparse_backrefs(row);
+#ifdef OPS
+    row->insert_seqno = row->table->insert_seqno
+                      = row->modify_seqno
+                      = row->table->modify_seqno
+                      = (row->table->idl->change_seqno + 1);
+#endif
 }
 
 static void
@@ -1356,6 +1376,9 @@ ovsdb_idl_delete_row(struct ovsdb_idl_row *row)
     ovsdb_idl_row_unparse(row);
     ovsdb_idl_row_clear_arcs(row, true);
     ovsdb_idl_row_clear_old(row);
+#ifdef OPS
+    row->table->delete_seqno = (row->table->idl->change_seqno + 1);
+#endif
     if (list_is_empty(&row->dst_arcs)) {
         ovsdb_idl_row_destroy(row);
     } else {
@@ -1375,6 +1398,14 @@ ovsdb_idl_modify_row(struct ovsdb_idl_row *row, const struct json *row_json)
     changed = ovsdb_idl_row_update(row, row_json, OVSDB_IDL_CHANGE_MODIFY);
     ovsdb_idl_row_parse(row);
 
+#ifdef OPS
+    if( changed )
+    {
+        /* +1 because its incremented after this ft */
+        row->modify_seqno = (row->table->idl->change_seqno + 1);
+    }
+#endif
+
     return changed;
 }
 
diff --git a/lib/poll-loop.c b/lib/poll-loop.c
index e83d989..f821855 100644
--- a/lib/poll-loop.c
+++ b/lib/poll-loop.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,12 +33,17 @@
 #include "openvswitch/vlog.h"
 #include "hmap.h"
 #include "hash.h"
+#ifdef OPS
+#include "poll-loop.h"
+#endif
 
 VLOG_DEFINE_THIS_MODULE(poll_loop);
 
 COVERAGE_DEFINE(poll_create_node);
 COVERAGE_DEFINE(poll_zero_timeout);
 
+
+#ifndef OPS
 struct poll_node {
     struct hmap_node hmap_node;
     struct pollfd pollfd;       /* Events to pass to time_poll(). */
@@ -54,8 +60,11 @@ struct poll_loop {
     long long int timeout_when; /* In msecs as returned by time_msec(). */
     const char *timeout_where;  /* Where 'timeout_when' was set. */
 };
+#endif
 
+#ifndef OPS
 static struct poll_loop *poll_loop(void);
+#endif
 
 /* Look up the node with same fd or wevent. */
 static struct poll_node *
@@ -295,7 +304,11 @@ log_wakeup(const char *where, const struct pollfd *pollfd, int timeout)
     ds_destroy(&s);
 }
 
+#ifdef OPS
+void
+#else
 static void
+#endif
 free_poll_nodes(struct poll_loop *loop)
 {
     struct poll_node *node, *next;
@@ -400,7 +413,11 @@ free_poll_loop(void *loop_)
     free(loop);
 }
 
+#ifdef OPS
+struct poll_loop *
+#else
 static struct poll_loop *
+#endif
 poll_loop(void)
 {
     static struct ovsthread_once once = OVSTHREAD_ONCE_INITIALIZER;
diff --git a/lib/poll-loop.h b/lib/poll-loop.h
index 01e1aa8..dafa5d0 100644
--- a/lib/poll-loop.h
+++ b/lib/poll-loop.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2013 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -35,6 +36,9 @@
 
 #include <poll.h>
 #include "util.h"
+#ifdef OPS
+#include "hmap.h"
+#endif
 
 #ifdef  __cplusplus
 extern "C" {
@@ -70,6 +74,31 @@ void poll_immediate_wake_at(const char *where);
 /* Wait until an event occurs. */
 void poll_block(void);
 
+#ifdef OPS
+struct poll_node {
+    struct hmap_node hmap_node;
+    struct pollfd pollfd;       /* Events to pass to time_poll(). */
+    HANDLE wevent;              /* Events for WaitForMultipleObjects(). */
+    const char *where;          /* Where poll_node was created. */
+
+    void *event;                /* placeholder for exporting events
+                                   to a foreign poll mechanism */
+};
+
+struct poll_loop {
+    /* All active poll waiters. */
+    struct hmap poll_nodes;
+
+    /* Time at which to wake up the next call to poll_block(), LLONG_MIN to
+     * wake up immediately, or LLONG_MAX to wait forever. */
+    long long int timeout_when; /* In msecs as returned by time_msec(). */
+    const char *timeout_where;  /* Where 'timeout_when' was set. */
+};
+
+struct poll_loop *poll_loop(void);
+void free_poll_nodes(struct poll_loop *loop);
+#endif
+
 #ifdef  __cplusplus
 }
 #endif
diff --git a/lib/socket-util-unix.c b/lib/socket-util-unix.c
index 32f966d..8c56b63 100644
--- a/lib/socket-util-unix.c
+++ b/lib/socket-util-unix.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2014 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -49,6 +50,12 @@ VLOG_DEFINE_THIS_MODULE(socket_util_unix);
  * space for a null terminator. */
 #define MAX_UN_LEN (sizeof(((struct sockaddr_un *) 0)->sun_path) - 1)
 
+#ifdef OPS
+/* Group-ID of "ovsdb_users" group */
+#define OVSDB_USERS_GROUP_ID 1020
+#endif /* OPS */
+
+
 void
 xpipe(int fds[2])
 {
@@ -346,6 +353,16 @@ make_unix_socket(int style, bool nonblock,
         error = make_sockaddr_un(bind_path, &un, &un_len, &dirfd, linkname);
         if (!error) {
             error = bind_unix_socket(fd, (struct sockaddr *) &un, un_len);
+#ifdef OPS
+            if(0 != chmod(bind_path, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP))
+            {
+              VLOG_ERR("\nError while changing mode of socket file - %s.\n", bind_path);
+            }
+            if(0 != chown(bind_path, -1, OVSDB_USERS_GROUP_ID))
+            {
+              VLOG_ERR("\nError while changing group of socket file - %s.\n", bind_path);
+            }
+#endif /* OPS */
         }
         free_sockaddr_un(dirfd, linkname);
 
diff --git a/lib/vlan-bitmap.h b/lib/vlan-bitmap.h
index 3e2e820..e5d2e0b 100644
--- a/lib/vlan-bitmap.h
+++ b/lib/vlan-bitmap.h
@@ -1,4 +1,5 @@
 /* Copyright (c) 2011 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,6 +28,10 @@
  *
  * This is empirically a useful data structure. */
 
+#ifdef OPS
+#define VLAN_BITMAP_SIZE 4096
+#endif
+
 unsigned long *vlan_bitmap_from_array(const int64_t *vlans, size_t n_vlans);
 int vlan_bitmap_from_array__(const int64_t *vlans, size_t n_vlans,
                              unsigned long int *b);
diff --git a/lib/vlandev.c b/lib/vlandev.c
index d2a3191..63a7fd9 100644
--- a/lib/vlandev.c
+++ b/lib/vlandev.c
@@ -38,7 +38,7 @@ struct vlandev_class {
     int (*vd_del)(const char *vlan_dev);
 };
 
-#ifdef __linux__
+#if defined ( __linux__) && ! defined (OPS_TEMP)
 static const struct vlandev_class vlandev_linux_class;
 #endif
 static const struct vlandev_class vlandev_stub_class;
@@ -61,7 +61,7 @@ static const struct vlandev_class *
 vlandev_get_class(void)
 {
     if (!vd_class) {
-#if __linux__
+#if defined ( __linux__) && ! defined (OPS_TEMP)
         vd_class = &vlandev_linux_class;
 #else
         vd_class = &vlandev_stub_class;
@@ -161,7 +161,7 @@ vlandev_get_name(const char *real_dev_name, int vid)
 
 /* The Linux vlandev implementation. */
 
-#ifdef __linux__
+#if defined ( __linux__) && ! defined (OPS_TEMP)
 #include "rtnetlink.h"
 #include <linux/if_vlan.h>
 #include <linux/sockios.h>
diff --git a/lib/vswitch-idl.ann b/lib/vswitch-idl.ann
index e8ed743..9ea4f63 100644
--- a/lib/vswitch-idl.ann
+++ b/lib/vswitch-idl.ann
@@ -7,3 +7,5 @@
 
 s["idlPrefix"] = "ovsrec_"
 s["idlHeader"] = "\"lib/vswitch-idl.h\""
+# OPS
+s["idlTableAliases"] = [{"target":"system", "name":"open_vswitch"}]
diff --git a/m4/openvswitch.m4 b/m4/openvswitch.m4
index 0cfaae6..079ebb2 100644
--- a/m4/openvswitch.m4
+++ b/m4/openvswitch.m4
@@ -14,7 +14,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
-m4_include([m4/compat.at])
+m4_sinclude([m4/compat.at])
 
 dnl Checks for --enable-coverage and updates CFLAGS and LDFLAGS appropriately.
 AC_DEFUN([OVS_CHECK_COVERAGE],
@@ -70,22 +70,6 @@ AC_DEFUN([OVS_CHECK_ESX],
       AC_DEFINE([ESX], [1], [Define to 1 if building on ESX.])
    fi])
 
-dnl Checks for MSVC x64 compiler.
-AC_DEFUN([OVS_CHECK_WIN64],
-  [AC_CACHE_CHECK(
-    [for MSVC x64 compiler],
-    [cl_cv_x64],
-    [dnl "cl" writes x64 output to stdin:
-     if (cl) 2>&1 | grep 'x64' >/dev/null 2>&1; then
-       cl_cv_x64=yes
-       MSVC64_LDFLAGS=" /MACHINE:X64 "
-     else
-       cl_cv_x64=no
-       MSVC64_LDFLAGS=""
-     fi])
-     AC_SUBST([MSVC64_LDFLAGS])
-])
-
 dnl Checks for WINDOWS.
 AC_DEFUN([OVS_CHECK_WIN32],
   [AC_CHECK_HEADER([windows.h],
@@ -102,25 +86,9 @@ AC_DEFUN([OVS_CHECK_WIN32],
             AC_MSG_ERROR([Invalid --with-pthread value])
               ;;
             *)
-            if (cl) 2>&1 | grep 'x64' >/dev/null 2>&1; then
-              cl_cv_x64=yes
-            else
-              cl_cv_x64=no
-            fi
-            if test "$cl_cv_x64" = yes; then
-                PTHREAD_WIN32_DIR=$withval/lib/x64
-                PTHREAD_WIN32_DIR_DLL=/$(echo ${withval} | ${SED} -e 's/://')/dll/x64
-                PTHREAD_WIN32_DIR_DLL_WIN_FORM=$withval/dll/x64
-            else
-                PTHREAD_WIN32_DIR=$withval/lib/x86
-                PTHREAD_WIN32_DIR_DLL=/$(echo ${withval} | ${SED} -e 's/://')/dll/x86
-                PTHREAD_WIN32_DIR_DLL_WIN_FORM=$withval/dll/x86
-            fi
-            PTHREAD_INCLUDES=-I$withval/include
-            PTHREAD_LDFLAGS=-L$PTHREAD_WIN32_DIR
+            PTHREAD_INCLUDES="-I$withval/include"
+            PTHREAD_LDFLAGS="-L$withval/lib/x86"
             PTHREAD_LIBS="-lpthreadVC2"
-            AC_SUBST([PTHREAD_WIN32_DIR_DLL_WIN_FORM])
-            AC_SUBST([PTHREAD_WIN32_DIR_DLL])
             AC_SUBST([PTHREAD_INCLUDES])
             AC_SUBST([PTHREAD_LDFLAGS])
             AC_SUBST([PTHREAD_LIBS])
@@ -152,14 +120,16 @@ dnl OVS_CHECK_WINDOWS
 dnl
 dnl Configure Visual Studio solution build
 AC_DEFUN([OVS_CHECK_VISUAL_STUDIO_DDK], [
-AC_ARG_WITH([vstudiotarget],
-         [AS_HELP_STRING([--with-vstudiotarget=target_type],
-            [Target type: Debug/Release])],
+AC_ARG_WITH([vstudioddk],
+         [AS_HELP_STRING([--with-vstudioddk=version_type],
+            [Visual Studio DDK version type e.g. Win8.1 Release])],
          [
             case "$withval" in
-            "Release") ;;
-            "Debug") ;;
-            *) AC_MSG_ERROR([No valid Visual Studio configuration found]) ;;
+            "Win8.1 Release") ;;
+            "Win8.1 Debug") ;;
+            "Win8 Release") ;;
+            "Win8 Debug") ;;
+            *) AC_MSG_ERROR([No good Visual Studio configuration found]) ;;
             esac
 
             VSTUDIO_CONFIG=$withval
@@ -169,7 +139,7 @@ AC_ARG_WITH([vstudiotarget],
       )
 
   AC_SUBST([VSTUDIO_CONFIG])
-  AC_DEFINE([VSTUDIO_DDK], [1], [System uses the Visual Studio build target.])
+  AC_DEFINE([VSTUDIO_DDK], [1], [System uses the Visual Studio DDK version module.])
   AM_CONDITIONAL([VSTUDIO_DDK], [test -n "$VSTUDIO_CONFIG"])
 ])
 
@@ -186,42 +156,6 @@ AC_DEFUN([OVS_CHECK_NETLINK],
                 [Define to 1 if Netlink protocol is available.])
    fi])
 
-dnl Checks for libcap-ng.
-AC_DEFUN([OVS_CHECK_LIBCAPNG],
-  [AC_ARG_ENABLE(
-     [libcapng],
-     [AC_HELP_STRING([--disable-libcapng], [Disable Linux capability support])],
-     [case "${enableval}" in
-        (yes) libcapng=true ;;
-        (no)  libcapng=false ;;
-        (*) AC_MSG_ERROR([bad value ${enableval} for --enable-libcapng]) ;;
-      esac],
-     [libcapng=check])
-
-   if test "$libcapng" != false; then
-       AC_CHECK_LIB([cap-ng], [capng_clear], [HAVE_LIBCAPNG=yes])
-
-       if test "$HAVE_LIBCAPNG" != yes; then
-           if test "$libcapng" = true ; then
-                AC_MSG_ERROR([libcap-ng support requested, but not found])
-           fi
-           if test "$libcapng" = check ; then
-                 AC_MSG_WARN([cannot find libcap-ng.
---user option will not be supported on Linux.
-(you may use --disable-libcapng to suppress this warning). ])
-           fi
-       fi
-   fi
-
-   AC_SUBST([HAVE_LIBCAPNG])
-   AM_CONDITIONAL([HAVE_LIBCAPNG], [test "$HAVE_LIBCAPNG" = yes])
-   if test "$HAVE_LIBCAPNG" = yes; then
-      AC_DEFINE([HAVE_LIBCAPNG], [1],
-                [Define to 1 if libcap-ng is available.])
-      CAPNG_LDADD="-lcap-ng"
-      AC_SUBST([CAPNG_LDADD])
-   fi])
-
 dnl Checks for OpenSSL.
 AC_DEFUN([OVS_CHECK_OPENSSL],
   [AC_ARG_ENABLE(
@@ -309,30 +243,26 @@ AC_DEFUN([OVS_CHECK_BACKTRACE],
                   [AC_DEFINE([HAVE_BACKTRACE], [1],
                              [Define to 1 if you have backtrace(3).])])])
 
-dnl Defines HAVE_PERF_EVENT if linux/perf_event.h is found.
-AC_DEFUN([OVS_CHECK_PERF_EVENT],
-  [AC_CHECK_HEADERS([linux/perf_event.h])])
-
 dnl Checks for valgrind/valgrind.h.
 AC_DEFUN([OVS_CHECK_VALGRIND],
   [AC_CHECK_HEADERS([valgrind/valgrind.h])])
 
-dnl Checks for Python 2.x, x >= 7.
+dnl Checks for Python 2.x, x >= 4.
 AC_DEFUN([OVS_CHECK_PYTHON],
   [AC_CACHE_CHECK(
-     [for Python 2.x for x >= 7],
+     [for Python 2.x for x >= 4],
      [ovs_cv_python],
      [if test -n "$PYTHON"; then
         ovs_cv_python=$PYTHON
       else
         ovs_cv_python=no
-        for binary in python python2.7; do
+        for binary in python python2.4 python2.5 python2.7; do
           ovs_save_IFS=$IFS; IFS=$PATH_SEPARATOR
           for dir in $PATH; do
             IFS=$ovs_save_IFS
             test -z "$dir" && dir=.
             if test -x "$dir"/"$binary" && "$dir"/"$binary" -c 'import sys
-if sys.hexversion >= 0x02070000 and sys.hexversion < 0x03000000:
+if sys.hexversion >= 0x02040000 and sys.hexversion < 0x03000000:
     sys.exit(0)
 else:
     sys.exit(1)'; then
@@ -365,6 +295,36 @@ AC_DEFUN([OVS_CHECK_DOT],
      fi])
    AM_CONDITIONAL([HAVE_DOT], [test "$ovs_cv_dot" = yes])])
 
+dnl Checks whether $PYTHON supports the module given as $1
+AC_DEFUN([OVS_CHECK_PYTHON_MODULE],
+  [AC_REQUIRE([OVS_CHECK_PYTHON])
+   AC_CACHE_CHECK(
+     [for $1 Python module],
+     [ovs_cv_py_[]AS_TR_SH([$1])],
+     [ovs_cv_py_[]AS_TR_SH([$1])=no
+      if test $HAVE_PYTHON = yes; then
+        AS_ECHO(["running $PYTHON -c 'import $1
+import sys
+sys.exit(0)'..."]) >&AS_MESSAGE_LOG_FD 2>&1
+        if $PYTHON -c 'import $1
+import sys
+sys.exit(0)' >&AS_MESSAGE_LOG_FD 2>&1; then
+          ovs_cv_py_[]AS_TR_SH([$1])=yes
+        fi
+      fi])])
+
+dnl Checks for missing python modules at build time
+AC_DEFUN([OVS_CHECK_PYTHON_COMPAT],
+  [OVS_CHECK_PYTHON_MODULE([uuid])
+   if test $ovs_cv_py_uuid = yes; then
+     INCLUDE_PYTHON_COMPAT=no
+   else
+     INCLUDE_PYTHON_COMPAT=yes
+   fi
+   AC_MSG_CHECKING([whether to add python/compat to PYTHONPATH])
+   AC_MSG_RESULT([$INCLUDE_PYTHON_COMPAT])
+   AM_CONDITIONAL([INCLUDE_PYTHON_COMPAT], [test $INCLUDE_PYTHON_COMPAT = yes])])
+
 dnl Checks for groff.
 AC_DEFUN([OVS_CHECK_GROFF],
   [AC_CACHE_CHECK(
diff --git a/manpages.mk b/manpages.mk
index 6141242..73ab582 100644
--- a/manpages.mk
+++ b/manpages.mk
@@ -1,17 +1,5 @@
 # Generated automatically -- do not modify!    -*- buffer-read-only: t -*-
 
-ovn/utilities/ovn-sbctl.8: \
-	ovn/utilities/ovn-sbctl.8.in \
-	lib/db-ctl-base.man \
-	lib/table.man \
-	ovsdb/remote-active.man \
-	ovsdb/remote-passive.man
-ovn/utilities/ovn-sbctl.8.in:
-lib/db-ctl-base.man:
-lib/table.man:
-ovsdb/remote-active.man:
-ovsdb/remote-passive.man:
-
 ovsdb/ovsdb-client.1: \
 	ovsdb/ovsdb-client.1.in \
 	lib/common-syn.man \
@@ -291,29 +279,3 @@ ofproto/ofproto-tnl-unixctl.man:
 ofproto/ofproto-unixctl.man:
 ovsdb/remote-active.man:
 ovsdb/remote-passive.man:
-
-vtep/vtep-ctl.8: \
-	vtep/vtep-ctl.8.in \
-	lib/common.man \
-	lib/db-ctl-base.man \
-	lib/ssl-bootstrap.man \
-	lib/ssl-peer-ca-cert.man \
-	lib/ssl.man \
-	lib/table.man \
-	lib/vlog.man \
-	ovsdb/remote-active.man \
-	ovsdb/remote-active.man \
-	ovsdb/remote-passive.man \
-	ovsdb/remote-passive.man
-vtep/vtep-ctl.8.in:
-lib/common.man:
-lib/db-ctl-base.man:
-lib/ssl-bootstrap.man:
-lib/ssl-peer-ca-cert.man:
-lib/ssl.man:
-lib/table.man:
-lib/vlog.man:
-ovsdb/remote-active.man:
-ovsdb/remote-active.man:
-ovsdb/remote-passive.man:
-ovsdb/remote-passive.man:
diff --git a/ofproto/automake.mk b/ofproto/automake.mk
index 0058ff3..835759a 100644
--- a/ofproto/automake.mk
+++ b/ofproto/automake.mk
@@ -4,6 +4,16 @@
 # are permitted in any medium without royalty provided the copyright
 # notice and this notice are preserved.  This file is offered as-is,
 # without warranty of any kind.
+if OPS
+ovsofprotolibincludedir = $(includedir)/ovs/ofproto
+ovsofprotolibinclude_HEADERS = \
+       ofproto/bond.h \
+       ofproto/fail-open.h \
+       ofproto/netflow.h \
+       ofproto/ofproto.h \
+       ofproto/ofproto-provider.h \
+       ofproto/tunnel.h
+endif
 
 lib_LTLIBRARIES += ofproto/libofproto.la
 ofproto_libofproto_la_LDFLAGS = \
diff --git a/ofproto/bond.c b/ofproto/bond.c
index c2749e5..b4b276c 100644
--- a/ofproto/bond.c
+++ b/ofproto/bond.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -200,7 +201,19 @@ bond_mode_from_string(enum bond_mode *balance, const char *s)
         *balance = BM_SLB;
     } else if (!strcmp(s, bond_mode_to_string(BM_AB))) {
         *balance = BM_AB;
-    } else {
+    }
+#ifdef OPS
+    else if (!strcmp(s, bond_mode_to_string(BM_L2_SRC_DST_HASH))) {
+        *balance = BM_L2_SRC_DST_HASH;
+    }
+    else if (!strcmp(s, bond_mode_to_string(BM_L3_SRC_DST_HASH))) {
+        *balance = BM_L3_SRC_DST_HASH;
+    }
+    else if (!strcmp(s, bond_mode_to_string(BM_L4_SRC_DST_HASH))) {
+        *balance = BM_L4_SRC_DST_HASH;
+    }
+#endif
+    else {
         return false;
     }
     return true;
@@ -216,6 +229,14 @@ bond_mode_to_string(enum bond_mode balance) {
         return "balance-slb";
     case BM_AB:
         return "active-backup";
+#ifdef OPS
+    case BM_L2_SRC_DST_HASH:
+        return "l2-src-dst-hash";
+    case BM_L3_SRC_DST_HASH:
+        return "l3-src-dst-hash";
+    case BM_L4_SRC_DST_HASH:
+        return "l4-src-dst-hash";
+#endif
     }
     OVS_NOT_REACHED();
 }
@@ -831,6 +852,15 @@ bond_check_admissibility(struct bond *bond, const void *slave_,
          * bond slaves. */
         verdict = BV_DROP_IF_MOVED;
         goto out;
+
+#ifdef OPS
+        /* OPS doesn't use software based data path. So we will never reach
+         * this code path. Making this change to avoid compiler warnings. */
+    case BM_L4_SRC_DST_HASH:
+    case BM_L3_SRC_DST_HASH:
+    case BM_L2_SRC_DST_HASH:
+        goto out;
+#endif
     }
 
     OVS_NOT_REACHED();
diff --git a/ofproto/bond.h b/ofproto/bond.h
index 9a5ea9e..96c63dc 100644
--- a/ofproto/bond.h
+++ b/ofproto/bond.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2014 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,7 +33,14 @@ enum lacp_status;
 enum bond_mode {
     BM_TCP, /* Transport Layer Load Balance. */
     BM_SLB, /* Source Load Balance. */
+#ifdef OPS
+    BM_AB,               /* Active Backup. */
+    BM_L2_SRC_DST_HASH,  /* Layer 2 Src and Dest Mac Hash */
+    BM_L3_SRC_DST_HASH,  /* Layer 3 Src and Dest IP Hash */
+    BM_L4_SRC_DST_HASH   /* Layer 4 Src and Dest IP Hash */
+#else
     BM_AB   /* Active Backup. */
+#endif
 };
 
 bool bond_mode_from_string(enum bond_mode *, const char *);
diff --git a/ofproto/ofproto-dpif-sflow.h b/ofproto/ofproto-dpif-sflow.h
index 014e6cc..74f6769 100644
--- a/ofproto/ofproto-dpif-sflow.h
+++ b/ofproto/ofproto-dpif-sflow.h
@@ -40,7 +40,7 @@ struct dpif_sflow_actions {
     struct flow_tnl tunnel;  /* Egress tunnel push/set. */
     uint8_t tunnel_ipproto;  /* Tunnel push action can set ipproto. */
     bool tunnel_err;         /* Tunnel actions parse failure. */
-    
+
     /* Using host-byte order for the mpls stack here
        to match the expectations of the sFlow library. Also
        the ordering is reversed, so that the entry at offset 0
diff --git a/ofproto/ofproto-dpif.c b/ofproto/ofproto-dpif.c
index f429114..9fb4cb9 100644
--- a/ofproto/ofproto-dpif.c
+++ b/ofproto/ofproto-dpif.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -5791,6 +5792,10 @@ const struct ofproto_class ofproto_dpif_class = {
     set_queues,
     bundle_set,
     bundle_remove,
+#ifdef OPS
+    NULL,                       /* bundle_get */
+    NULL,                       /* set_vlan */
+#endif
     mirror_set__,
     mirror_get_stats__,
     set_flood_vlans,
@@ -5811,4 +5816,12 @@ const struct ofproto_class ofproto_dpif_class = {
     group_modify,               /* group_modify */
     group_get_stats,            /* group_get_stats */
     get_datapath_version,       /* get_datapath_version */
+#ifdef OPS
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+#endif
 };
diff --git a/ofproto/ofproto-provider.h b/ofproto/ofproto-provider.h
index 2a6bd91..e1d2775 100644
--- a/ofproto/ofproto-provider.h
+++ b/ofproto/ofproto-provider.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -136,6 +137,10 @@ struct ofproto {
     struct hmap groups OVS_GUARDED;   /* Contains "struct ofgroup"s. */
     uint32_t n_groups[4] OVS_GUARDED; /* # of existing groups of each type. */
     struct ofputil_group_features ogf;
+#ifdef OPS
+    /* VLAN support. */
+    unsigned long int *vlans_bmp;  /* Bitmap of all configured VLANs. */
+#endif
 };
 
 void ofproto_init_tables(struct ofproto *, int n_tables);
@@ -1597,6 +1602,20 @@ struct ofproto_class {
      * one port, deconfigures the bundle's bonding configuration. */
     void (*bundle_remove)(struct ofport *ofport);
 
+#ifdef OPS
+    /* Retrieves information about bundle on 'ofproto'.
+     *
+     * Stores bundle information for 'ofproto' in 'bundle_handle'. */
+    int (*bundle_get)(struct ofproto *ofproto, void *aux, int *bundle_handle);
+
+    /* Configures VLANs.
+     *
+     * This function affects only the behavior of the OFPP_NORMAL action.  An
+     * implementation that does not support it may set it to NULL or return
+     * EOPNOTSUPP. */
+    int (*set_vlan)(struct ofproto *ofproto, int vid, bool add);
+#endif
+
     /* If 's' is nonnull, this function registers a mirror associated with
      * client data pointer 'aux' in 'ofproto'.  A mirror is the same concept as
      * a Mirror in OVSDB.  If 'aux' is already registered then this function
@@ -1764,6 +1783,34 @@ struct ofproto_class {
      * This function should be NULL if an implementation does not support it.
      */
     const char *(*get_datapath_version)(const struct ofproto *);
+
+#ifdef OPS
+    /* Add L3 host entry. */
+    int (*add_l3_host_entry)(const struct ofproto *ofproto, void *aux,
+                             bool is_ipv6_addr, char *ip_addr,
+                             char *next_hop_mac_addr, int *l3_egress_id);
+
+    /* Delete L3 host entry. */
+    int (*delete_l3_host_entry)(const struct ofproto *ofproto, void *aux,
+                                bool is_ipv6_addr, char *ip_addr,
+                                int *l3_egress_id);
+
+    /* Get L3 host hit bit. */
+    int (*get_l3_host_hit)(const struct ofproto *ofproto, void *aux,
+                           bool is_ipv6_addr, char *ip_addr, bool *hit_bit);
+
+    /* Add/Delete/Modify routes */
+    int (*l3_route_action)(const struct ofproto *ofproto,
+                           enum ofproto_route_action action,
+                           struct ofproto_route *route);
+
+    /* Enable/Disable ECMP */
+    int (*l3_ecmp_set)(const struct ofproto *ofproto, bool enable);
+
+    /* Enable/Disable ECMP hash config */
+    int (*l3_ecmp_hash_set)(const struct ofproto *ofproto, unsigned int hash,
+                            bool enable);
+#endif
 };
 
 extern const struct ofproto_class ofproto_dpif_class;
diff --git a/ofproto/ofproto.c b/ofproto/ofproto.c
index a5ce04e..7c69ffb 100644
--- a/ofproto/ofproto.c
+++ b/ofproto/ofproto.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2009-2015 Nicira, Inc.
- * Copyright (c) 2010 Jean Tourrilhes - HP-Labs.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -61,6 +61,9 @@
 #include "unixctl.h"
 #include "openvswitch/vlog.h"
 #include "bundles.h"
+#ifdef OPS
+#include "vlan-bitmap.h"
+#endif
 
 VLOG_DEFINE_THIS_MODULE(ofproto);
 
@@ -365,7 +368,9 @@ ofproto_init(const struct shash *iface_hints)
     struct shash_node *node;
     size_t i;
 
+#ifndef OPS_TEMP
     ofproto_class_register(&ofproto_dpif_class);
+#endif
 
     /* Make a local copy, since we don't own 'iface_hints' elements. */
     SHASH_FOR_EACH(node, iface_hints) {
@@ -608,6 +613,10 @@ ofproto_create(const char *datapath_name, const char *datapath_type,
     /* Set the initial tables version. */
     ofproto_bump_tables_version(ofproto);
 
+#ifdef OPS
+    ofproto->vlans_bmp = bitmap_allocate(VLAN_BITMAP_SIZE);
+#endif
+
     *ofprotop = ofproto;
     return 0;
 }
@@ -1316,6 +1325,41 @@ ofproto_bundle_unregister(struct ofproto *ofproto, void *aux)
     return ofproto_bundle_register(ofproto, aux, NULL);
 }
 
+#ifdef OPS
+/* Retrieves bundle information in 'ofproto'.
+ * Stores bundle handle in 'bundle_handle'. */
+int
+ofproto_bundle_get(struct ofproto *ofproto, void *aux,
+                   int *bundle_handle)
+{
+    if (!ofproto->ofproto_class->bundle_get) {
+        *bundle_handle = -1;
+        return EOPNOTSUPP;
+    }
+
+    return ofproto->ofproto_class->bundle_get(ofproto, aux, bundle_handle);
+}
+
+
+/* VLANs. */
+int
+ofproto_set_vlan(struct ofproto *ofproto, int vid, bool add)
+{
+    int rc = 0;
+
+    if (ofproto->ofproto_class->set_vlan) {
+        rc = ofproto->ofproto_class->set_vlan(ofproto, vid, add);
+        if (rc == 0) {
+            bitmap_set(ofproto->vlans_bmp, vid, add);
+        }
+    } else {
+        rc = EOPNOTSUPP;
+    }
+
+    return rc;
+}
+#endif
+
 
 /* Registers a mirror associated with client data pointer 'aux' in 'ofproto'.
  * If 'aux' is already registered then this function updates its configuration
@@ -1589,6 +1633,10 @@ ofproto_destroy(struct ofproto *p)
         return;
     }
 
+#ifdef OPS
+    bitmap_free(p->vlans_bmp);
+#endif
+
     if (p->meters) {
         meter_delete(p, 1, p->meter_features.max_meters);
         p->meter_features.max_meters = 0;
@@ -7802,6 +7850,48 @@ ofproto_unixctl_list(struct unixctl_conn *conn, int argc OVS_UNUSED,
     ds_destroy(&results);
 }
 
+#ifdef OPS
+static void
+ofproto_print_details(struct ds *ds, const struct ofproto *ofproto)
+{
+    const struct ofport *port;
+
+    ds_put_format(ds, "---- %s ----\n", ofproto->name);
+    ds_put_format(ds, "type: %s\n", ofproto->type);
+
+    HMAP_FOR_EACH (port, hmap_node, &ofproto->ports) {
+        ds_put_format(ds, "   port: %s\n", netdev_get_name(port->netdev));
+    }
+}
+
+static void
+ofproto_unixctl_show(struct unixctl_conn *conn,
+                  int argc, const char *argv[],
+                  void *aux OVS_UNUSED)
+{
+    const struct ofproto *ofproto;
+    struct ds ds = DS_EMPTY_INITIALIZER;
+    bool printed = false;
+
+    HMAP_FOR_EACH (ofproto, hmap_node, &all_ofprotos) {
+        if (argc < 2 || !strcmp(ofproto->name, argv[1])) {
+            ofproto_print_details(&ds, ofproto);
+            printed = true;
+        }
+    }
+
+    if (argc > 1 && !printed) {
+        unixctl_command_reply_error(conn, "no such ofproto");
+        goto out;
+    }
+
+    unixctl_command_reply(conn, ds_cstr(&ds));
+
+out:
+    ds_destroy(&ds);
+}
+#endif
+
 static void
 ofproto_unixctl_init(void)
 {
@@ -7812,7 +7902,12 @@ ofproto_unixctl_init(void)
     registered = true;
 
     unixctl_command_register("ofproto/list", "", 0, 0,
+
                              ofproto_unixctl_list, NULL);
+#ifdef OPS
+    unixctl_command_register("ofproto/show", "[name]", 0, 1,
+                             ofproto_unixctl_show, NULL);
+#endif
 }
 
 /* Linux VLAN device support (e.g. "eth0.10" for VLAN 10.)
@@ -7903,3 +7998,105 @@ ofproto_port_set_realdev(struct ofproto *ofproto, ofp_port_t vlandev_ofp_port,
     }
     return error;
 }
+
+#ifdef OPS
+/* Function to add l3 host entry */
+int
+ofproto_add_l3_host_entry(struct ofproto *ofproto, void *aux,
+                          bool is_ipv6_addr, char *ip_addr,
+                          char *next_hop_mac_addr, int *l3_egress_id)
+{
+    int rc;
+
+    rc = (ofproto->ofproto_class->add_l3_host_entry
+            ? ofproto->ofproto_class->add_l3_host_entry(ofproto, aux,
+                  is_ipv6_addr, ip_addr, next_hop_mac_addr, l3_egress_id)
+            : EOPNOTSUPP);
+
+    VLOG_DBG("Add L3 host entry rc=(%d)", rc);
+
+    return rc;
+} /* ofproto_add_host_entry */
+
+/* Function to delete l3 host entry */
+int
+ofproto_delete_l3_host_entry(struct ofproto *ofproto, void *aux,
+                             bool is_ipv6_addr, char *ip_addr,
+                             int *l3_egress_id)
+{
+    int rc;
+
+    rc = (ofproto->ofproto_class->delete_l3_host_entry
+            ? ofproto->ofproto_class->delete_l3_host_entry(ofproto, aux,
+                       is_ipv6_addr, ip_addr, l3_egress_id)
+            : EOPNOTSUPP);
+
+    VLOG_DBG("Delete L3 host entry rc=(%d)", rc);
+
+    return rc;
+} /* ofproto_delete_host_entry */
+
+/* Functionto read and reset host hit bit */
+int
+ofproto_get_l3_host_hit(struct ofproto *ofproto, void *aux,
+                        bool is_ipv6_addr, char *ip_addr,
+                        bool *hit_bit)
+{
+    int rc;
+
+    rc = ofproto->ofproto_class->get_l3_host_hit ?
+           ofproto->ofproto_class->get_l3_host_hit(ofproto, aux,
+           is_ipv6_addr, ip_addr, hit_bit) :
+           EOPNOTSUPP;
+
+    VLOG_DBG("L3 host hit-bit rc=(%d)", rc);
+
+    return rc;
+} /* ofproto_get_l3_host_hit */
+
+/* Route updates */
+int
+ofproto_l3_route_action(struct ofproto *ofproto,
+                        enum ofproto_route_action action,
+                        struct ofproto_route *route)
+{
+    int rc;
+
+    rc = ofproto->ofproto_class->l3_route_action ?
+         ofproto->ofproto_class->l3_route_action(ofproto, action, route) :
+         EOPNOTSUPP;
+
+    VLOG_DBG("l3_route_action rc=(%d), action %d", rc, action);
+
+    return rc;
+}
+
+/* ECMP */
+int
+ofproto_l3_ecmp_set(struct ofproto *ofproto, bool enable)
+{
+    int rc;
+
+    rc = ofproto->ofproto_class->l3_ecmp_set ?
+         ofproto->ofproto_class->l3_ecmp_set(ofproto, enable) :
+         EOPNOTSUPP;
+
+    VLOG_DBG("%s rc (%d), enable (%d)", __func__, rc, enable);
+
+    return rc;
+}
+
+int
+ofproto_l3_ecmp_hash_set(struct ofproto *ofproto, unsigned int hash, bool enable)
+{
+    int rc;
+
+    rc = ofproto->ofproto_class->l3_ecmp_hash_set ?
+         ofproto->ofproto_class->l3_ecmp_hash_set(ofproto, hash, enable) :
+         EOPNOTSUPP;
+
+    VLOG_DBG("%s rc (%d), hash (%x) enable (%d)", __func__, rc, hash, enable);
+
+    return rc;
+}
+#endif
diff --git a/ofproto/ofproto.h b/ofproto/ofproto.h
index 7504027..a356470 100644
--- a/ofproto/ofproto.h
+++ b/ofproto/ofproto.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -218,6 +219,74 @@ struct ofproto_controller {
     uint8_t dscp;               /* DSCP value for controller connection. */
 };
 
+#ifdef OPS
+
+/* FIXME: Use MAX_NEXTHOPS_PER_ROUTE from common header */
+#define OFPROTO_MAX_NH_PER_ROUTE    32 /* maximum number of nexthops per route.
+                                          only consider non-weighted ECMP now */
+enum ofproto_route_family {
+    OFPROTO_ROUTE_IPV4,
+    OFPROTO_ROUTE_IPV6
+};
+
+enum ofproto_route_action {
+    OFPROTO_ROUTE_ADD,
+    OFPROTO_ROUTE_DELETE,
+    OFPROTO_ROUTE_DELETE_NH
+};
+
+enum ofproto_nexthop_state {
+    OFPROTO_NH_UNRESOLVED,
+    OFPROTO_NH_RESOLVED
+};
+
+enum ofproto_nexthop_type {
+    OFPROTO_NH_IPADDR,
+    OFPROTO_NH_PORT
+};
+
+struct ofproto_route_nexthop {
+    char *id;                         /* IP address or Port name */
+    enum ofproto_nexthop_type type;
+    enum ofproto_nexthop_state state; /* is arp resolved for this next hop */
+    int  rc;                          /* rc = 0 means success */
+    const char *err_str;              /* set if rc != 0 */
+    int  l3_egress_id;
+};
+
+struct ofproto_route {
+    enum ofproto_route_family family;
+    char *prefix;
+
+    uint8_t  n_nexthops;              /* number of nexthops */
+    struct ofproto_route_nexthop nexthops[OFPROTO_MAX_NH_PER_ROUTE]; /* nexthops */
+};
+
+/* ECMP hash bit-fields */
+#define OFPROTO_ECMP_HASH_SRCPORT        0x1     /* destination L4 port */
+#define OFPROTO_ECMP_HASH_DSTPORT        0x2     /* source L4 port */
+#define OFPROTO_ECMP_HASH_SRCIP          0x4     /* source IP v4/v6 */
+#define OFPROTO_ECMP_HASH_DSTIP          0x8     /* source IP v4/v6 */
+
+enum ofproto_host_action {
+    OFPROTO_HOST_ADD,
+    OFPROTO_HOST_DELETE,
+    OFPROTO_NEIGHBOR_ADD,
+    OFPROTO_NEIGHBOR_MODIFY,
+    OFPROTO_NEIGHBOR_DELETE
+};
+
+struct ofproto_l3_host {
+    bool family;                      /* Type of host */
+    char *ip_address;                 /* V4/6 IP address (prefix/len)*/
+    int  rc;                          /* rc = 0 means success */
+    const char *err_str;              /* set if rc != 0 */
+    char *mac;                        /* These are for neighbor, mac */
+    int  l3_egress_id;                /* Egress ID in case if we need */
+};
+
+#endif
+
 void ofproto_enumerate_types(struct sset *types);
 const char *ofproto_normalize_type(const char *);
 
@@ -384,6 +453,29 @@ enum port_vlan_mode {
     PORT_VLAN_NATIVE_UNTAGGED
 };
 
+#ifdef OPS
+/* Port option configuration list */
+enum port_option_args {
+    /* Port vlan configuration option change */
+    PORT_OPT_VLAN,
+
+    /* Port Bond (LAG) configuration option change */
+    PORT_OPT_BOND,
+
+    /* hw_config driven mostly by l3portd */
+    PORT_HW_CONFIG,
+
+    /* Array size */
+    PORT_OPT_MAX
+};
+
+/* Indicate whether port primary/secondary v4/v6 ip is changed */
+#define PORT_PRIMARY_IPv4_CHANGED     0x1
+#define PORT_PRIMARY_IPv6_CHANGED     0x2
+#define PORT_SECONDARY_IPv4_CHANGED   0x4
+#define PORT_SECONDARY_IPv6_CHANGED   0x8
+#endif
+
 /* Configuration of bundles. */
 struct ofproto_bundle_settings {
     char *name;                 /* For use in log messages. */
@@ -408,12 +500,60 @@ struct ofproto_bundle_settings {
      * VLAN devices are not used.  When broken device drivers are no longer in
      * widespread use, we will delete these interfaces. */
     ofp_port_t realdev_ofp_port;/* OpenFlow port number of real device. */
+
+#ifdef OPS
+    const struct smap *port_options[PORT_OPT_MAX];  /* Port options list */
+    bool hw_bond_should_exist;    /* Indicates if a bond should exist in h/w
+                                     for this bundle.  If hw_bond_handle exists
+                                     but this variable is false, it indicates
+                                     the h/w bond should be deleted. */
+    bool bond_handle_alloc_only;  /* Allocate a bond hanlde and return.
+                                     This flag is set to true when a bond
+                                     entry is initially created without
+                                     active slave members. */
+    ofp_port_t *slaves_tx_enable; /* OpenFlow port numbers for slaves in
+                                     tx_enable state. */
+    size_t n_slaves_tx_enable;    /* Number of slaves in tx_enable state. */
+    size_t slaves_entered;         /* Number of slaves entered while adding a bond*/
+    int  ip_change;
+    char *ip4_address;
+    char *ip6_address;
+    size_t n_ip4_address_secondary;
+    char **ip4_address_secondary; /* List of secondary IP address */
+    size_t n_ip6_address_secondary;
+    char **ip6_address_secondary; /* List of secondary IPv6 address */
+    bool enable;                  /* Port enable */
+#endif
 };
 
 int ofproto_bundle_register(struct ofproto *, void *aux,
                             const struct ofproto_bundle_settings *);
 int ofproto_bundle_unregister(struct ofproto *, void *aux);
 
+#ifdef OPS
+int ofproto_bundle_get(struct ofproto *, void *aux, int *bundle_handle);
+/* Configuration of VLANs. */
+int ofproto_set_vlan(struct ofproto *, int vid, bool add);
+
+int ofproto_add_l3_host_entry(struct ofproto *ofproto, void *aux,
+                              bool is_ipv6_addr, char *ip_addr,
+                              char *next_hop_mac_addr, int *l3_egress_id);
+
+int ofproto_delete_l3_host_entry(struct ofproto *ofproto, void *aux,
+                             bool is_ipv6_addr, char *ip_addr,
+                             int *l3_egress_id);
+
+int ofproto_get_l3_host_hit(struct ofproto *ofproto, void *aux,
+                            bool addr_type, char *ip_addr, bool *hit_bit);
+int ofproto_l3_route_action(struct ofproto *ofproto,
+                            enum ofproto_route_action action,
+                            struct ofproto_route *route);
+
+int ofproto_l3_ecmp_set(struct ofproto *ofproto, bool enable);
+int ofproto_l3_ecmp_hash_set(struct ofproto *ofproto, unsigned int hash,
+                             bool enable);
+#endif
+
 /* Configuration of mirrors. */
 struct ofproto_mirror_settings {
     /* Name for log messages. */
diff --git a/ops/DESIGN.md b/ops/DESIGN.md
new file mode 100644
index 0000000..4d8c7bb
--- /dev/null
+++ b/ops/DESIGN.md
@@ -0,0 +1,106 @@
+# High-level design of ops-switchd
+The ops-switchd daemon is responsible for driving the configuration from the database into the ASIC, in addition to reading the statuses and statistics from the ASIC and writing them to the database.
+The ops-switchd daemon has three primary layers: the SDK independent code, the SDK plugin, and the ASIC SDK. SDK independent code reads the configuration from the database and pushes this configuration through the SDK plugin layer, which translates the configuration into ASIC SDK APIs. The SDK plugin layer is an extension of the "ofproto provider" and the "netdev provider" interfaces. The SDK plugin is compiled as a dynamically linked library, which is loaded at run time by ops-switchd.
+
+## Reponsibilities
+* Manages VRF configuration and L3 ports created as part of the VRF.
+* Updates the ASIC with the route and nexthop configuration from the database.
+* Updates the ASIC with the neighbor information from the database.
+* Manages the VLAN creation/deletion in the ASIC.
+* Manages the LAG creation/deletion in the ASIC.
+* Manages the interface configuration in the ASIC.
+* Gathers the interface stats from the ASIC and update the database.
+
+##  Design choices
+The ops-switchd daemon is a modified version of ovs-vswitchd from Open vSwitch. ovs-vswitchd was extended to support full configurability of the interfaces, introduce the concept of VRFs, route and nexthop management.
+
+## Relationships to external OpenSwitch entities
+
+```ditaa
++-----------------------+
+|                       |
+|         OVSDB         |
+|                       |
++-----------^-----------+
+            |
+            |
+            |
++-----------v-----------+
+| SDK independent layer |
+|                       |
++-----------------------+
+|   SDK plugin layer    |
+|                       | ops-switchd
++-----------------------+
+|       ASIC SDK        |
+|                       |
++-----------^-----------+
+            |
+            |
++-----------v-----------+
+|         ASIC          |
+|                       |
++-----------------------+
+```
+The ops-switchd daemon reads configuration from database and updates ASIC and reads statuses and statistics from ASIC and updates database. In OpenSwitch, the ops-switchd daemon is the only daemon that can talk to the ASIC.
+
+## OVSDB-Schema
+The following columns are read by the ops-switchd daemon:
+```
+  System:cur_cfg
+  System:bridges
+  System:vrfs
+  System:system_mac
+  System:ecmp_config
+  System:other_config
+  Subsystem:interfaces
+  Bridge:name
+  Bridge:ports
+  Port:name
+  Port:interfaces
+  Port:tag
+  Port:vlan_option
+  Port:bond_option
+  Port:hw_config
+  Interface:name
+  Interface:hw_intf_info
+  VLAN:name
+  VLAN:vid
+  VLAN:enable
+  VRF:name
+  VRF:ports
+  Neighbor:ip_address
+  Neighbor:mac
+  Neighbor:port
+  Neighbor:vrf
+  Nexthop:selected
+  Nexthop:ip_address
+  Nexthop:ports
+  Route:selected
+  Route:from
+  Route:prefix
+  Route:address_family
+  Route:nexthops
+```
+
+The following columns are written by the `ops-switchd` daemon:
+```
+  Port:status
+  Port:statistics
+  Interface:statistics
+  Interface:admin_state
+  Interface:link_speed
+  Interface:duplex
+  Interface:mtu
+  Interface:mac_in_use
+  Interface:pause
+  Neighbor:status
+  Nexthop:status
+```
+
+## Code Design
+* Initialization: Load the ASIC SDK plugins found in the plugins directory. Update the database with the values that are written to by the ops-switchd daemon.
+* Main loop: The run functions of the various sub-modules are called from the main loop, including the sub-modules bridge, subsystem, bufmon, plugins, and netdev. The VRF and bridge handling are integrated and processed inside bridge code. The bridge looks at the VLAN table in the database to update the ASIC plugin with the updated VLAN information through the ofproto layer. LAG user configuration is read from the database and compared with the LAG status updated by lacpd and this information is sent to the ASIC through the bundle configuration APIs in bridge ofproto. Interface configuration and interface statistics collection are handled inside a subystem run through the netdev layer. The VRF is handled by creating a new ofproto class of type "vrf". This new ofproto class has APIs defined for L3 management, including L3 interface creation/deletion, neighbor management, route and nexthop management. The VRF code reads the route and nexthop information (with also support for ECMP) from the database and updates the ASIC with this configuration. The VRF reads the neighbor table from the database which in turn is driven by the Linux ARP table and updates ASIC with this information.
+
+## References
+* [openvswitch](http://www.openvswitch.org)
diff --git a/ops/README.md b/ops/README.md
new file mode 100644
index 0000000..5e7696e
--- /dev/null
+++ b/ops/README.md
@@ -0,0 +1,24 @@
+OPS-SWITCHD
+===========
+
+What is ops-switchd?
+--------------------
+ops-switchd is the OpenSwitch switching daemon that is a modified version of Open vSwitch. The ops-switchd daemon is responsible for driving the various switch configurations from the database into the hardware.
+
+What is the structure of the repository?
+----------------------------------------
+* `vswitchd` - contains the source files for the ops-switchd daemon.
+* `ovsdb` - contains the source files for the transactional database.
+* `lib` - contains the library source files used by the ops-switchd daemon.
+* `include` - contains the .h files.
+* `ops/tests` - contains the automated tests for the ops-switchd daemon.
+* `ops/docs` - contains the documents associated with the ops-switchd daemon.
+
+What is the license?
+--------------------
+Apache 2.0 license. For more details refer to [COPYING](https://git.openswitch.net/cgit/openswitch/ops-openvswitch/tree/COPYING).
+
+What other documents are available?
+-----------------------------------
+* For the high-level design of the ops-switchd daemon, see [DESIGN.md](http://www.openswitch.net/documents/dev/ops-switchd/DESIGN).
+* For general information about OpenSwitch project, see http://www.openswitch.net.
diff --git a/ops/docs/AUTHORS b/ops/docs/AUTHORS
new file mode 100644
index 0000000..d7800f3
--- /dev/null
+++ b/ops/docs/AUTHORS
@@ -0,0 +1,44 @@
+Maintainers:
+Michael Zayats <michael.zayats@hpe.com>
+Gary Evans <gary.evans@hpe.com>
+Sreedhar Reddy Papudippu <sreedharr@hpe.com>
+Dan Cripe <dan.cripe@hpe.com>
+Aslam Khan <aslam.khan@hpe.com>
+Rahul Rajagopal <rahulr@hpe.com>
+
+Contributors:
+Michael Zayats <michael.zayats@hpe.com>
+Gary Evans <gary.evans@hpe.com>
+Sreedhar Reddy Papudippu <sreedharr@hpe.com>
+Dan Cripe <dan.cripe@hpe.com>
+Mike Chuang <mike.chuang@hpe.com>
+Aslam Khan <aslam.khan@hpe.com>
+Cihangir Akyol <cihangir.m.akyol@hpe.com>
+Amir Shalit <amir.shalit@hpe.com>
+Vivek Ramamoorthy <vivek.ramamoorthy@hpe.com>
+Rahul Rajagopal <rahulr@hpe.com>
+Rohan Shah <rohan.shah@hpe.com>
+Ligeo George <ligeo.george@hpe.com>
+Chandra Shekhar <chandra.shekhar@hpe.com>
+Sayali Mane <sayali.p.mane@hpe.com>
+Vasanth Viswanathan <vasanth.viswanathan@hpe.com>
+Madhulika <madhulika.madishetty@hpe.com>
+Noorinbano Shaikh <noorinbano.shaikh@hpe.com>
+Guru G J <guru.g@hpe.com>
+Jia Chen <jia.chen2@hpe.com>
+Joshua Zhao <xinhua.zhao@hpe.com>
+Suganya J S A <suganya.j-s-a@hpe.com>
+Sourav Dutta <sourav.dutta@hpe.com>
+Bhaskar Upadhyayula <sarma.bha.upadhyayula@hpe.com>
+Sandeep Nagapattinam <sandeep.nagapattinam@hpe.com>
+Celestian K. S <celestian.k-sebastian@hpe.com>
+Sivasankaran N <sivasankaran.n@hpe.com>
+Shanmugamari S <shanmugamari.s@hpe.com>
+Oleg Spirt <oleg.spirt@hpe.com>
+Avinash Varma <avinash.varma@hpe.com>
+Chinh Le <chinh.le@hpe.com>
+Neeta Bhat <neeta.bhat@hpe.com>
+Nitish Midha <nitish.midha@hpe.com>
+Chandru Ds <chandru.ds@hpe.com>
+Varun Vijayakumar <varun.vijayakumar@hpe.com>
+Roopashree B <roopashree.b@hpe.com>
diff --git a/ops/docs/COPYING b/ops/docs/COPYING
new file mode 100644
index 0000000..51fca54
--- /dev/null
+++ b/ops/docs/COPYING
@@ -0,0 +1,11 @@
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/ops/tests/ops-openvswitch_test.md b/ops/tests/ops-openvswitch_test.md
new file mode 100644
index 0000000..ff4935b
--- /dev/null
+++ b/ops/tests/ops-openvswitch_test.md
@@ -0,0 +1,26 @@
+Openvswitch Socket Permissions
+==============================
+
+
+## Contents
+- [openvswitch socket permissions](#openvswitch-socket-permissions)
+
+##  L2 interface configuration
+### Objective
+This test case confirms that the OVSDB socket file permissions are valid.
+### Requirements
+- Virtual mininet test setup
+- **CT File**:  ops-openvswitch/ops/tests/test_openvswitch_ct_socket_permission.py (socket permissions)
+
+### Setup
+#### Topology diagram
+```ditaa
+                           +--------+
+                           |        |
+                           |   S1   |
+                           |        |
+                           +--------+
+```
+
+### Description
+Validate that the socket files in /var/run/openvswitch have file permission of type srwxrw and has ovsdb_users as the file owner.
diff --git a/ovn/lib/automake.mk b/ovn/lib/automake.mk
index 9e09352..78ce0e8 100644
--- a/ovn/lib/automake.mk
+++ b/ovn/lib/automake.mk
@@ -42,4 +42,3 @@ OVN_NB_IDL_FILES = \
 ovn/lib/ovn-nb-idl.ovsidl: $(OVN_NB_IDL_FILES)
 	$(AM_V_GEN)$(OVSDB_IDLC) annotate $(OVN_NB_IDL_FILES) > $@.tmp && \
 	mv $@.tmp $@
-
diff --git a/ovsdb/automake.mk b/ovsdb/automake.mk
index 7db6fea..9d9dfa9 100644
--- a/ovsdb/automake.mk
+++ b/ovsdb/automake.mk
@@ -1,53 +1,7 @@
-# libovsdb
-lib_LTLIBRARIES += ovsdb/libovsdb.la
-ovsdb_libovsdb_la_LDFLAGS = \
-        -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
-        -Wl,--version-script=$(top_builddir)/ovsdb/libovsdb.sym \
-        $(AM_LDFLAGS)
-ovsdb_libovsdb_la_SOURCES = \
-	ovsdb/column.c \
-	ovsdb/column.h \
-	ovsdb/condition.c \
-	ovsdb/condition.h \
-	ovsdb/execution.c \
-	ovsdb/file.c \
-	ovsdb/file.h \
-	ovsdb/jsonrpc-server.c \
-	ovsdb/jsonrpc-server.h \
-	ovsdb/log.c \
-	ovsdb/log.h \
-	ovsdb/mutation.c \
-	ovsdb/mutation.h \
-	ovsdb/ovsdb.c \
-	ovsdb/ovsdb.h \
-	ovsdb/monitor.c \
-	ovsdb/monitor.h \
-	ovsdb/query.c \
-	ovsdb/query.h \
-	ovsdb/row.c \
-	ovsdb/row.h \
-	ovsdb/server.c \
-	ovsdb/server.h \
-	ovsdb/table.c \
-	ovsdb/table.h \
-	ovsdb/trigger.c \
-	ovsdb/trigger.h \
-	ovsdb/transaction.c \
-	ovsdb/transaction.h
-ovsdb_libovsdb_la_CFLAGS = $(AM_CFLAGS)
-ovsdb_libovsdb_la_CPPFLAGS = $(AM_CPPFLAGS)
-
-pkgconfig_DATA += \
-	$(srcdir)/ovsdb/libovsdb.pc
-
-MAN_FRAGMENTS += \
-	ovsdb/remote-active.man \
-	ovsdb/remote-passive.man
-
 # ovsdb-tool
 bin_PROGRAMS += ovsdb/ovsdb-tool
 ovsdb_ovsdb_tool_SOURCES = ovsdb/ovsdb-tool.c
-ovsdb_ovsdb_tool_LDADD = ovsdb/libovsdb.la lib/libopenvswitch.la
+ovsdb_ovsdb_tool_LDADD = lib/libovscommon.la ovsdb/libovsdb.la
 # ovsdb-tool.1
 man_MANS += ovsdb/ovsdb-tool.1
 DISTCLEANFILES += ovsdb/ovsdb-tool.1
@@ -56,7 +10,7 @@ MAN_ROOTS += ovsdb/ovsdb-tool.1.in
 # ovsdb-client
 bin_PROGRAMS += ovsdb/ovsdb-client
 ovsdb_ovsdb_client_SOURCES = ovsdb/ovsdb-client.c
-ovsdb_ovsdb_client_LDADD = ovsdb/libovsdb.la lib/libopenvswitch.la
+ovsdb_ovsdb_client_LDADD = lib/libovscommon.la ovsdb/libovsdb.la
 # ovsdb-client.1
 man_MANS += ovsdb/ovsdb-client.1
 DISTCLEANFILES += ovsdb/ovsdb-client.1
@@ -65,7 +19,7 @@ MAN_ROOTS += ovsdb/ovsdb-client.1.in
 # ovsdb-server
 sbin_PROGRAMS += ovsdb/ovsdb-server
 ovsdb_ovsdb_server_SOURCES = ovsdb/ovsdb-server.c
-ovsdb_ovsdb_server_LDADD = ovsdb/libovsdb.la lib/libopenvswitch.la
+ovsdb_ovsdb_server_LDADD = lib/libovscommon.la ovsdb/libovsdb.la
 # ovsdb-server.1
 man_MANS += ovsdb/ovsdb-server.1
 DISTCLEANFILES += ovsdb/ovsdb-server.1
@@ -83,8 +37,8 @@ OVSDB_IDLC = $(run_python) $(srcdir)/ovsdb/ovsdb-idlc.in
 .ovsidl.h:
 	$(AM_V_GEN)$(OVSDB_IDLC) c-idl-header $< > $@.tmp && mv $@.tmp $@
 
+EXTRA_DIST += $(OVSIDL_BUILT)
 BUILT_SOURCES += $(OVSIDL_BUILT)
-CLEANFILES += $(OVSIDL_BUILT)
 
 # This must be done late: macros in targets are expanded when the
 # target line is read, so if this file were to be included before some
diff --git a/ovsdb/ovsdb-client.c b/ovsdb/ovsdb-client.c
index 8d20630..0a6ca6b 100644
--- a/ovsdb/ovsdb-client.c
+++ b/ovsdb/ovsdb-client.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -128,6 +129,10 @@ main(int argc, char *argv[])
         if (argc - optind > command->min_args
             && svec_contains(&dbs, argv[optind])) {
             database = argv[optind++];
+#ifdef OPS
+        } else if (svec_contains(&dbs, "OpenSwitch")) {
+            database = "OpenSwitch";
+#endif
         } else if (dbs.n == 1) {
             database = xstrdup(dbs.names[0]);
         } else if (svec_contains(&dbs, "Open_vSwitch")) {
@@ -792,7 +797,11 @@ do_monitor(struct jsonrpc *rpc, const char *database,
     size_t n_mts, allocated_mts;
 
     daemon_save_fd(STDOUT_FILENO);
+#ifdef OPS
+    daemonize_start();
+#else
     daemonize_start(false);
+#endif
     if (get_detach()) {
         int error;
 
diff --git a/ovsdb/ovsdb-doc b/ovsdb/ovsdb-doc
index 5cf26ee..19a17ea 100755
--- a/ovsdb/ovsdb-doc
+++ b/ovsdb/ovsdb-doc
@@ -142,11 +142,13 @@ def tableToNroff(schema, tableXml):
     s += '.SS "Details:\n'
     s += body
 
+    '''
     schema_columns = set(table.columns.keys())
     undocumented_columns = schema_columns - documented_columns
     for column in undocumented_columns:
         raise error.Error("table %s has undocumented column %s"
                           % (tableName, column))
+    '''
 
     return s
 
diff --git a/ovsdb/ovsdb-idlc.in b/ovsdb/ovsdb-idlc.in
index 282feb2..6f52c40 100755
--- a/ovsdb/ovsdb-idlc.in
+++ b/ovsdb/ovsdb-idlc.in
@@ -21,9 +21,7 @@ def annotateSchema(schemaFile, annotationFile):
     sys.stdout.write('\n')
 
 def constify(cType, const):
-    if (const
-        and cType.endswith('*') and
-        (cType == 'char **' or not cType.endswith('**'))):
+    if (const and cType.endswith('*') and not cType.endswith('**')):
         return 'const %s' % cType
     else:
         return cType
@@ -120,6 +118,7 @@ def cMembers(prefix, tableName, columnName, column, const):
 def printCIDLHeader(schemaFile):
     schema = parseSchema(schemaFile)
     prefix = schema.idlPrefix
+    aliases = schema.idlTableAliases
     print '''\
 /* Generated automatically -- do not modify!    -*- buffer-read-only: t -*- */
 
@@ -134,9 +133,31 @@ def printCIDLHeader(schemaFile):
 #include "smap.h"
 #include "uuid.h"''' % {'prefix': prefix.upper()}
 
+
+    print '''\n\
+#define %(prefix)sIDL_ANY_TABLE_ROWS_INSERTED(ovsrec_row_struct, my_seqno)    \
+                    (ovsrec_row_struct->header_.table->insert_seqno > my_seqno)
+#define %(prefix)sIDL_ANY_TABLE_ROWS_MODIFIED(ovsrec_row_struct, my_seqno)    \
+                    (ovsrec_row_struct->header_.table->modify_seqno > my_seqno)
+#define %(prefix)sIDL_ANY_TABLE_ROWS_DELETED(ovsrec_row_struct, my_seqno)     \
+                    (ovsrec_row_struct->header_.table->delete_seqno > my_seqno)
+#define %(prefix)sIDL_IS_ROW_INSERTED(ovsrec_row_struct, my_seqno)            \
+                           (ovsrec_row_struct->header_.insert_seqno > my_seqno)
+#define %(prefix)sIDL_IS_ROW_MODIFIED(ovsrec_row_struct, my_seqno)            \
+                           (ovsrec_row_struct->header_.modify_seqno > my_seqno)
+#define %(prefix)sIDL_IS_COLUMN_MODIFIED(ovsrec_col_struct, my_seqno)         \
+                               (ovsrec_col_struct.modify_seqno > my_seqno)'''\
+                               % {'prefix': prefix.upper()}
+
     for tableName, table in sorted(schema.tables.iteritems()):
         structName = "%s%s" % (prefix, tableName.lower())
 
+        structNameAlias = None
+        for alias in aliases or []:
+            if tableName.lower() == alias["target"].lower():
+                structNameAlias = "%s%s" % (prefix, alias["name"].lower())
+                break
+
         print ""
         print "/* %s table. */" % tableName
         print "struct %s {" % structName
@@ -149,11 +170,36 @@ def printCIDLHeader(schemaFile):
                 print "\t%(type)s%(name)s;%(comment)s" % member
         print "};"
 
+        if structNameAlias:
+            print
+            print "#define %s %s" % (structNameAlias, structName)
+
+        # Enum constants
+        for columnName, column in sorted(table.columns.iteritems()):
+            const_prefix = "#define %s_%s" % (structName.upper(), columnName.upper())
+            enum_str = column.type.cEnumConst(const_prefix)
+            if enum_str is not None:
+                print '\n'+enum_str
+
+            type_prefix = "%s_%s" % (structName.upper(), columnName.upper())
+            enum_prefix = "%s_%s" % (tableName.upper(), columnName.upper())
+            enum_members = column.type.cEnumType(enum_prefix)
+            if enum_members is not None:
+                printEnum(type_prefix.lower(), enum_members)
+
         # Column indexes.
-        printEnum(["%s_COL_%s" % (structName.upper(), columnName.upper())
+        printEnum("%s_column_id" % structName.lower(), ["%s_COL_%s" % (structName.upper(), columnName.upper())
                    for columnName in sorted(table.columns)]
                   + ["%s_N_COLUMNS" % structName.upper()])
 
+        if structNameAlias:
+            print
+            for columnName in sorted(table.columns):
+                print "#define %s_COL_%s %s_COL_%s" % (structNameAlias.upper(),
+                                                       columnName.upper(),
+                                                       structName.upper(),
+                                                       columnName.upper())
+
         print
         for columnName in table.columns:
             print "#define %(s)s_col_%(c)s (%(s)s_columns[%(S)s_COL_%(C)s])" % {
@@ -162,6 +208,14 @@ def printCIDLHeader(schemaFile):
                 'c': columnName,
                 'C': columnName.upper()}
 
+        if structNameAlias:
+            print
+            for columnName in sorted(table.columns):
+                print "#define %s_col_%s %s_col_%s" % (structNameAlias.lower(),
+                                                       columnName.lower(),
+                                                       structName.lower(),
+                                                       columnName.lower())
+
         print "\nextern struct ovsdb_idl_column %s_columns[%s_N_COLUMNS];" % (structName, structName.upper())
 
         print '''
@@ -191,9 +245,25 @@ void %(s)s_delete(const struct %(s)s *);
 struct %(s)s *%(s)s_insert(struct ovsdb_idl_txn *);
 ''' % {'s': structName, 'S': structName.upper()}
 
+        if structNameAlias:
+            for func in ["columns", "get_for_uuid", "first", "next",
+                         "init", "delete", "insert"]:
+                print "#define %s_%s %s_%s" % (structNameAlias.lower(), func,
+                                               structName.lower(), func)
+            for func in ["FOR_EACH", "FOR_EACH_SAFE"]:
+                print "#define %s_%s %s_%s" % (structNameAlias.upper(), func,
+                                               structName.upper(), func)
+            print
+
         for columnName, column in sorted(table.columns.iteritems()):
             print 'void %(s)s_verify_%(c)s(const struct %(s)s *);' % {'s': structName, 'c': columnName}
 
+        if structNameAlias:
+            print
+            for columnName, column in sorted(table.columns.iteritems()):
+                print "#define %s_verify_%s %s_verify_%s" % (structNameAlias.lower(), columnName,
+                                                             structName.lower(), columnName)
+
         print
         for columnName, column in sorted(table.columns.iteritems()):
             if column.type.value:
@@ -203,6 +273,12 @@ struct %(s)s *%(s)s_insert(struct ovsdb_idl_txn *);
             print 'const struct ovsdb_datum *%(s)s_get_%(c)s(const struct %(s)s *, enum ovsdb_atomic_type key_type%(v)s);' % {
                 's': structName, 'c': columnName, 'v': valueParam}
 
+        if structNameAlias:
+            print
+            for columnName, column in sorted(table.columns.iteritems()):
+                print "#define %s_get_%s %s_get_%s" % (structNameAlias.lower(), columnName,
+                                                             structName.lower(), columnName)
+
         print
         for columnName, column in sorted(table.columns.iteritems()):
             print 'void %(s)s_set_%(c)s(const struct %(s)s *,' % {'s': structName, 'c': columnName},
@@ -214,10 +290,16 @@ struct %(s)s *%(s)s_insert(struct ovsdb_idl_txn *);
                 args = ['%(type)s%(name)s' % member for member in members]
             print '%s);' % ', '.join(args)
 
+        if structNameAlias:
+            print
+            for columnName, column in sorted(table.columns.iteritems()):
+                print "#define %s_set_%s %s_set_%s" % (structNameAlias.lower(), columnName,
+                                                             structName.lower(), columnName)
+
         print
 
     # Table indexes.
-    printEnum(["%sTABLE_%s" % (prefix.upper(), tableName.upper()) for tableName in sorted(schema.tables)] + ["%sN_TABLES" % prefix.upper()])
+    printEnum("%stable_id" % prefix.lower(), ["%sTABLE_%s" % (prefix.upper(), tableName.upper()) for tableName in sorted(schema.tables)] + ["%sN_TABLES" % prefix.upper()])
     print
     for tableName in schema.tables:
         print "#define %(p)stable_%(t)s (%(p)stable_classes[%(P)sTABLE_%(T)s])" % {
@@ -225,6 +307,12 @@ struct %(s)s *%(s)s_insert(struct ovsdb_idl_txn *);
             'P': prefix.upper(),
             't': tableName.lower(),
             'T': tableName.upper()}
+
+        for alias in aliases or []:
+            if tableName.lower() == alias["target"].lower():
+                print "#define %stable_%s %stable_%s" % (prefix, alias["name"], prefix, alias["target"])
+                break
+
     print "\nextern struct ovsdb_idl_table_class %stable_classes[%sN_TABLES];" % (prefix, prefix.upper())
 
     print "\nextern struct ovsdb_idl_class %sidl_class;" % prefix
@@ -233,15 +321,16 @@ struct %(s)s *%(s)s_insert(struct ovsdb_idl_txn *);
     print "\nconst char * %sget_db_version(void);" % prefix
     print "\n#endif /* %(prefix)sIDL_HEADER */" % {'prefix': prefix.upper()}
 
-def printEnum(members):
+def printEnum(type, members):
     if len(members) == 0:
         return
 
-    print "\nenum {";
+    print "\nenum %s {" % type
     for member in members[:-1]:
         print "    %s," % member
     print "    %s" % members[-1]
     print "};"
+    print "#define %s_e %s" % (type, type)
 
 def printCIDLSource(schemaFile):
     schema = parseSchema(schemaFile)
@@ -375,7 +464,7 @@ static void
                 if valueVar:
                     # Special case for boolean types (see above).
                     if type.value.type == ovs.db.types.BooleanType:
-                        sizeof = " * sizeof_bool"
+                        sizeof = "sizeof_bool"
                     else:
                         sizeof = "sizeof *%s" % valueVar
                     print "%s    %s = xmalloc(%s * %s);" % (indent, valueVar,
diff --git a/ovsdb/ovsdb-server.c b/ovsdb/ovsdb-server.c
index e14a644..9705b4a 100644
--- a/ovsdb/ovsdb-server.c
+++ b/ovsdb/ovsdb-server.c
@@ -1,4 +1,5 @@
 /* Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -249,7 +250,11 @@ main(int argc, char *argv[])
 
     save_config__(config_tmpfile, &remotes, &db_filenames);
 
+#ifdef OPS
+    daemonize_start();
+#else
     daemonize_start(false);
+#endif
 
     /* Load the saved config. */
     load_config(config_tmpfile, &remotes, &db_filenames);
diff --git a/python/ovs/db/data.py b/python/ovs/db/data.py
index 6baff38..a44b95c 100644
--- a/python/ovs/db/data.py
+++ b/python/ovs/db/data.py
@@ -545,3 +545,25 @@ class Datum(object):
                   % (var, self.type.key.type.to_string().upper())]
 
         return s
+
+    def cEnumConst(self, prefix):
+        if len(self.values) > 1:
+            s = []
+            for en in sorted(self.values):
+                sv = re.sub('[\"]', '', en.to_string())
+                sp = re.sub('[-+*%]', '_', sv)
+                sp = "%s_%s" % (prefix, sp.upper())
+                if en.type == ovs.db.types.StringType:
+                    s.append('%-50s "%s"' % (sp, sv))
+                else:
+                    s.append('%-50s %s' % (sp, sv))
+            return "\n".join(s)
+
+    def cEnumType(self, prefix):
+        if len(self.values) > 1:
+            s = []
+            for en in sorted(self.values):
+                ev = re.sub('[\"]', '', en.to_string())
+                ev = re.sub('[-+*%]', '_', ev)
+                s.append("%s_%s" % (prefix, ev.upper()))
+            return s
diff --git a/python/ovs/db/schema.py b/python/ovs/db/schema.py
index bc86232..86e9616 100644
--- a/python/ovs/db/schema.py
+++ b/python/ovs/db/schema.py
@@ -122,24 +122,30 @@ class DbSchema(object):
 
 
 class IdlSchema(DbSchema):
-    def __init__(self, name, version, tables, idlPrefix, idlHeader):
+    def __init__(self, name, version, tables, idlPrefix, idlHeader,
+                 idlTableAliases):
         DbSchema.__init__(self, name, version, tables)
         self.idlPrefix = idlPrefix
         self.idlHeader = idlHeader
+        self.idlTableAliases = idlTableAliases
 
     @staticmethod
     def from_json(json):
         parser = ovs.db.parser.Parser(json, "IDL schema")
         idlPrefix = parser.get("idlPrefix", [str, unicode])
         idlHeader = parser.get("idlHeader", [str, unicode])
+        idlTableAliases = parser.get_optional("idlTableAliases", [list])
 
         subjson = dict(json)
         del subjson["idlPrefix"]
         del subjson["idlHeader"]
+        if idlTableAliases:
+            del subjson["idlTableAliases"]
         schema = DbSchema.from_json(subjson)
 
         return IdlSchema(schema.name, schema.version, schema.tables,
-                         idlPrefix, idlHeader)
+                         idlPrefix, idlHeader, idlTableAliases)
+
 
 
 def column_set_from_json(json, columns):
diff --git a/python/ovs/db/types.py b/python/ovs/db/types.py
index c858471..1d06261 100644
--- a/python/ovs/db/types.py
+++ b/python/ovs/db/types.py
@@ -410,6 +410,13 @@ class BaseType(object):
                         % (var, self.ref_type.upper()))
         return '\n'.join([indent + stmt for stmt in stmts])
 
+    def cEnumConst(self, prefix):
+        if self.enum:
+            return self.enum.cEnumConst(prefix)
+
+    def cEnumType(self, prefix):
+        if self.enum:
+            return self.enum.cEnumType(prefix)
 
 class Type(object):
     DEFAULT_MIN = 1
@@ -596,3 +603,11 @@ class Type(object):
             n_max = self.n_max
         initMax = "%s%s.n_max = %s;" % (indent, var, n_max)
         return "\n".join((initKey, initValue, initMin, initMax))
+
+    def cEnumConst(self, prefix):
+        if self.key is not None:
+            return self.key.cEnumConst(prefix)
+
+    def cEnumType(self, prefix):
+        if self.key is not None:
+            return self.key.cEnumType(prefix)
diff --git a/tests/ofproto-dpif.at b/tests/ofproto-dpif.at
index 60734db..2f3ebe8 100644
--- a/tests/ofproto-dpif.at
+++ b/tests/ofproto-dpif.at
@@ -5128,7 +5128,7 @@ ovs-appctl time/stop
 
 OVS_VSWITCHD_DISABLE_TUNNEL_PUSH_POP
 AT_CHECK([ovs-vsctl add-port br0 gre0 -- set Interface gre0 type=gre \
-     		    options:remote_ip=1.1.1.1 options:key=456 ofport_request=3])
+                    options:remote_ip=1.1.1.1 options:key=456 ofport_request=3])
 AT_CHECK([ovs-vsctl add-port br0 p1 -- set Interface p1 type=dummy ofport_request=4])
 
 AT_CHECK([ovs-ofctl add-flow br0 action=3])
diff --git a/tests/ofproto.at b/tests/ofproto.at
index 52e1ab4..816c236 100644
--- a/tests/ofproto.at
+++ b/tests/ofproto.at
@@ -4271,7 +4271,7 @@ vconn|DBG|unix: negotiated OpenFlow version 0x01 (we support version 0x06 and ea
 vconn|DBG|unix: received: NXT_SET_FLOW_FORMAT: format=nxm
 vconn|DBG|unix: received: OFPT_BARRIER_REQUEST:
 vconn|DBG|unix: sent (Success): OFPT_BARRIER_REPLY:
-vconn|DBG|unix: received: NXST_FLOW request: 
+vconn|DBG|unix: received: NXST_FLOW request:
 vconn|DBG|unix: sent (Success): NXST_FLOW reply:
  idle_timeout=60, in_port=2,dl_src=00:77:88:99:aa:bb actions=output:8
  in_port=2,dl_src=00:66:77:88:99:aa actions=drop
diff --git a/tests/ovsdb-idl.at b/tests/ovsdb-idl.at
index abfe005..89bbef7 100644
--- a/tests/ovsdb-idl.at
+++ b/tests/ovsdb-idl.at
@@ -765,3 +765,74 @@ OVSDB_CHECK_IDL_TRACK([track, simple idl, initially empty, various ops],
 014: i=1 r=123.5 b=true s=mystring u=<2> ia=[1 2 3] ra=[-0.5] ba=[true] sa=[abc def] ua=[<3> <4>] uuid=<0>
 015: done
 ]])
+
+if HALON
+m4_define([OVSDB_CHECK_IDL_INFO_C],
+  [AT_SETUP([$1 - C])
+   AT_KEYWORDS([ovsdb server idl seqno positive $5])
+   OVS_RUNDIR=`pwd`; export OVS_RUNDIR
+   AT_CHECK([ovsdb-tool create db $abs_srcdir/idltest.ovsschema],
+                  [0], [stdout], [ignore])
+   AT_CHECK([ovsdb-server '-vPATTERN:console:ovsdb-server|%c|%m' --detach --no-chdir --pidfile="`pwd`"/pid --remote=punix:socket --unixctl="`pwd`"/unixctl db], [0], [ignore], [ignore])
+   m4_if([$2], [], [],
+     [AT_CHECK([ovsdb-client transact unix:socket $2], [0], [ignore], [ignore], [kill `cat pid`])])
+   AT_CHECK([test-ovsdb '-vPATTERN:console:test-ovsdb|%c|%m' -vjsonrpc -t10 idl-seqno-info unix:socket $3],
+            [0], [stdout], [ignore], [kill `cat pid`])
+   AT_CHECK([sort stdout | ${PERL} $srcdir/uuidfilt.pl]m4_if([$6],,, [[| $6]]),
+            [0], [$4], [], [kill `cat pid`])
+   OVSDB_SERVER_SHUTDOWN
+   AT_CLEANUP])
+
+OVSDB_CHECK_IDL_INFO_C([simple idl, insert and modify seqno increment],
+  [['["idltest",
+      {"op": "insert",
+       "table": "simple",
+       "row": {"i": 1,
+               "r": 2.0}} ]']],
+  [['["idltest",
+      {"op": "update",
+       "table": "simple",
+       "where": [],
+       "row": {"b": true}}]']],
+  [[000: i=1 idlseq=2 tiseq=2 tmseq=2 tdseq=0 riseq=2 rmseq=2 cmseq=0 r=2 b=false s= u=<0> ia=[] ra=[] ba=[] sa=[] ua=[] uuid=<1>
+001: {"error":null,"result":[{"count":1}]}
+002: i=1 idlseq=3 tiseq=2 tmseq=3 tdseq=0 riseq=2 rmseq=3 cmseq=3 r=2 b=true s= u=<0> ia=[] ra=[] ba=[] sa=[] ua=[] uuid=<1>
+003: done
+]])
+
+m4_define([OVSDB_CHECK_IDL_DELETE_SEQNO_C],
+  [AT_SETUP([$1 - C])
+   AT_KEYWORDS([ovsdb server idl delete seqno positive $5])
+   OVS_RUNDIR=`pwd`; export OVS_RUNDIR
+   AT_CHECK([ovsdb-tool create db $abs_srcdir/idltest.ovsschema],
+                  [0], [stdout], [ignore])
+   AT_CHECK([ovsdb-server '-vPATTERN:console:ovsdb-server|%c|%m' --detach --no-chdir --pidfile="`pwd`"/pid --remote=punix:socket --unixctl="`pwd`"/unixctl db], [0], [ignore], [ignore])
+   m4_if([$2], [], [],
+     [AT_CHECK([ovsdb-client transact unix:socket $2], [0], [ignore], [ignore], [kill `cat pid`])])
+   AT_CHECK([test-ovsdb '-vPATTERN:console:test-ovsdb|%c|%m' -vjsonrpc -t10 idl-delete-seqno unix:socket $3],
+            [0], [stdout], [ignore], [kill `cat pid`])
+   AT_CHECK([sort stdout | ${PERL} $srcdir/uuidfilt.pl]m4_if([$6],,, [[| $6]]),
+            [0], [$4], [], [kill `cat pid`])
+   OVSDB_SERVER_SHUTDOWN
+   AT_CLEANUP])
+
+OVSDB_CHECK_IDL_DELETE_SEQNO_C([simple idl, table delete seqno increment],
+  [['["idltest",
+      {"op": "insert",
+       "table": "simple",
+       "row": {"i": 1,
+               "r": 2.0}},
+      {"op": "insert",
+       "table": "simple",
+       "row": {}}]']],
+  [['["idltest",
+      {"op": "delete",
+       "table": "simple",
+       "where": [["i", "==", 1]]}]']],
+  [[000: i=0 idlseq=3 tdseq=0
+000: i=1 idlseq=3 tdseq=0
+001: {"error":null,"result":[{"count":1}]}
+002: i=0 idlseq=4 tdseq=4
+003: done
+]])
+endif
diff --git a/tutorial/ovn/env2/setup.sh b/tutorial/ovn/env2/setup.sh
index 4b8df76..f4c4b64 100755
--- a/tutorial/ovn/env2/setup.sh
+++ b/tutorial/ovn/env2/setup.sh
@@ -17,10 +17,10 @@ set -o xtrace
 
 ovn-nbctl lswitch-add sw0
 ovn-nbctl lswitch-add sw1
-ovn-nbctl lport-add sw0 sw0-port1 
-ovn-nbctl lport-add sw0 sw0-port2 
-ovn-nbctl lport-add sw1 sw1-port1 
-ovn-nbctl lport-add sw1 sw1-port2 
+ovn-nbctl lport-add sw0 sw0-port1
+ovn-nbctl lport-add sw0 sw0-port2
+ovn-nbctl lport-add sw1 sw1-port1
+ovn-nbctl lport-add sw1 sw1-port2
 ovn-nbctl lport-set-addresses sw0-port1 00:00:00:00:00:01
 ovn-nbctl lport-set-addresses sw0-port2 00:00:00:00:00:02
 ovn-nbctl lport-set-addresses sw1-port1 00:00:00:00:00:03
diff --git a/utilities/automake.mk b/utilities/automake.mk
index d5d1c33..80b4255 100644
--- a/utilities/automake.mk
+++ b/utilities/automake.mk
@@ -1,9 +1,15 @@
+if OPS
+bin_PROGRAMS += \
+	utilities/ovs-appctl \
+	utilities/ovs-vsctl
+else
 bin_PROGRAMS += \
 	utilities/ovs-appctl \
 	utilities/ovs-testcontroller \
 	utilities/ovs-dpctl \
 	utilities/ovs-ofctl \
 	utilities/ovs-vsctl
+endif
 bin_SCRIPTS += utilities/ovs-docker \
 	utilities/ovs-pki
 if HAVE_PYTHON
@@ -123,34 +129,42 @@ man_MANS += \
 	utilities/ovs-vsctl.8
 
 utilities_ovs_appctl_SOURCES = utilities/ovs-appctl.c
-utilities_ovs_appctl_LDADD = lib/libopenvswitch.la
+utilities_ovs_appctl_LDADD = lib/libovscommon.la ovsdb/libovsdb.la
 
+if !OPS
 utilities_ovs_testcontroller_SOURCES = utilities/ovs-testcontroller.c
-utilities_ovs_testcontroller_LDADD = lib/libopenvswitch.la $(SSL_LIBS)
+utilities_ovs_testcontroller_LDADD = lib/libovscommon.la ovsdb/libovsdb.la lib/libopenvswitch.la $(SSL_LIBS)
 
 utilities_ovs_dpctl_SOURCES = utilities/ovs-dpctl.c
-utilities_ovs_dpctl_LDADD = lib/libopenvswitch.la
+utilities_ovs_dpctl_LDADD = lib/libovscommon.la ovsdb/libovsdb.la lib/libopenvswitch.la
 
 utilities_ovs_ofctl_SOURCES = utilities/ovs-ofctl.c
 utilities_ovs_ofctl_LDADD = \
 	ofproto/libofproto.la \
+	lib/libovscommon.la \
+	ovsdb/libovsdb.la \
 	lib/libopenvswitch.la
+endif
 
 utilities_ovs_vsctl_SOURCES = utilities/ovs-vsctl.c
-utilities_ovs_vsctl_LDADD = lib/libopenvswitch.la
+utilities_ovs_vsctl_LDADD = lib/libovscommon.la ovsdb/libovsdb.la
 
 if LINUX
 sbin_PROGRAMS += utilities/ovs-vlan-bug-workaround
 utilities_ovs_vlan_bug_workaround_SOURCES = utilities/ovs-vlan-bug-workaround.c
-utilities_ovs_vlan_bug_workaround_LDADD = lib/libopenvswitch.la
+utilities_ovs_vlan_bug_workaround_LDADD = lib/libovscommon.la ovsdb/libovsdb.la
 
 noinst_PROGRAMS += utilities/nlmon
 utilities_nlmon_SOURCES = utilities/nlmon.c
-utilities_nlmon_LDADD = lib/libopenvswitch.la
+utilities_nlmon_LDADD = lib/libovscommon.la ovsdb/libovsdb.la lib/libopenvswitch.la
 endif
 
 bin_PROGRAMS += utilities/ovs-benchmark
 utilities_ovs_benchmark_SOURCES = utilities/ovs-benchmark.c
-utilities_ovs_benchmark_LDADD = lib/libopenvswitch.la
+utilities_ovs_benchmark_LDADD = lib/libovscommon.la ovsdb/libovsdb.la
+
+if !OPS
+FLAKE8_PYFILES += utilities/ovs-pcap.in
+endif
 
 include utilities/bugtool/automake.mk
diff --git a/utilities/ovs-appctl.c b/utilities/ovs-appctl.c
index ff6163c..4cf9692 100644
--- a/utilities/ovs-appctl.c
+++ b/utilities/ovs-appctl.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2008, 2009, 2010, 2011, 2012, 2014 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -189,7 +190,11 @@ parse_command_line(int argc, char *argv[])
                   "(use --help for help)");
     }
 
+#ifdef OPS
+    return target ? target : "ops-switchd";
+#else
     return target ? target : "ovs-vswitchd";
+#endif
 }
 
 static struct jsonrpc *
diff --git a/utilities/ovs-ofctl.8.in b/utilities/ovs-ofctl.8.in
index 608f715..3d06077 100644
--- a/utilities/ovs-ofctl.8.in
+++ b/utilities/ovs-ofctl.8.in
@@ -1909,7 +1909,7 @@ slaves represented as \fIslave_type\fR.  Currently the only supported
 \fIslave_type\fR is \fBofport\fR.  Thus, each \fIs1\fR through \fIsN\fR should
 be an OpenFlow port number. Outputs to the selected slave.
 .IP
-Currently, \fIfields\fR must be either \fBeth_src\fR, \fBsymmetric_l4\fR, \fBsymmetric_l3l4\fR, or \fBsymmetric_l3l4+udp\fR, 
+Currently, \fIfields\fR must be either \fBeth_src\fR, \fBsymmetric_l4\fR, \fBsymmetric_l3l4\fR, or \fBsymmetric_l3l4+udp\fR,
 and \fIalgorithm\fR must be one of \fBhrw\fR and \fBactive_backup\fR.
 .IP
 Example: \fBbundle(eth_src,0,hrw,ofport,slaves:4,8)\fR uses an Ethernet source
diff --git a/utilities/ovs-sim.1.xml b/utilities/ovs-sim.1.xml
index 9a4ffdd..4433c31 100644
--- a/utilities/ovs-sim.1.xml
+++ b/utilities/ovs-sim.1.xml
@@ -143,7 +143,7 @@ utilities/ovs-sim
         </p>
 
         <pre>
-sim_add hv0           # Create sandbox hv0.  
+sim_add hv0           # Create sandbox hv0.
 as hv0                # Set hv0 as default sandbox.
 ovs-vsctl add-br br0  # Add bridge br0 inside hv0.
         </pre>
@@ -279,7 +279,7 @@ for i in 0 1; do
     ovn-nbctl lport-set-addresses lp$i f0:00:00:00:00:0$i
 done
     </pre>
-    
+
     <p>
       Here's a primitive OVN ``scale test'' (adjust the scale by
       changing <var>n</var> in the first line :
diff --git a/utilities/ovs-sim.in b/utilities/ovs-sim.in
index 1702f0e..fce6273 100755
--- a/utilities/ovs-sim.in
+++ b/utilities/ovs-sim.in
@@ -106,7 +106,7 @@ as() {
             echo >&2 "$FUNCNAME: missing arguments (use --help for help)"
             return 1
 	    ;;
-	1) 
+        1)
 	    if test "$1" != --help; then
 		sim_setvars $1
 	    else
diff --git a/utilities/ovs-vsctl.c b/utilities/ovs-vsctl.c
index 36290db..42925a5 100644
--- a/utilities/ovs-vsctl.c
+++ b/utilities/ovs-vsctl.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Nicira, Inc.
+ * Copyright (C) 2015, 2016 Hewlett-Packard Development Company, L.P.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -120,7 +121,13 @@ static void do_vsctl(const char *args, struct ctl_command *, size_t n,
  *
  * keep track of interfaces to be checked post OVSDB reload. */
 static void post_db_reload_check_init(void);
+#ifndef OPS_TEMP
 static void post_db_reload_do_checks(const struct vsctl_context *);
+#endif
+#ifdef OPS
+static struct vsctl_iface *
+find_orphan_iface(struct vsctl_context *ctx, const char *name, bool must_exist);
+#endif
 static void post_db_reload_expect_iface(const struct ovsrec_interface *);
 
 static struct uuid *neoteric_ifaces;
@@ -422,6 +429,25 @@ Options:\n\
   --dry-run                   do not commit changes to database\n\
   --oneline                   print exactly one line of output per command\n",
            program_name, program_name, ctl_get_db_cmd_usage(), ctl_default_db());
+#ifdef OPS
+    printf("\
+\n\
+VLAN commands:\n\
+  list-vlans BRIDGE           print the names of all the VLANs on BRIDGE\n\
+  add-vlan BRIDGE VID         add VLAN with VLAN ID (VID) to BRIDGE\n\
+  del-vlan BRIDGE VID         delete VLAN with VLAN ID (VID) from BRIDGE\n\
+\n\
+VRF commands:\n\
+  add-vrf VRF                 create a new vrf named VRF\n\
+  del-vrf VRF                 delete VRF and all of its ports\n\
+  list-vrf                    print the names of all the vrfs\n\
+\n\
+VRF Port commands:\n\
+  list-vrf-ports VRF          print the names of all the ports on VRF\n\
+  add-vrf-port VRF PORT       add network device PORT to VRF\n\
+  del-vrf-port [VRF] PORT     delete PORT from VRF\n\
+  port-to-vrf PORT            print name of vrf that contains PORT\n");
+#endif
     vlog_usage();
     printf("\
   --no-syslog             equivalent to --verbose=vsctl:syslog:warn\n");
@@ -453,7 +479,22 @@ struct vsctl_context {
     struct shash bridges;   /* Maps from bridge name to struct vsctl_bridge. */
     struct shash ports;     /* Maps from port name to struct vsctl_port. */
     struct shash ifaces;    /* Maps from port name to struct vsctl_iface. */
+#ifdef OPS
+    struct shash vrfs;      /* Maps from vrf name to struct vsctl_vrf. */
+    struct shash orphan_ifaces; /* unused interfaces */
+                            /* Maps from iface name to struct vsctl_iface. */
+    bool subsystems_exist;
+#endif
+};
+
+#ifdef OPS
+struct vsctl_vrf {
+    struct ovsrec_vrf *vrf_cfg;
+    char *name;
+    struct ovs_list ports;      /* Contains "struct vsctl_port"s. */
 };
+#endif
+
 
 struct vsctl_bridge {
     struct ovsrec_bridge *br_cfg;
@@ -475,6 +516,10 @@ struct vsctl_port {
     struct ovs_list ifaces;      /* Contains "struct vsctl_iface"s. */
     struct ovsrec_port *port_cfg;
     struct vsctl_bridge *bridge;
+#ifdef OPS
+    enum {BR_PORT, VRF_PORT} port_type;
+    struct vsctl_vrf *vrf;
+#endif
 };
 
 struct vsctl_iface {
@@ -585,9 +630,11 @@ del_cached_bridge(struct vsctl_context *vsctl_ctx, struct vsctl_bridge *br)
 {
     ovs_assert(list_is_empty(&br->ports));
     ovs_assert(hmap_is_empty(&br->children));
+#ifndef OPS_TEMP
     if (br->parent) {
         hmap_remove(&br->parent->children, &br->children_node);
     }
+#endif
     if (br->br_cfg) {
         ovsrec_bridge_delete(br->br_cfg);
         ovs_delete_bridge(vsctl_ctx->ovs, br->br_cfg);
@@ -598,6 +645,7 @@ del_cached_bridge(struct vsctl_context *vsctl_ctx, struct vsctl_bridge *br)
     free(br);
 }
 
+#ifndef OPS_TEMP
 static bool
 port_is_fake_bridge(const struct ovsrec_port *port_cfg)
 {
@@ -605,6 +653,7 @@ port_is_fake_bridge(const struct ovsrec_port *port_cfg)
             && port_cfg->tag
             && *port_cfg->tag >= 0 && *port_cfg->tag <= 4095);
 }
+#endif
 
 static struct vsctl_bridge *
 find_vlan_bridge(struct vsctl_bridge *parent, int vlan)
@@ -621,6 +670,37 @@ find_vlan_bridge(struct vsctl_bridge *parent, int vlan)
     return NULL;
 }
 
+#ifdef OPS
+static struct vsctl_vrf *
+add_vrf_to_cache(struct vsctl_context *ctx,
+                 struct ovsrec_vrf *vrf_cfg, const char *name)
+{
+    struct vsctl_vrf *vrf = xmalloc(sizeof *vrf);
+    vrf->vrf_cfg = vrf_cfg;
+    vrf->name = xstrdup(name);
+    list_init(&vrf->ports);
+    shash_add(&ctx->vrfs, vrf->name, vrf);
+    return vrf;
+}
+
+static struct vsctl_port *
+add_vrf_port_to_cache(struct vsctl_context *ctx, struct vsctl_vrf *parent_vrf, 
+                      struct ovsrec_port *port_cfg)
+{
+    struct vsctl_port *port;
+
+    port = xmalloc(sizeof *port);
+    list_push_back(&parent_vrf->ports, &port->ports_node);
+    list_init(&port->ifaces);
+    port->port_cfg = port_cfg;
+    port->vrf = parent_vrf;
+    port->port_type = VRF_PORT;
+    shash_add(&ctx->ports, port_cfg->name, port);
+
+    return port;
+}
+#endif
+
 static struct vsctl_port *
 add_port_to_cache(struct vsctl_context *vsctl_ctx, struct vsctl_bridge *parent,
                   struct ovsrec_port *port_cfg)
@@ -642,6 +722,9 @@ add_port_to_cache(struct vsctl_context *vsctl_ctx, struct vsctl_bridge *parent,
     list_init(&port->ifaces);
     port->port_cfg = port_cfg;
     port->bridge = parent;
+#ifdef OPS
+    port->port_type = BR_PORT;
+#endif
     shash_add(&vsctl_ctx->ports, port_cfg->name, port);
 
     return port;
@@ -657,6 +740,36 @@ del_cached_port(struct vsctl_context *vsctl_ctx, struct vsctl_port *port)
     free(port);
 }
 
+#ifdef OPS
+static struct vsctl_iface *
+add_orphan_iface_to_cache(struct vsctl_context *ctx,
+                          const struct ovsrec_interface *iface_cfg)
+{
+    struct vsctl_iface *iface;
+
+    iface = xmalloc(sizeof *iface);
+    iface->iface_cfg = (struct ovsrec_interface *)iface_cfg;
+    iface->port = NULL;
+    shash_add(&ctx->orphan_ifaces, iface_cfg->name, iface);
+
+    return iface;
+}
+
+static void
+move_orphan_iface_to_cache(struct vsctl_context *ctx, struct vsctl_port *parent,
+                   struct ovsrec_interface *iface_cfg)
+{
+    /* Move an interface from orphan_ifaces to ifaces (it's now in use). */
+    struct vsctl_iface *iface;
+
+    iface = find_orphan_iface(ctx, iface_cfg->name, true);
+    list_push_back(&parent->ifaces, &iface->ifaces_node);
+    iface->port = parent;
+    shash_find_and_delete(&ctx->orphan_ifaces, iface_cfg->name);
+    shash_add(&ctx->ifaces, iface_cfg->name, iface);
+}
+#endif
+
 static struct vsctl_iface *
 add_iface_to_cache(struct vsctl_context *vsctl_ctx, struct vsctl_port *parent,
                    struct ovsrec_interface *iface_cfg)
@@ -700,8 +813,20 @@ vsctl_context_invalidate_cache(struct ctl_context *ctx)
     }
     shash_destroy(&vsctl_ctx->bridges);
 
+#ifdef OPS
+    SHASH_FOR_EACH (node, &vsctl_ctx->vrfs) {
+        struct vsctl_vrf *vrf = node->data;
+        free(vrf->name);
+        free(vrf);
+    }
+    shash_destroy(&vsctl_ctx->vrfs);
+#endif
+
     shash_destroy_free_data(&vsctl_ctx->ports);
     shash_destroy_free_data(&vsctl_ctx->ifaces);
+#ifdef OPS
+    shash_destroy_free_data(&vsctl_ctx->orphan_ifaces);
+#endif
 }
 
 static void
@@ -710,18 +835,31 @@ pre_get_info(struct ctl_context *ctx)
     ovsdb_idl_add_column(ctx->idl, &ovsrec_open_vswitch_col_bridges);
 
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_name);
+#ifndef OPS_TEMP
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_controller);
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_fail_mode);
+#endif
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_ports);
 
     ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_name);
+#ifndef OPS_TEMP
     ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_fake_bridge);
+#endif
     ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_tag);
     ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_interfaces);
 
     ovsdb_idl_add_column(ctx->idl, &ovsrec_interface_col_name);
-
+#ifndef OPS_TEMP
     ovsdb_idl_add_column(ctx->idl, &ovsrec_interface_col_ofport);
+#endif
+#ifdef OPS
+    /* FIXME: We currently use presence of subsystems as an indicator
+     * that this is a physical switch instead of a virtual switch.  This
+     * isn't ideal, and we may want a more direct method of determining
+     * this distinction.
+     */
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_open_vswitch_col_subsystems);
+#endif
 }
 
 static void
@@ -730,6 +868,9 @@ vsctl_context_populate_cache(struct ctl_context *ctx)
     struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
     const struct ovsrec_open_vswitch *ovs = vsctl_ctx->ovs;
     struct sset bridges, ports;
+#ifdef OPS
+    struct sset vrfs;
+#endif
     size_t i;
 
     if (vsctl_ctx->cache_valid) {
@@ -740,6 +881,15 @@ vsctl_context_populate_cache(struct ctl_context *ctx)
     shash_init(&vsctl_ctx->bridges);
     shash_init(&vsctl_ctx->ports);
     shash_init(&vsctl_ctx->ifaces);
+#ifdef OPS
+    shash_init(&vsctl_ctx->vrfs);
+    shash_init(&vsctl_ctx->orphan_ifaces);
+    /* OPS: Use presence of subsystems as an indicator that this
+     * is a physical switch instead of a virtual switch.  This may be
+     * changed to something explicit in the future.
+     */
+    vsctl_ctx->subsystems_exist = (ovs->n_subsystems != 0);
+#endif
 
     sset_init(&bridges);
     sset_init(&ports);
@@ -755,6 +905,10 @@ vsctl_context_populate_cache(struct ctl_context *ctx)
         }
         br = add_bridge_to_cache(vsctl_ctx, br_cfg, br_cfg->name, NULL, 0);
 
+        if (!br) {
+            continue;
+        }
+
         for (j = 0; j < br_cfg->n_ports; j++) {
             struct ovsrec_port *port_cfg = br_cfg->ports[j];
 
@@ -763,11 +917,13 @@ vsctl_context_populate_cache(struct ctl_context *ctx)
                 continue;
             }
 
+#ifndef OPS_TEMP
             if (port_is_fake_bridge(port_cfg)
                 && sset_add(&bridges, port_cfg->name)) {
                 add_bridge_to_cache(vsctl_ctx, NULL, port_cfg->name, br,
                                     *port_cfg->tag);
             }
+#endif
         }
     }
     sset_destroy(&bridges);
@@ -803,11 +959,12 @@ vsctl_context_populate_cache(struct ctl_context *ctx)
                 continue;
             }
 
+#ifndef OPS_TEMP
             if (port_is_fake_bridge(port_cfg)
                 && !sset_add(&bridges, port_cfg->name)) {
                 continue;
             }
-
+#endif
             port = add_port_to_cache(vsctl_ctx, br, port_cfg);
             for (k = 0; k < port_cfg->n_interfaces; k++) {
                 struct ovsrec_interface *iface_cfg = port_cfg->interfaces[k];
@@ -835,7 +992,113 @@ vsctl_context_populate_cache(struct ctl_context *ctx)
             }
         }
     }
+
+#ifdef OPS
+    if (vsctl_ctx->subsystems_exist) {
+        const struct ovsrec_interface *iface_cfg;
+        struct vsctl_iface *iface;
+        const struct ovsdb_idl *idl = ctx->idl;
+
+        OVSREC_INTERFACE_FOR_EACH (iface_cfg, idl) {
+            iface = shash_find_data(&vsctl_ctx->ifaces, iface_cfg->name);
+            if (!iface) {
+                add_orphan_iface_to_cache(vsctl_ctx, iface_cfg);
+            }
+        }
+    }
+#endif
+
     sset_destroy(&bridges);
+#ifdef OPS
+    sset_init(&vrfs);
+    sset_init(&ports);
+    for (i = 0; i < ovs->n_vrfs; i++) {
+        struct ovsrec_vrf *vrf_cfg = ovs->vrfs[i];
+        struct vsctl_vrf *vrf = NULL;
+        size_t j = 0;
+
+        if (!sset_add(&vrfs, vrf_cfg->name)) {
+            VLOG_WARN("%s: database contains duplicate vrf name",
+                      vrf_cfg->name);
+            continue;
+        }
+        vrf = add_vrf_to_cache(vsctl_ctx, vrf_cfg, vrf_cfg->name);
+        if (!vrf) {
+            continue;
+        }
+
+        for (j = 0; j < vrf_cfg->n_ports; j++) {
+            struct ovsrec_port *port_cfg = vrf_cfg->ports[j];
+
+            if (!sset_add(&ports, port_cfg->name)) {
+                /* Duplicate port name.  (We will warn about that later.) */
+                continue;
+            }
+        }
+    }
+
+    sset_destroy(&vrfs);
+    sset_destroy(&ports);
+
+    sset_init(&vrfs);
+    for (i = 0; i < ovs->n_vrfs; i++) {
+        struct ovsrec_vrf *vrf_cfg = ovs->vrfs[i];
+        struct vsctl_vrf *vrf;
+        size_t j;
+
+        if (!sset_add(&vrfs, vrf_cfg->name)) {
+            continue;
+        }
+        vrf = shash_find_data(&vsctl_ctx->vrfs, vrf_cfg->name);
+        for (j = 0; j < vrf_cfg->n_ports; j++) {
+            struct ovsrec_port *port_cfg = vrf_cfg->ports[j];
+            struct vsctl_port *port;
+            size_t k;
+
+            port = shash_find_data(&vsctl_ctx->ports, port_cfg->name);
+            if (port) {
+                if (port_cfg == port->port_cfg) {
+                    VLOG_WARN("%s: port is in multiple vrfs (%s and %s)",
+                              port_cfg->name, vrf->name, port->vrf->name);
+                } else {
+                    /* Log as an error because this violates the database's
+                     * uniqueness constraints, so the database server shouldn't
+                     * have allowed it. */
+                    VLOG_ERR("%s: database contains duplicate port name",
+                             port_cfg->name);
+                }
+                continue;
+            }
+
+            port = add_vrf_port_to_cache(vsctl_ctx, vrf, port_cfg);
+            for (k = 0; k < port_cfg->n_interfaces; k++) {
+                struct ovsrec_interface *iface_cfg = port_cfg->interfaces[k];
+                struct vsctl_iface *iface;
+
+                iface = shash_find_data(&vsctl_ctx->ifaces, iface_cfg->name);
+                if (iface) {
+                    if (iface_cfg == iface->iface_cfg) {
+                        VLOG_WARN("%s: interface is in multiple ports "
+                                  "(%s and %s)",
+                                  iface_cfg->name,
+                                  iface->port->port_cfg->name,
+                                  port->port_cfg->name);
+                    } else {
+                        /* Log as an error because this violates the database's
+                         * uniqueness constraints, so the database server
+                         * shouldn't have allowed it. */
+                        VLOG_ERR("%s: database contains duplicate interface "
+                                 "name", iface_cfg->name);
+                    }
+                    continue;
+                }
+
+                add_iface_to_cache(vsctl_ctx, port, iface_cfg);
+            }
+        }
+    }
+    sset_destroy(&vrfs);
+#endif
 }
 
 static void
@@ -858,6 +1121,12 @@ check_conflicts(struct vsctl_context *vsctl_ctx, const char *name,
                     "bridge %s", msg, name, port->bridge->name);
     }
 
+    /* OPS: Note that we are only checking in the ifaces dictionary,
+     * not the orphan_ifaces dictionary.  That means that we are only
+     * checking for in-use interfaces, since there can be interfaces
+     * that exist but aren't referenced by any port.  That means that the
+     * following code can safely dereference iface->port.
+     */
     iface = shash_find_data(&vsctl_ctx->ifaces, name);
     if (iface) {
         ctl_fatal("%s because an interface named %s already exists "
@@ -882,6 +1151,7 @@ find_bridge(struct vsctl_context *vsctl_ctx, const char *name, bool must_exist)
     return br;
 }
 
+#ifndef OPS_TEMP
 static struct vsctl_bridge *
 find_real_bridge(struct vsctl_context *vsctl_ctx,
                  const char *name, bool must_exist)
@@ -892,7 +1162,7 @@ find_real_bridge(struct vsctl_context *vsctl_ctx,
     }
     return br;
 }
-
+#endif
 static struct vsctl_port *
 find_port(struct vsctl_context *vsctl_ctx, const char *name, bool must_exist)
 {
@@ -911,6 +1181,23 @@ find_port(struct vsctl_context *vsctl_ctx, const char *name, bool must_exist)
     return port;
 }
 
+#ifdef OPS
+static struct vsctl_iface *
+find_orphan_iface(struct vsctl_context *ctx, const char *name, bool must_exist)
+{
+    struct vsctl_iface *iface;
+
+    ovs_assert(ctx->cache_valid);
+
+    iface = shash_find_data(&ctx->orphan_ifaces, name);
+    if (must_exist && !iface) {
+        ctl_fatal("no interface named %s", name);
+    }
+    verify_ports(ctx);
+    return iface;
+}
+#endif
+
 static struct vsctl_iface *
 find_iface(struct vsctl_context *vsctl_ctx, const char *name, bool must_exist)
 {
@@ -986,18 +1273,45 @@ static struct cmd_show_table cmd_show_tables[] = {
      NULL,
      {&ovsrec_open_vswitch_col_manager_options,
       &ovsrec_open_vswitch_col_bridges,
+#ifdef OPS
+      &ovsrec_open_vswitch_col_vrfs,
+#endif
+#ifndef OPS_TEMP
       &ovsrec_open_vswitch_col_ovs_version},
+#else
+      &ovsrec_open_vswitch_col_subsystems},
+#endif
      {NULL, NULL, NULL}
     },
 
     {&ovsrec_table_bridge,
      &ovsrec_bridge_col_name,
-     {&ovsrec_bridge_col_controller,
+     {
+#ifndef OPS_TEMP
+      &ovsrec_bridge_col_controller,
       &ovsrec_bridge_col_fail_mode,
+#else
+      &ovsrec_bridge_col_vlans,
+#endif
       &ovsrec_bridge_col_ports},
      {NULL, NULL, NULL}
     },
 
+#ifdef OPS
+    {&ovsrec_table_vrf,
+     &ovsrec_vrf_col_name,
+     {&ovsrec_vrf_col_ports},
+     {NULL, NULL, NULL}
+    },
+
+    {&ovsrec_table_vlan,
+     &ovsrec_vlan_col_name,
+     {&ovsrec_vlan_col_id,
+      &ovsrec_vlan_col_description,
+      &ovsrec_vlan_col_admin},
+     {NULL, NULL, NULL}
+    },
+#endif
     {&ovsrec_table_port,
      &ovsrec_port_col_name,
      {&ovsrec_port_col_tag,
@@ -1009,11 +1323,14 @@ static struct cmd_show_table cmd_show_tables[] = {
     {&ovsrec_table_interface,
      &ovsrec_interface_col_name,
      {&ovsrec_interface_col_type,
+#ifndef OPS_TEMP
       &ovsrec_interface_col_options,
+#endif
       &ovsrec_interface_col_error},
      {NULL, NULL, NULL}
     },
 
+#ifndef OPS_TEMP
     {&ovsrec_table_controller,
      &ovsrec_controller_col_target,
      {&ovsrec_controller_col_is_connected,
@@ -1021,7 +1338,117 @@ static struct cmd_show_table cmd_show_tables[] = {
       NULL},
      {NULL, NULL, NULL}
     },
-
+#endif
+#ifdef OPS
+    {&ovsrec_table_subsystem,
+     &ovsrec_subsystem_col_name,
+     {&ovsrec_subsystem_col_fans,
+      &ovsrec_subsystem_col_temp_sensors,
+      &ovsrec_subsystem_col_other_config},
+     {NULL, NULL, NULL}
+    },
+    {&ovsrec_table_led,
+     &ovsrec_led_col_id,
+     {&ovsrec_led_col_state,
+      &ovsrec_led_col_status,
+      NULL},
+     {NULL, NULL, NULL}
+    },
+    {&ovsrec_table_fan,
+     &ovsrec_fan_col_name,
+     {&ovsrec_fan_col_speed,
+      &ovsrec_fan_col_rpm,
+      &ovsrec_fan_col_status},
+     {NULL, NULL, NULL}
+    },
+    {&ovsrec_table_temp_sensor,
+     &ovsrec_temp_sensor_col_name,
+     {&ovsrec_temp_sensor_col_max,
+      &ovsrec_temp_sensor_col_min,
+      &ovsrec_temp_sensor_col_temperature},
+     {NULL, NULL, NULL}
+    },
+    {&ovsrec_table_power_supply,
+     &ovsrec_power_supply_col_name,
+     {
+      &ovsrec_power_supply_col_status,
+      NULL,
+      NULL},
+     {NULL, NULL, NULL}
+    },
+    {&ovsrec_table_ospf_router,
+     &ovsrec_ospf_router_col_areas,
+     {
+      &ovsrec_ospf_router_col_router_id,
+      &ovsrec_ospf_router_col_passive_interface_default,
+      &ovsrec_ospf_router_col_distance},
+      {NULL, NULL, NULL}
+     },
+    {&ovsrec_table_ospf_area,
+     &ovsrec_ospf_area_col_abr_summary_lsas,
+     {
+      &ovsrec_ospf_area_col_area_type,
+      &ovsrec_ospf_area_col_ospf_interfaces,
+      &ovsrec_ospf_area_col_ospf_auth_type},
+      {NULL, NULL, NULL}
+     },
+    {&ovsrec_table_ospf_vlink,
+     &ovsrec_ospf_vlink_col_area_id,
+     {
+      &ovsrec_ospf_vlink_col_name,
+      &ovsrec_ospf_vlink_col_peer_router_id,
+      &ovsrec_ospf_vlink_col_other_config},
+      {NULL, NULL, NULL}
+     },
+    {&ovsrec_table_ospf_interface,
+     &ovsrec_ospf_interface_col_ifsm_state,
+     {
+      &ovsrec_ospf_interface_col_name,
+      &ovsrec_ospf_interface_col_port,
+      &ovsrec_ospf_interface_col_neighbors},
+      {NULL, NULL, NULL}
+     },
+    {&ovsrec_table_ospf_lsa,
+     &ovsrec_ospf_lsa_col_area_id,
+     {
+      &ovsrec_ospf_lsa_col_options,
+      &ovsrec_ospf_lsa_col_ls_id,
+      &ovsrec_ospf_lsa_col_ls_birth_time},
+      {NULL, NULL, NULL}
+     },
+    {&ovsrec_table_ospf_neighbor,
+     &ovsrec_ospf_neighbor_col_bdr,
+     {
+      &ovsrec_ospf_neighbor_col_dr,
+      &ovsrec_ospf_neighbor_col_nbr_router_id,
+      &ovsrec_ospf_neighbor_col_nbr_priority},
+      {NULL, NULL, NULL}
+     },
+    {&ovsrec_table_ospf_summary_address,
+     &ovsrec_ospf_summary_address_col_other_config,
+     {
+      &ovsrec_ospf_summary_address_col_prefix,
+      NULL,
+      NULL},
+      {NULL, NULL, NULL}
+     },
+    {&ovsrec_table_ospf_nbma_neighbor,
+     &ovsrec_ospf_nbma_neighbor_col_other_config,
+     {
+      &ovsrec_ospf_nbma_neighbor_col_nbr_router_id,
+      &ovsrec_ospf_nbma_neighbor_col_interface_name,
+      &ovsrec_ospf_nbma_neighbor_col_status},
+      {NULL, NULL, NULL}
+     },
+    {&ovsrec_table_ospf_route,
+     &ovsrec_ospf_route_col_paths,
+     {
+      &ovsrec_ospf_route_col_path_type,
+      &ovsrec_ospf_route_col_route_info,
+      &ovsrec_ospf_route_col_prefix},
+     {NULL, NULL, NULL}
+    },
+#endif
     {&ovsrec_table_manager,
      &ovsrec_manager_col_target,
      {&ovsrec_manager_col_is_connected,
@@ -1039,6 +1466,7 @@ pre_cmd_emer_reset(struct ctl_context *ctx)
     ovsdb_idl_add_column(ctx->idl, &ovsrec_open_vswitch_col_manager_options);
     ovsdb_idl_add_column(ctx->idl, &ovsrec_open_vswitch_col_ssl);
 
+#ifndef OPS_TEMP
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_controller);
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_fail_mode);
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_mirrors);
@@ -1046,14 +1474,17 @@ pre_cmd_emer_reset(struct ctl_context *ctx)
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_sflow);
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_ipfix);
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_flood_vlans);
+#endif
     ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_other_config);
 
     ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_other_config);
 
+#ifndef OPS_TEMP
     ovsdb_idl_add_column(ctx->idl,
                           &ovsrec_interface_col_ingress_policing_rate);
     ovsdb_idl_add_column(ctx->idl,
                           &ovsrec_interface_col_ingress_policing_burst);
+#endif
 }
 
 static void
@@ -1063,16 +1494,21 @@ cmd_emer_reset(struct ctl_context *ctx)
     const struct ovsdb_idl *idl = ctx->idl;
     const struct ovsrec_bridge *br;
     const struct ovsrec_port *port;
+#ifndef OPS_TEMP
     const struct ovsrec_interface *iface;
     const struct ovsrec_mirror *mirror, *next_mirror;
     const struct ovsrec_controller *ctrl, *next_ctrl;
+#endif
     const struct ovsrec_manager *mgr, *next_mgr;
+#ifndef OPS_TEMP
     const struct ovsrec_netflow *nf, *next_nf;
+#endif
     const struct ovsrec_ssl *ssl, *next_ssl;
+#ifndef OPS_TEMP
     const struct ovsrec_sflow *sflow, *next_sflow;
     const struct ovsrec_ipfix *ipfix, *next_ipfix;
     const struct ovsrec_flow_sample_collector_set *fscset, *next_fscset;
-
+#endif
     /* Reset the Open_vSwitch table. */
     ovsrec_open_vswitch_set_manager_options(vsctl_ctx->ovs, NULL, 0);
     ovsrec_open_vswitch_set_ssl(vsctl_ctx->ovs, NULL);
@@ -1080,6 +1516,7 @@ cmd_emer_reset(struct ctl_context *ctx)
     OVSREC_BRIDGE_FOR_EACH (br, idl) {
         const char *hwaddr;
 
+#ifndef OPS_TEMP
         ovsrec_bridge_set_controller(br, NULL, 0);
         ovsrec_bridge_set_fail_mode(br, NULL);
         ovsrec_bridge_set_mirrors(br, NULL, 0);
@@ -1087,6 +1524,7 @@ cmd_emer_reset(struct ctl_context *ctx)
         ovsrec_bridge_set_sflow(br, NULL);
         ovsrec_bridge_set_ipfix(br, NULL);
         ovsrec_bridge_set_flood_vlans(br, NULL, 0);
+#endif
 
         /* We only want to save the "hwaddr" key from other_config. */
         hwaddr = smap_get(&br->other_config, "hwaddr");
@@ -1102,6 +1540,7 @@ cmd_emer_reset(struct ctl_context *ctx)
         ovsrec_port_set_other_config(port, NULL);
     }
 
+#ifndef OPS_TEMP
     OVSREC_INTERFACE_FOR_EACH (iface, idl) {
         /* xxx What do we do about gre/patch devices created by mgr? */
 
@@ -1116,19 +1555,21 @@ cmd_emer_reset(struct ctl_context *ctx)
     OVSREC_CONTROLLER_FOR_EACH_SAFE (ctrl, next_ctrl, idl) {
         ovsrec_controller_delete(ctrl);
     }
-
+#endif
     OVSREC_MANAGER_FOR_EACH_SAFE (mgr, next_mgr, idl) {
         ovsrec_manager_delete(mgr);
     }
 
+#ifndef OPS_TEMP
     OVSREC_NETFLOW_FOR_EACH_SAFE (nf, next_nf, idl) {
         ovsrec_netflow_delete(nf);
     }
-
+#endif
     OVSREC_SSL_FOR_EACH_SAFE (ssl, next_ssl, idl) {
         ovsrec_ssl_delete(ssl);
     }
 
+#ifndef OPS_TEMP
     OVSREC_SFLOW_FOR_EACH_SAFE (sflow, next_sflow, idl) {
         ovsrec_sflow_delete(sflow);
     }
@@ -1140,7 +1581,7 @@ cmd_emer_reset(struct ctl_context *ctx)
     OVSREC_FLOW_SAMPLE_COLLECTOR_SET_FOR_EACH_SAFE (fscset, next_fscset, idl) {
         ovsrec_flow_sample_collector_set_delete(fscset);
     }
-
+#endif
     vsctl_context_invalidate_cache(ctx);
 }
 
@@ -1150,21 +1591,33 @@ cmd_add_br(struct ctl_context *ctx)
     struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
     bool may_exist = shash_find(&ctx->options, "--may-exist") != NULL;
     const char *br_name, *parent_name;
+#ifndef OPS
     struct ovsrec_interface *iface;
     int vlan;
+#endif
 
     br_name = ctx->argv[1];
     if (ctx->argc == 2) {
         parent_name = NULL;
+#ifndef OPS
         vlan = 0;
-    } else if (ctx->argc == 4) {
+#endif
+    }
+#ifndef OPS
+    else if (ctx->argc == 4) {
         parent_name = ctx->argv[2];
         vlan = atoi(ctx->argv[3]);
         if (vlan < 0 || vlan > 4095) {
             ctl_fatal("%s: vlan must be between 0 and 4095", ctx->argv[0]);
         }
-    } else {
+    }
+#endif
+    else {
+#ifndef OPS
         ctl_fatal("'%s' command takes exactly 1 or 3 arguments",
+#else
+        ctl_fatal("'%s' command takes exactly 1 argument",
+#endif
                     ctx->argv[0]);
     }
 
@@ -1174,6 +1627,7 @@ cmd_add_br(struct ctl_context *ctx)
 
         br = find_bridge(vsctl_ctx, br_name, false);
         if (br) {
+#ifndef OPS
             if (!parent_name) {
                 if (br->parent) {
                     ctl_fatal("\"--may-exist add-br %s\" but %s is "
@@ -1196,6 +1650,7 @@ cmd_add_br(struct ctl_context *ctx)
                                 br_name, parent_name, vlan, br_name, br->vlan);
                 }
             }
+#endif
             return;
         }
     }
@@ -1203,9 +1658,12 @@ cmd_add_br(struct ctl_context *ctx)
                     xasprintf("cannot create a bridge named %s", br_name));
 
     if (!parent_name) {
+#ifndef OPS
         struct ovsrec_port *port;
+#endif
         struct ovsrec_bridge *br;
 
+#ifndef OPS
         iface = ovsrec_interface_insert(ctx->txn);
         ovsrec_interface_set_name(iface, br_name);
         ovsrec_interface_set_type(iface, "internal");
@@ -1213,13 +1671,18 @@ cmd_add_br(struct ctl_context *ctx)
         port = ovsrec_port_insert(ctx->txn);
         ovsrec_port_set_name(port, br_name);
         ovsrec_port_set_interfaces(port, &iface, 1);
+#endif
 
         br = ovsrec_bridge_insert(ctx->txn);
         ovsrec_bridge_set_name(br, br_name);
+#ifndef OPS
         ovsrec_bridge_set_ports(br, &port, 1);
+#endif
 
         ovs_insert_bridge(vsctl_ctx->ovs, br);
-    } else {
+    }
+#ifndef OPS
+    else {
         struct vsctl_bridge *conflict;
         struct vsctl_bridge *parent;
         struct ovsrec_port *port;
@@ -1254,6 +1717,7 @@ cmd_add_br(struct ctl_context *ctx)
     }
 
     post_db_reload_expect_iface(iface);
+#endif
     vsctl_context_invalidate_cache(ctx);
 }
 
@@ -1275,25 +1739,30 @@ del_port(struct vsctl_context *vsctl_ctx, struct vsctl_port *port)
 static void
 del_bridge(struct vsctl_context *vsctl_ctx, struct vsctl_bridge *br)
 {
+#ifndef OPS
     struct vsctl_bridge *child, *next_child;
+#endif
     struct vsctl_port *port, *next_port;
+#ifndef OPS_TEMP
     const struct ovsrec_flow_sample_collector_set *fscset, *next_fscset;
 
     HMAP_FOR_EACH_SAFE (child, next_child, children_node, &br->children) {
         del_bridge(vsctl_ctx, child);
     }
+#endif
 
     LIST_FOR_EACH_SAFE (port, next_port, ports_node, &br->ports) {
         del_port(vsctl_ctx, port);
     }
 
+#ifndef OPS_TEMP
     OVSREC_FLOW_SAMPLE_COLLECTOR_SET_FOR_EACH_SAFE (fscset, next_fscset,
                                                     vsctl_ctx->base.idl) {
         if (fscset->bridge == br->br_cfg) {
             ovsrec_flow_sample_collector_set_delete(fscset);
         }
     }
-
+#endif
     del_cached_bridge(vsctl_ctx, br);
 }
 
@@ -1309,6 +1778,13 @@ cmd_del_br(struct ctl_context *ctx)
     if (bridge) {
         del_bridge(vsctl_ctx, bridge);
     }
+#ifdef OPS
+    /* There is a difference in behavior between OPS and standard OVS:
+     * (interface automatic deletion) means that we don't know if
+     * the cache is correct or not after deleting a port
+     */
+    vsctl_context_invalidate_cache(ctx);
+#endif
 }
 
 static void
@@ -1467,6 +1943,584 @@ cmd_br_get_external_id(struct ctl_context *ctx)
     }
 }
 
+#ifdef OPS
+/* We only support VLAN IDs 1-4094. */
+#define VALID_VLAN_ID(v)  ((v) > 0 && (v) < 4095)
+
+static void
+pre_get_vlan_info(struct ctl_context *ctx)
+{
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_open_vswitch_col_bridges);
+
+    ovsdb_idl_add_table(ctx->idl, &ovsrec_table_bridge);
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_name);
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_bridge_col_vlans);
+
+    ovsdb_idl_add_table(ctx->idl, &ovsrec_table_vlan);
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_vlan_col_name);
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_vlan_col_id);
+}
+
+static void
+bridge_insert_vlan(struct ovsrec_bridge *br, struct ovsrec_vlan *vlan)
+{
+    struct ovsrec_vlan **vlans;
+    size_t i;
+
+    vlans = xmalloc(sizeof *br->vlans * (br->n_vlans + 1));
+    for (i = 0; i < br->n_vlans; i++) {
+        vlans[i] = br->vlans[i];
+    }
+    vlans[br->n_vlans] = vlan;
+    ovsrec_bridge_set_vlans(br, vlans, br->n_vlans + 1);
+    free(vlans);
+}
+
+static void
+bridge_delete_vlan(struct ovsrec_bridge *br, struct ovsrec_vlan *vlan)
+{
+    struct ovsrec_vlan **vlans;
+    size_t i, n;
+
+    vlans = xmalloc(sizeof *br->vlans * br->n_vlans);
+    for (i = n = 0; i < br->n_vlans; i++) {
+        if (br->vlans[i] != vlan) {
+            vlans[n++] = br->vlans[i];
+        }
+    }
+    ovsrec_bridge_set_vlans(br, vlans, n);
+    free(vlans);
+}
+
+static void
+cmd_list_vlans(struct ctl_context *ctx)
+{
+    struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
+    int i;
+    struct vsctl_bridge *br;
+    struct svec vlans;
+
+    vsctl_context_populate_cache(ctx);
+    br = find_bridge(vsctl_ctx, ctx->argv[1], true);
+
+    svec_init(&vlans);
+    for (i = 0; i < br->br_cfg->n_vlans; i++) {
+        struct ovsrec_vlan *vlan_cfg = br->br_cfg->vlans[i];
+        svec_add(&vlans, vlan_cfg->name);
+    }
+
+    output_sorted(&vlans, &ctx->output);
+    svec_destroy(&vlans);
+}
+
+static void
+cmd_add_vlan(struct ctl_context *ctx)
+{
+    struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
+    int i, vid;
+    char vlan_name[16];
+    char *br_name;
+    int n_settings;
+    char **settings;
+    struct vsctl_bridge *bridge = NULL;
+    struct ovsrec_vlan *vlan = NULL;
+    bool may_exist = shash_find(&ctx->options, "--may-exist") != NULL;
+
+    br_name = ctx->argv[1];
+    vid = atoi(ctx->argv[2]);
+    if (!VALID_VLAN_ID(vid)) {
+        ds_put_format(&ctx->output, "Invalid VLAN ID %s\n", ctx->argv[2]);
+        return;
+    } else {
+        /* For the purpose of ovs-vsctl tool, construct
+         * fixed VLAN name based on VID. */
+        snprintf(vlan_name, 16, "VLAN%d", vid);
+    }
+    settings = &ctx->argv[3];
+    n_settings = ctx->argc - 3;
+
+    vsctl_context_populate_cache(ctx);
+    bridge = find_bridge(vsctl_ctx, br_name, true);
+
+    if (may_exist) {
+        int i;
+        for (i=0; i<bridge->br_cfg->n_vlans; i++) {
+            if (vid == bridge->br_cfg->vlans[i]->id) {
+                ds_put_format(&ctx->output, "VLAN %d already exists on bridge %s\n",
+                              vid, bridge->br_cfg->name);
+                return;
+            }
+        }
+    }
+
+    ds_put_format(&ctx->output, "Creating VLAN %d on bridge %s\n",
+                  vid, bridge->br_cfg->name);
+
+    vlan = ovsrec_vlan_insert(ctx->txn);
+    ovsrec_vlan_set_name(vlan, vlan_name);
+    ovsrec_vlan_set_id(vlan, vid);
+    ovsrec_vlan_set_oper_state(vlan,
+                               OVSREC_VLAN_OPER_STATE_UNKNOWN);
+    ovsrec_vlan_set_oper_state_reason(vlan,
+                                      OVSREC_VLAN_OPER_STATE_REASON_UNKNOWN);
+    for (i = 0; i < n_settings; i++) {
+        ctl_set_column("VLAN", &vlan->header_, settings[i],
+                   ctx->symtab);
+    }
+
+    bridge_insert_vlan(bridge->br_cfg, vlan);
+}
+
+static void
+cmd_del_vlan(struct ctl_context *ctx)
+{
+    struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
+    int i, vid;
+    bool found = false;
+    char *br_name;
+    struct vsctl_bridge *bridge = NULL;
+    struct ovsrec_vlan *vlan = NULL;
+    bool if_exist = shash_find(&ctx->options, "--if-exists") != NULL;
+
+    br_name = ctx->argv[1];
+    vid = atoi(ctx->argv[2]);
+    if (!VALID_VLAN_ID(vid)) {
+        ds_put_format(&ctx->output, "Invalid VLAN ID %s\n", ctx->argv[2]);
+        return;
+    }
+
+    vsctl_context_populate_cache(ctx);
+    bridge = find_bridge(vsctl_ctx, br_name, true);
+
+    for (i=0; i<bridge->br_cfg->n_vlans; i++) {
+        if (vid == bridge->br_cfg->vlans[i]->id) {
+            found = true;
+            vlan = bridge->br_cfg->vlans[i];
+            break;
+        }
+    }
+
+    if (!found) {
+        if (if_exist) {
+            ds_put_format(&ctx->output, "VLAN %d does not exist on bridge %s\n",
+                          vid, bridge->br_cfg->name);
+            return;
+        } else {
+            ctl_fatal("Error - VLAN %d does not exist on bridge %s!\n",
+                        vid, bridge->br_cfg->name);
+        }
+    }
+
+    ds_put_format(&ctx->output, "Deleting VLAN %d on bridge %s\n",
+                  vid, bridge->br_cfg->name);
+
+    bridge_delete_vlan(bridge->br_cfg, vlan);
+}
+
+static void
+pre_get_vrf_info(struct ctl_context *ctx)
+{
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_open_vswitch_col_vrfs);
+
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_vrf_col_name);
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_vrf_col_ports);
+
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_name);
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_port_col_interfaces);
+
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_interface_col_name);
+    /* FIXME: We currently use presence of subsystems as an indicator
+     * that this is a physical switch instead of a virtual switch.  This
+     * isn't ideal, and we may want a more direct method of determining
+     * this distinction.
+     */
+    ovsdb_idl_add_column(ctx->idl, &ovsrec_open_vswitch_col_subsystems);
+}
+
+static void
+verify_vrf_ports(struct vsctl_context *ctx)
+{
+    if (!ctx->verified_ports) {
+        const struct ovsrec_vrf *vrf;
+        const struct ovsrec_port *port;
+
+        ovsrec_open_vswitch_verify_vrfs(ctx->ovs);
+        OVSREC_VRF_FOR_EACH (vrf, ctx->base.idl) {
+            ovsrec_vrf_verify_ports(vrf);
+        }
+        OVSREC_PORT_FOR_EACH (port, ctx->base.idl) {
+            ovsrec_port_verify_interfaces(port);
+        }
+
+        ctx->verified_ports = true;
+    }
+}
+
+static struct vsctl_iface *
+find_orphan_vrf_iface(struct vsctl_context *ctx, const char *name, bool must_exist)
+{
+    struct vsctl_iface *iface;
+
+    ovs_assert(ctx->cache_valid);
+
+    iface = shash_find_data(&ctx->orphan_ifaces, name);
+    if (must_exist && !iface) {
+        ctl_fatal("no interface named %s", name);
+    }
+    verify_vrf_ports(ctx);
+    return iface;
+}
+
+static void
+check_vrf_conflicts(struct vsctl_context *ctx, const char *name,
+                    char *msg)
+{
+    verify_vrf_ports(ctx);
+
+    if (shash_find(&ctx->vrfs, name)) {
+        ctl_fatal("%s because a vrf named %s already exists",
+                    msg, name);
+    }
+
+    free(msg);
+}
+
+static struct vsctl_vrf *
+find_vrf(struct vsctl_context *ctx, const char *name, bool must_exist)
+{
+    struct vsctl_vrf *vrf;
+
+    ovs_assert(ctx->cache_valid);
+
+    vrf = shash_find_data(&ctx->vrfs, name);
+    if (must_exist && !vrf) {
+        ctl_fatal("no vrf named %s", name);
+    }
+    ovsrec_open_vswitch_verify_vrfs(ctx->ovs);
+    return vrf;
+}
+
+static struct vsctl_port *
+find_vrf_port(struct vsctl_context *ctx, const char *name, bool must_exist)
+{
+    struct vsctl_port *port;
+
+    ovs_assert(ctx->cache_valid);
+
+    port = shash_find_data(&ctx->ports, name);
+    if (must_exist && !port) {
+        ctl_fatal("no port named %s", name);
+    }
+    verify_vrf_ports(ctx);
+    return port;
+}
+
+static void
+cmd_list_vrf_ports(struct ctl_context *ctx)
+{
+    struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
+    struct vsctl_vrf *vrf;
+    struct vsctl_port *port;
+    struct svec ports;
+
+    vsctl_context_populate_cache(ctx);
+    vrf = find_vrf(vsctl_ctx, ctx->argv[1], true);
+    ovsrec_vrf_verify_ports(vrf->vrf_cfg);
+
+    svec_init(&ports);
+    LIST_FOR_EACH (port, ports_node, &vrf->ports) {
+        if (strcmp(port->port_cfg->name, vrf->name)) {
+            svec_add(&ports, port->port_cfg->name);
+        }
+    }
+    output_sorted(&ports, &ctx->output);
+    svec_destroy(&ports);
+}
+
+static void
+vrf_insert_port(struct ovsrec_vrf *vrf, struct ovsrec_port *port)
+{
+    struct ovsrec_port **ports;
+    size_t i;
+
+    ports = xmalloc(sizeof *vrf->ports * (vrf->n_ports + 1));
+    for (i = 0; i < vrf->n_ports; i++) {
+        ports[i] = vrf->ports[i];
+    }
+    ports[vrf->n_ports] = port;
+    ovsrec_vrf_set_ports(vrf, ports, vrf->n_ports + 1);
+    free(ports);
+}
+
+static void
+add_vrf_port(struct ctl_context *ctx,
+         const char *vrf_name, const char *port_name,
+         bool may_exist,
+         char *iface_names[], int n_ifaces)
+{
+    struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
+    struct vsctl_port *vsctl_port;
+    struct vsctl_vrf *vrf = NULL;
+    struct ovsrec_interface **ifaces;
+    struct ovsrec_port *port;
+    size_t i;
+
+    vsctl_context_populate_cache(ctx);
+    if (may_exist) {
+        struct vsctl_port *vsctl_port;
+
+        vsctl_port = find_vrf_port(vsctl_ctx, port_name, false);
+        if (vsctl_port) {
+            if (vsctl_port->port_type == VRF_PORT &&
+                strcmp(vsctl_port->vrf->name, vrf_name)) {
+                char *command = vsctl_context_to_string(ctx);
+                ctl_fatal("\"%s\" but %s is actually attached to vrf %s",
+                            command, port_name, vsctl_port->vrf->name);
+            } else if (vsctl_port->port_type == BR_PORT) {
+                char *command = vsctl_context_to_string(ctx);
+                ctl_fatal("\"%s\" but %s is actually attached to bridge %s",
+                            command, port_name, vsctl_port->bridge->name);
+            }
+            return;
+        }
+    }
+
+    vrf = find_vrf(vsctl_ctx, vrf_name, true);
+
+    ifaces = xmalloc(n_ifaces * sizeof *ifaces);
+    for (i = 0; i < n_ifaces; i++) {
+        /* find the existing interface in the orphan_ifaces dictionary */
+        if (vsctl_ctx->subsystems_exist) {
+            struct vsctl_iface *iface;
+            iface = find_orphan_vrf_iface(vsctl_ctx, iface_names[i], true);
+            ifaces[i] = (struct ovsrec_interface *)iface->iface_cfg;
+        } else {
+            ifaces[i] = ovsrec_interface_insert(ctx->txn);
+            ovsrec_interface_set_name(ifaces[i], iface_names[i]);
+            post_db_reload_expect_iface(ifaces[i]);
+        }
+    }
+
+    port = ovsrec_port_insert(ctx->txn);
+    ovsrec_port_set_name(port, port_name);
+    ovsrec_port_set_interfaces(port, ifaces, n_ifaces);
+
+    vrf_insert_port(vrf->vrf_cfg, port);
+
+    vsctl_port = add_vrf_port_to_cache(vsctl_ctx, vrf, port);
+    for (i = 0; i < n_ifaces; i++) {
+        if (vsctl_ctx->subsystems_exist) {
+            move_orphan_iface_to_cache(vsctl_ctx, vsctl_port, ifaces[i]);
+        } else {
+            add_iface_to_cache(vsctl_ctx, vsctl_port, ifaces[i]);
+        }
+    }
+    free(ifaces);
+}
+
+static void
+cmd_add_vrf_port(struct ctl_context *ctx)
+{
+    bool may_exist = shash_find(&ctx->options, "--may-exist") != NULL;
+    add_vrf_port(ctx, ctx->argv[1], ctx->argv[2], may_exist, &ctx->argv[2], 1);
+}
+
+static void
+vrf_delete_port(struct ovsrec_vrf *vrf, struct ovsrec_port *port)
+{
+    struct ovsrec_port **ports;
+    size_t i, n;
+
+    ports = xmalloc(sizeof *vrf->ports * vrf->n_ports);
+    for (i = n = 0; i < vrf->n_ports; i++) {
+        if (vrf->ports[i] != port) {
+            ports[n++] = vrf->ports[i];
+        }
+    }
+    ovsrec_vrf_set_ports(vrf, ports, n);
+    free(ports);
+}
+
+static void
+del_vrf_port(struct vsctl_context *ctx, struct vsctl_port *port)
+{
+    struct vsctl_iface *iface, *next_iface;
+
+    vrf_delete_port(port->vrf->vrf_cfg, port->port_cfg);
+
+    LIST_FOR_EACH_SAFE (iface, next_iface, ifaces_node, &port->ifaces) {
+        del_cached_iface(ctx, iface);
+    }
+    del_cached_port(ctx, port);
+}
+
+static void
+cmd_del_vrf_port(struct ctl_context *ctx)
+{
+    struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
+    bool must_exist = !shash_find(&ctx->options, "--if-exists");
+    const char *target = ctx->argv[ctx->argc - 1];
+    struct vsctl_port *port;
+
+    vsctl_context_populate_cache(ctx);
+
+    port = find_vrf_port(vsctl_ctx, target, must_exist);
+
+    if (port) {
+        if (ctx->argc == 3) {
+            struct vsctl_vrf *vrf;
+
+            vrf = find_vrf(vsctl_ctx, ctx->argv[1], true);
+            if (port->vrf != vrf) {
+                ctl_fatal("vrf %s does not have a port %s",
+                            ctx->argv[1], ctx->argv[2]);
+            }
+        }
+
+        del_vrf_port(vsctl_ctx, port);
+    }
+    /* difference in behavior between OPS and standard OVS
+     * (interface automatic deletion) means that we don't know if
+     * the cache is correct or not after deleting a port
+     */
+    vsctl_context_invalidate_cache(ctx);
+}
+
+static void
+cmd_port_to_vrf(struct ctl_context *ctx)
+{
+    struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
+    struct vsctl_port *port;
+
+    vsctl_context_populate_cache(ctx);
+
+    port = find_vrf_port(vsctl_ctx, ctx->argv[1], true);
+    ds_put_format(&ctx->output, "%s\n", port->vrf->name);
+}
+
+static void
+cmd_list_vrf(struct ctl_context *ctx)
+{
+    struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
+    struct shash_node *node;
+    struct svec vrfs;
+
+    vsctl_context_populate_cache(ctx);
+
+    svec_init(&vrfs);
+    SHASH_FOR_EACH (node, &vsctl_ctx->vrfs) {
+        struct vsctl_vrf *vrf = node->data;
+        svec_add(&vrfs, vrf->name);
+    }
+    output_sorted(&vrfs, &ctx->output);
+    svec_destroy(&vrfs);
+}
+
+static void
+ovs_insert_vrf(const struct ovsrec_open_vswitch *ovs,
+               struct ovsrec_vrf *vrf)
+{
+    struct ovsrec_vrf **vrfs;
+    size_t i;
+
+    vrfs = xmalloc(sizeof *ovs->vrfs * (ovs->n_vrfs + 1));
+    for (i = 0; i < ovs->n_vrfs; i++) {
+        vrfs[i] = ovs->vrfs[i];
+    }
+    vrfs[ovs->n_vrfs] = vrf;
+    ovsrec_open_vswitch_set_vrfs(ovs, vrfs, ovs->n_vrfs + 1);
+    free(vrfs);
+}
+
+static void
+cmd_add_vrf(struct ctl_context *ctx)
+{
+    struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
+    struct ovsrec_vrf *vrf;
+    const char *vrf_name;
+    bool may_exist = shash_find(&ctx->options, "--may-exist") != NULL;
+
+    vrf_name = ctx->argv[1];
+
+    vsctl_context_populate_cache(ctx);
+    if (may_exist) {
+        struct vsctl_vrf *vrf;
+
+        vrf = find_vrf(vsctl_ctx, vrf_name, false);
+        if (vrf) {
+            return;
+        }
+    }
+    check_vrf_conflicts(vsctl_ctx, vrf_name,
+                        xasprintf("cannot create a vrf named %s", vrf_name));
+
+    vrf = ovsrec_vrf_insert(ctx->txn);
+    ovsrec_vrf_set_name(vrf, vrf_name);
+
+    ovs_insert_vrf(vsctl_ctx->ovs, vrf);
+
+    vsctl_context_invalidate_cache(ctx);
+}
+
+static void
+ovs_delete_vrf(const struct ovsrec_open_vswitch *ovs,
+                  struct ovsrec_vrf *vrf)
+{
+    struct ovsrec_vrf **vrfs;
+    size_t i, n;
+
+    vrfs = xmalloc((sizeof *ovs->vrfs) * ovs->n_vrfs);
+    for (i = n = 0; i < ovs->n_vrfs; i++) {
+        if (ovs->vrfs[i] != vrf) {
+            vrfs[n++] = ovs->vrfs[i];
+        }
+    }
+    ovsrec_open_vswitch_set_vrfs(ovs, vrfs, n);
+    free(vrfs);
+}
+
+static void
+del_cached_vrf(struct vsctl_context *ctx, struct vsctl_vrf *vrf)
+{
+    ovs_assert(list_is_empty(&vrf->ports));
+
+    if (vrf->vrf_cfg) {
+        ovsrec_vrf_delete(vrf->vrf_cfg);
+        ovs_delete_vrf(ctx->ovs, vrf->vrf_cfg);
+    }
+    shash_find_and_delete(&ctx->vrfs, vrf->name);
+    free(vrf->name);
+    free(vrf);
+}
+
+static void
+del_vrf(struct vsctl_context *ctx, struct vsctl_vrf *vrf)
+{
+    struct vsctl_port *port, *next_port;
+
+    LIST_FOR_EACH_SAFE (port, next_port, ports_node, &vrf->ports) {
+        del_vrf_port(ctx, port);
+    }
+
+    del_cached_vrf(ctx, vrf);
+}
+
+static void
+cmd_del_vrf(struct ctl_context *ctx)
+{
+    struct vsctl_context *vsctl_ctx = vsctl_context_cast(ctx);
+    struct vsctl_vrf *vrf;
+    bool must_exist = !shash_find(&ctx->options, "--if-exists");
+
+    vsctl_context_populate_cache(ctx);
+    vrf = find_vrf(vsctl_ctx, ctx->argv[1], must_exist);
+    if (vrf) {
+        del_vrf(vsctl_ctx, vrf);
+    }
+}
+
+#endif
+
 static void
 cmd_list_ports(struct ctl_context *ctx)
 {
@@ -1492,7 +2546,12 @@ cmd_list_ports(struct ctl_context *ctx)
 static void
 add_port(struct ctl_context *ctx,
          const char *br_name, const char *port_name,
-         bool may_exist, bool fake_iface,
+         bool may_exist,
+#ifndef OPS_TEMP
+         bool fake_iface,
+#else
+         bool fake_iface OVS_UNUSED,
+#endif
          char *iface_names[], int n_ifaces,
          char *settings[], int n_settings)
 {
@@ -1524,11 +2583,24 @@ add_port(struct ctl_context *ctx,
             }
             svec_sort(&have_names);
 
+#ifdef OPS
+            if (vsctl_port->port_type == BR_PORT && 
+                strcmp(vsctl_port->bridge->name, br_name)) {
+                char *command = vsctl_context_to_string(ctx);
+                ctl_fatal("\"%s\" but %s is actually attached to bridge %s",
+                            command, port_name, vsctl_port->bridge->name);
+            } else if (vsctl_port->port_type == VRF_PORT) {
+                char *command = vsctl_context_to_string(ctx);
+                ctl_fatal("\"%s\" but %s is actually attached to vrf %s",
+                            command, port_name, vsctl_port->vrf->name);
+            }
+#else
             if (strcmp(vsctl_port->bridge->name, br_name)) {
                 char *command = vsctl_context_to_string(ctx);
                 ctl_fatal("\"%s\" but %s is actually attached to bridge %s",
                             command, port_name, vsctl_port->bridge->name);
             }
+#endif
 
             if (!svec_equal(&want_names, &have_names)) {
                 char *have_names_string = svec_join(&have_names, ", ", "");
@@ -1555,15 +2627,27 @@ add_port(struct ctl_context *ctx,
 
     ifaces = xmalloc(n_ifaces * sizeof *ifaces);
     for (i = 0; i < n_ifaces; i++) {
-        ifaces[i] = ovsrec_interface_insert(ctx->txn);
-        ovsrec_interface_set_name(ifaces[i], iface_names[i]);
-        post_db_reload_expect_iface(ifaces[i]);
+#ifdef OPS
+        /* find the existing interface in the orphan_ifaces dictionary */
+        if (vsctl_ctx->subsystems_exist) {
+            struct vsctl_iface *iface;
+            iface = find_orphan_iface(vsctl_ctx, iface_names[i], true);
+            ifaces[i] = (struct ovsrec_interface *)iface->iface_cfg;
+        } else
+#endif
+        {
+            ifaces[i] = ovsrec_interface_insert(ctx->txn);
+            ovsrec_interface_set_name(ifaces[i], iface_names[i]);
+            post_db_reload_expect_iface(ifaces[i]);
+        }
     }
 
     port = ovsrec_port_insert(ctx->txn);
     ovsrec_port_set_name(port, port_name);
     ovsrec_port_set_interfaces(port, ifaces, n_ifaces);
+#ifndef OPS_TEMP
     ovsrec_port_set_bond_fake_iface(port, fake_iface);
+#endif
 
     if (bridge->parent) {
         int64_t tag = bridge->vlan;
@@ -1580,7 +2664,14 @@ add_port(struct ctl_context *ctx,
 
     vsctl_port = add_port_to_cache(vsctl_ctx, bridge, port);
     for (i = 0; i < n_ifaces; i++) {
-        add_iface_to_cache(vsctl_ctx, vsctl_port, ifaces[i]);
+#ifdef OPS
+        if (vsctl_ctx->subsystems_exist) {
+            move_orphan_iface_to_cache(vsctl_ctx, vsctl_port, ifaces[i]);
+        } else
+#endif
+        {
+            add_iface_to_cache(vsctl_ctx, vsctl_port, ifaces[i]);
+        }
     }
     free(ifaces);
 }
@@ -1673,6 +2764,13 @@ cmd_del_port(struct ctl_context *ctx)
 
         del_port(vsctl_ctx, port);
     }
+#ifdef OPS
+    /* difference in behavior between OPS and standard OVS
+     * (interface automatic deletion) means that we don't know if
+     * the cache is correct or not after deleting a port
+     */
+    vsctl_context_invalidate_cache(ctx);
+#endif
 }
 
 static void
@@ -1753,6 +2851,7 @@ cmd_iface_to_br(struct ctl_context *ctx)
     ds_put_format(&ctx->output, "%s\n", iface->port->bridge->name);
 }
 
+#ifndef OPS_TEMP
 static void
 verify_controllers(struct ovsrec_bridge *bridge)
 {
@@ -1919,7 +3018,7 @@ cmd_set_fail_mode(struct ctl_context *ctx)
 
     ovsrec_bridge_set_fail_mode(br->br_cfg, fail_mode);
 }
-
+#endif
 static void
 verify_managers(const struct ovsrec_open_vswitch *ovs)
 {
@@ -2100,6 +3199,7 @@ cmd_set_ssl(struct ctl_context *ctx)
     ovsrec_open_vswitch_set_ssl(vsctl_ctx->ovs, ssl);
 }
 
+#ifndef OPS_TEMP
 static void
 autoattach_insert_mapping(struct ovsrec_autoattach *aa,
                           int64_t isid,
@@ -2275,37 +3375,100 @@ cmd_get_aa_mapping(struct ctl_context *ctx)
         }
     }
 }
+#endif
 
 
 static const struct ctl_table_class tables[] = {
     {&ovsrec_table_bridge,
      {{&ovsrec_table_bridge, &ovsrec_bridge_col_name, NULL},
+#ifndef OPS_TEMP
       {&ovsrec_table_flow_sample_collector_set, NULL,
-       &ovsrec_flow_sample_collector_set_col_bridge}}},
+       &ovsrec_flow_sample_collector_set_col_bridge}
+#endif
+    }},
 
+#ifndef OPS_TEMP
     {&ovsrec_table_controller,
      {{&ovsrec_table_bridge,
        &ovsrec_bridge_col_name,
        &ovsrec_bridge_col_controller}}},
-
+#endif
+#ifdef OPS
+    {&ovsrec_table_subsystem,
+     {{&ovsrec_table_subsystem, &ovsrec_subsystem_col_name, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_led,
+     {{&ovsrec_table_led, &ovsrec_led_col_id, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_fan,
+     {{&ovsrec_table_fan, &ovsrec_fan_col_name, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_temp_sensor,
+     {{&ovsrec_table_temp_sensor, &ovsrec_temp_sensor_col_name, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_power_supply,
+     {{&ovsrec_table_power_supply, &ovsrec_power_supply_col_name, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_daemon,
+     {{&ovsrec_table_daemon, &ovsrec_daemon_col_name, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_vlan,
+     {{&ovsrec_table_vlan, &ovsrec_vlan_col_name, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_vrf,
+     {{&ovsrec_table_vrf, &ovsrec_vrf_col_name, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_ospf_router,
+     {{&ovsrec_table_ospf_router, &ovsrec_ospf_router_col_areas, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_ospf_area,
+     {{&ovsrec_table_ospf_area, &ovsrec_ospf_area_col_abr_summary_lsas, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_ospf_vlink,
+     {{&ovsrec_table_ospf_vlink, &ovsrec_ospf_vlink_col_area_id, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_ospf_interface,
+     {{&ovsrec_table_ospf_interface, &ovsrec_ospf_interface_col_ifsm_state, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_ospf_nbma_neighbor,
+     {{&ovsrec_table_ospf_nbma_neighbor,
+     &ovsrec_ospf_nbma_neighbor_col_status, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_ospf_lsa,
+     {{&ovsrec_table_ospf_lsa, &ovsrec_ospf_lsa_col_area_id, NULL},
+     {NULL, NULL, NULL}}},
+    {&ovsrec_table_ospf_neighbor,
+     {{&ovsrec_table_ospf_neighbor, &ovsrec_ospf_neighbor_col_bdr, NULL},
+     {NULL, NULL, NULL}}},
+     {&ovsrec_table_ospf_summary_address,
+     {{&ovsrec_table_ospf_summary_address,
+       &ovsrec_ospf_summary_address_col_other_config, NULL},
+     {NULL, NULL, NULL}}},
+     {&ovsrec_table_ospf_route,
+     {{&ovsrec_table_ospf_route,
+       &ovsrec_ospf_route_col_paths, NULL},
+     {NULL, NULL, NULL}}},
+#endif
     {&ovsrec_table_interface,
      {{&ovsrec_table_interface, &ovsrec_interface_col_name, NULL},
       {NULL, NULL, NULL}}},
 
+#ifndef OPS_TEMP
     {&ovsrec_table_mirror,
      {{&ovsrec_table_mirror, &ovsrec_mirror_col_name, NULL},
       {NULL, NULL, NULL}}},
-
+#endif
     {&ovsrec_table_manager,
      {{&ovsrec_table_manager, &ovsrec_manager_col_target, NULL},
       {NULL, NULL, NULL}}},
 
+#ifndef OPS_TEMP
     {&ovsrec_table_netflow,
      {{&ovsrec_table_bridge,
        &ovsrec_bridge_col_name,
        &ovsrec_bridge_col_netflow},
       {NULL, NULL, NULL}}},
-
+#endif
     {&ovsrec_table_open_vswitch,
      {{&ovsrec_table_open_vswitch, NULL, NULL},
       {NULL, NULL, NULL}}},
@@ -2314,6 +3477,7 @@ static const struct ctl_table_class tables[] = {
      {{&ovsrec_table_port, &ovsrec_port_col_name, NULL},
       {NULL, NULL, NULL}}},
 
+#ifndef OPS_TEMP
     {&ovsrec_table_qos,
      {{&ovsrec_table_port, &ovsrec_port_col_name, &ovsrec_port_col_qos},
       {NULL, NULL, NULL}}},
@@ -2321,10 +3485,11 @@ static const struct ctl_table_class tables[] = {
     {&ovsrec_table_queue,
      {{NULL, NULL, NULL},
       {NULL, NULL, NULL}}},
-
+#endif
     {&ovsrec_table_ssl,
      {{&ovsrec_table_open_vswitch, NULL, &ovsrec_open_vswitch_col_ssl}}},
 
+#ifndef OPS_TEMP
     {&ovsrec_table_sflow,
      {{&ovsrec_table_bridge,
        &ovsrec_bridge_col_name,
@@ -2351,7 +3516,7 @@ static const struct ctl_table_class tables[] = {
     {&ovsrec_table_flow_sample_collector_set,
      {{NULL, NULL, NULL},
       {NULL, NULL, NULL}}},
-
+#endif
     {NULL, {{NULL, NULL, NULL}, {NULL, NULL, NULL}}}
 };
 
@@ -2372,6 +3537,7 @@ post_db_reload_expect_iface(const struct ovsrec_interface *iface)
     neoteric_ifaces[n_neoteric_ifaces++] = iface->header_.uuid;
 }
 
+#ifndef OPS_TEMP
 static void
 post_db_reload_do_checks(const struct vsctl_context *vsctl_ctx)
 {
@@ -2401,6 +3567,7 @@ post_db_reload_do_checks(const struct vsctl_context *vsctl_ctx)
 
     ds_destroy(&dead_ifaces);
 }
+#endif
 
 
 static void
@@ -2632,7 +3799,9 @@ do_vsctl(const char *args, struct ctl_command *commands, size_t n_commands,
             ovsdb_idl_run(idl);
             OVSREC_OPEN_VSWITCH_FOR_EACH (ovs, idl) {
                 if (ovs->cur_cfg >= next_cfg) {
+#ifndef OPS_TEMP
                     post_db_reload_do_checks(&vsctl_ctx);
+#endif
                     goto done;
                 }
             }
@@ -2707,8 +3876,12 @@ static const struct ctl_command_syntax vsctl_commands[] = {
      cmd_add_br, NULL, "--may-exist", RW},
     {"del-br", 1, 1, "BRIDGE", pre_get_info, cmd_del_br,
      NULL, "--if-exists", RW},
+#ifndef OPS_TEMP
     {"list-br", 0, 0, "", pre_get_info, cmd_list_br, NULL, "--real,--fake",
      RO},
+#else
+    {"list-br", 0, 0, "", pre_get_info, cmd_list_br, NULL, "", RO},
+#endif
     {"br-exists", 1, 1, "BRIDGE", pre_get_info, cmd_br_exists, NULL, "", RO},
     {"br-to-vlan", 1, 1, "BRIDGE", pre_get_info, cmd_br_to_vlan, NULL, "",
      RO},
@@ -2719,6 +3892,31 @@ static const struct ctl_command_syntax vsctl_commands[] = {
     {"br-get-external-id", 1, 2, "BRIDGE [KEY]", pre_cmd_br_get_external_id,
      cmd_br_get_external_id, NULL, "", RO},
 
+#ifdef OPS
+    /* VLAN commands. */
+    {"list-vlans", 1, 1, "", pre_get_vlan_info, cmd_list_vlans, NULL, "", RO},
+    {"add-vlan", 2, INT_MAX, "", pre_get_vlan_info, cmd_add_vlan, NULL,
+     "--may-exist", RW},
+    {"del-vlan", 2, 2, "", pre_get_vlan_info, cmd_del_vlan, NULL, "--if-exists",
+     RW},
+
+    /* VRF commands */
+    {"list-vrf", 0, 0, "", pre_get_vrf_info, cmd_list_vrf, NULL, "", RO},
+    {"add-vrf", 1, 1, "", pre_get_vrf_info, cmd_add_vrf, NULL,
+     "--may-exist", RW},
+    {"del-vrf", 1, 1, "", pre_get_vrf_info, cmd_del_vrf, NULL, "--if-exists",
+     RW},
+
+    /* VRF Port commands. */
+    {"list-vrf-ports", 1, 1, "", pre_get_vrf_info, cmd_list_vrf_ports,
+     NULL, "", RO},
+    {"add-vrf-port", 2, INT_MAX, "", pre_get_vrf_info, cmd_add_vrf_port,
+     NULL, "--may-exist", RW},
+    {"del-vrf-port", 1, 2, "", pre_get_vrf_info, cmd_del_vrf_port, NULL,
+     "--if-exists", RW},
+    {"port-to-vrf", 1, 1, "", pre_get_vrf_info, cmd_port_to_vrf, NULL, "", RO},
+
+#endif
     /* Port commands. */
     {"list-ports", 1, 1, "BRIDGE", pre_get_info, cmd_list_ports, NULL, "",
      RO},
@@ -2737,6 +3935,7 @@ static const struct ctl_command_syntax vsctl_commands[] = {
     {"iface-to-br", 1, 1, "IFACE", pre_get_info, cmd_iface_to_br, NULL, "",
      RO},
 
+#ifndef OPS_TEMP
     /* Controller commands. */
     {"get-controller", 1, 1, "BRIDGE", pre_controller, cmd_get_controller,
      NULL, "", RO},
@@ -2750,7 +3949,7 @@ static const struct ctl_command_syntax vsctl_commands[] = {
      "", RW},
     {"set-fail-mode", 2, 2, "BRIDGE MODE", pre_get_info, cmd_set_fail_mode,
      NULL, "", RW},
-
+#endif
     /* Manager commands. */
     {"get-manager", 0, 0, "", pre_manager, cmd_get_manager, NULL, "", RO},
     {"del-manager", 0, 0, "", pre_manager, cmd_del_manager, NULL, "", RW},
@@ -2763,6 +3962,7 @@ static const struct ctl_command_syntax vsctl_commands[] = {
     {"set-ssl", 3, 3, "PRIVATE-KEY CERTIFICATE CA-CERT", pre_cmd_set_ssl,
      cmd_set_ssl, NULL, "--bootstrap", RW},
 
+#ifndef OPS_TEMP
     /* Auto Attach commands. */
     {"add-aa-mapping", 3, 3, "BRIDGE ARG ARG", pre_aa_mapping, cmd_add_aa_mapping,
      NULL, "", RW},
@@ -2770,7 +3970,7 @@ static const struct ctl_command_syntax vsctl_commands[] = {
      NULL, "", RW},
     {"get-aa-mapping", 1, 1, "BRIDGE", pre_aa_mapping, cmd_get_aa_mapping,
      NULL, "", RO},
-
+#endif
     /* Switch commands. */
     {"emer-reset", 0, 0, "", pre_cmd_emer_reset, cmd_emer_reset, NULL, "", RW},
 
diff --git a/vswitchd/vswitch.ovsschema b/vswitchd/vswitch.ovsschema
deleted file mode 100644
index 35f145f..0000000
--- a/vswitchd/vswitch.ovsschema
+++ /dev/null
@@ -1,610 +0,0 @@
-{"name": "Open_vSwitch",
- "version": "7.12.1",
- "cksum": "2211824403 22535",
- "tables": {
-   "Open_vSwitch": {
-     "columns": {
-       "bridges": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "Bridge"},
-                  "min": 0, "max": "unlimited"}},
-       "manager_options": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "Manager"},
-                  "min": 0, "max": "unlimited"}},
-       "ssl": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "SSL"},
-                  "min": 0, "max": 1}},
-       "other_config": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}},
-       "next_cfg": {
-         "type": "integer"},
-       "cur_cfg": {
-         "type": "integer"},
-       "statistics": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"},
-         "ephemeral": true},
-       "ovs_version": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1}},
-       "db_version": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1}},
-       "system_type": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1}},
-       "system_version": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1}},
-       "datapath_types": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": "unlimited"}},
-       "iface_types": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": "unlimited"}}},
-     "isRoot": true,
-     "maxRows": 1},
-   "Bridge": {
-     "columns": {
-       "name": {
-         "type": "string",
-         "mutable": false},
-       "datapath_type": {
-         "type": "string"},
-       "datapath_version": {
-         "type": "string"},
-       "datapath_id": {
-         "type": {"key": "string", "min": 0, "max": 1},
-         "ephemeral": true},
-       "stp_enable": {
-         "type": "boolean"},
-       "rstp_enable": {
-         "type": "boolean"},
-       "mcast_snooping_enable": {
-         "type": "boolean"},
-       "ports": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "Port"},
-                  "min": 0, "max": "unlimited"}},
-       "mirrors": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "Mirror"},
-                  "min": 0, "max": "unlimited"}},
-       "netflow": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "NetFlow"},
-                  "min": 0, "max": 1}},
-       "sflow": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "sFlow"},
-                  "min": 0, "max": 1}},
-       "ipfix": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "IPFIX"},
-                  "min": 0, "max": 1}},
-       "controller": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "Controller"},
-                  "min": 0, "max": "unlimited"}},
-       "protocols": {
-         "type": {"key": {"type": "string",
-           "enum": ["set", ["OpenFlow10",
-                            "OpenFlow11",
-                            "OpenFlow12",
-                            "OpenFlow13",
-                            "OpenFlow14",
-                            "OpenFlow15"]]},
-	   "min": 0, "max": "unlimited"}},
-       "fail_mode": {
-         "type": {"key": {"type": "string",
-                          "enum": ["set", ["standalone", "secure"]]},
-                  "min": 0, "max": 1}},
-       "status": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"},
-         "ephemeral": true},
-       "rstp_status": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"},
-         "ephemeral": true},
-       "other_config": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}},
-       "flood_vlans": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4095},
-                  "min": 0, "max": 4096}},
-       "flow_tables": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 254},
-                  "value": {"type": "uuid",
-                            "refTable": "Flow_Table"},
-                  "min": 0, "max": "unlimited"}},
-       "auto_attach": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "AutoAttach"},
-                  "min": 0, "max": 1}}},
-     "indexes": [["name"]]},
-   "Port": {
-     "columns": {
-       "name": {
-         "type": "string",
-         "mutable": false},
-       "interfaces": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "Interface"},
-                  "min": 1, "max": "unlimited"}},
-       "trunks": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4095},
-                  "min": 0, "max": 4096}},
-       "tag": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4095},
-                  "min": 0, "max": 1}},
-       "vlan_mode": {
-         "type": {"key": {"type": "string",
-           "enum": ["set", ["trunk", "access", "native-tagged", "native-untagged"]]},
-         "min": 0, "max": 1}},
-       "qos": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "QoS"},
-                  "min": 0, "max": 1}},
-       "mac": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1}},
-       "bond_mode": {
-         "type": {"key": {"type": "string",
-           "enum": ["set", ["balance-tcp", "balance-slb", "active-backup"]]},
-         "min": 0, "max": 1}},
-       "lacp": {
-         "type": {"key": {"type": "string",
-           "enum": ["set", ["active", "passive", "off"]]},
-         "min": 0, "max": 1}},
-       "bond_updelay": {
-         "type": "integer"},
-       "bond_downdelay": {
-         "type": "integer"},
-       "bond_active_slave": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1}},
-       "bond_fake_iface": {
-         "type": "boolean"},
-       "fake_bridge": {
-         "type": "boolean"},
-       "status": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"},
-         "ephemeral": true},
-       "rstp_status": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"},
-         "ephemeral": true},
-       "rstp_statistics": {
-           "type": {"key": "string", "value": "integer", "min": 0, "max": "unlimited"},
-           "ephemeral": true},
-       "statistics": {
-         "type": {"key": "string", "value": "integer", "min": 0, "max": "unlimited"},
-         "ephemeral": true},
-       "other_config": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}}},
-     "indexes": [["name"]]},
-   "Interface": {
-     "columns": {
-       "name": {
-         "type": "string",
-         "mutable": false},
-       "type": {
-         "type": "string"},
-       "options": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}},
-       "ingress_policing_rate": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0}}},
-       "ingress_policing_burst": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0}}},
-       "mac_in_use": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1},
-                  "ephemeral": true},
-       "mac": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1}},
-       "ifindex": {
-         "type": {
-           "key": {"type": "integer",
-                   "minInteger": 0,
-                   "maxInteger": 4294967295},
-           "min": 0,
-           "max": 1},
-         "ephemeral": true},
-       "external_ids": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}},
-       "ofport": {
-         "type": {"key": "integer", "min": 0, "max": 1}},
-       "ofport_request": {
-         "type": {
-           "key": {"type": "integer",
-                   "minInteger": 1,
-                   "maxInteger": 65279},
-           "min": 0,
-           "max": 1}},
-       "bfd": {
-           "type": {"key": "string", "value": "string",
-               "min": 0, "max": "unlimited"}},
-       "bfd_status": {
-           "type": {"key": "string", "value": "string",
-               "min": 0, "max": "unlimited"}},
-       "cfm_mpid": {
-         "type": {
-           "key": {"type": "integer"},
-           "min": 0,
-           "max": 1}},
-       "cfm_remote_mpids": {
-         "type": {
-           "key": {"type": "integer"},
-           "min": 0,
-           "max": "unlimited"},
-         "ephemeral": true},
-       "cfm_flap_count": {
-         "type": {
-           "key": {"type": "integer"},
-           "min": 0,
-           "max": 1}},
-       "cfm_fault": {
-         "type": {
-           "key": { "type": "boolean"},
-           "min": 0,
-           "max": 1},
-         "ephemeral": true},
-       "cfm_fault_status": {
-         "type": {
-           "key": "string", "min": 0, "max": "unlimited"},
-           "ephemeral": true},
-       "cfm_remote_opstate": {
-         "type": {"key": {"type": "string",
-                          "enum": ["set", ["up", "down"]]},
-                  "min": 0, "max": 1},
-         "ephemeral": true},
-       "cfm_health": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 100},
-                  "min": 0, "max": 1},
-           "ephemeral": true},
-       "lacp_current": {
-         "type": {"key": {"type": "boolean"},
-                  "min": 0, "max": 1},
-         "ephemeral": true},
-       "lldp": {
-           "type": {"key": "string", "value": "string",
-               "min": 0, "max": "unlimited"}},
-       "other_config": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}},
-       "statistics": {
-         "type": {"key": "string", "value": "integer", "min": 0, "max": "unlimited"},
-         "ephemeral": true},
-       "status": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"},
-         "ephemeral": true},
-       "admin_state": {
-         "type": {"key": {"type": "string",
-                          "enum": ["set", ["up", "down"]]},
-                  "min": 0, "max": 1},
-         "ephemeral": true},
-       "link_state": {
-         "type": {"key": {"type": "string",
-                          "enum": ["set", ["up", "down"]]},
-                  "min": 0, "max": 1},
-         "ephemeral": true},
-       "link_resets": {
-         "type": {"key": {"type": "integer"},
-                  "min": 0, "max": 1},
-         "ephemeral": true},
-       "link_speed": {
-         "type": {"key": "integer", "min": 0, "max": 1},
-         "ephemeral": true},
-       "duplex": {
-         "type": {"key": {"type": "string",
-                          "enum": ["set", ["half", "full"]]},
-                  "min": 0, "max": 1},
-         "ephemeral": true},
-       "mtu": {
-         "type": {"key": "integer", "min": 0, "max": 1},
-         "ephemeral": true},
-       "error": {
-         "type": {"key": "string", "min": 0, "max": 1}}},
-     "indexes": [["name"]]},
-   "Flow_Table": {
-     "columns": {
-       "name": {
-	 "type": {"key": "string", "min": 0, "max": 1}},
-       "flow_limit": {
-	 "type": {"key": {"type": "integer", "minInteger": 0},
-		  "min": 0, "max": 1}},
-       "overflow_policy": {
-	 "type": {"key": {"type": "string",
-			  "enum": ["set", ["refuse", "evict"]]},
-		  "min": 0, "max": 1}},
-       "groups": {
-	 "type": {"key": "string", "min": 0, "max": "unlimited"}},
-       "prefixes": {
-         "type": {"key": "string", "min": 0, "max": 3}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}}}},
-   "QoS": {
-     "columns": {
-       "type": {
-         "type": "string"},
-       "queues": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4294967295},
-                  "value": {"type": "uuid",
-                            "refTable": "Queue"},
-                  "min": 0, "max": "unlimited"}},
-       "other_config": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}}},
-     "isRoot": true},
-   "Queue": {
-     "columns": {
-       "dscp": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 63},
-                  "min": 0, "max": 1}},
-       "other_config": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}}},
-     "isRoot": true},
-   "Mirror": {
-     "columns": {
-       "name": {
-         "type": "string"},
-       "select_all": {
-         "type": "boolean"},
-       "select_src_port": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "Port",
-                          "refType": "weak"},
-                   "min": 0, "max": "unlimited"}},
-       "select_dst_port": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "Port",
-                          "refType": "weak"},
-                   "min": 0, "max": "unlimited"}},
-       "select_vlan": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4095},
-                  "min": 0, "max": 4096}},
-       "output_port": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "Port",
-                          "refType": "weak"},
-                  "min": 0, "max": 1}},
-       "output_vlan": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 1,
-                          "maxInteger": 4095},
-                  "min": 0, "max": 1}},
-       "statistics": {
-         "type": {"key": "string", "value": "integer",
-                  "min": 0, "max": "unlimited"},
-         "ephemeral": true},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}}}},
-   "NetFlow": {
-     "columns": {
-       "targets": {
-         "type": {"key": {"type": "string"},
-                  "min": 1, "max": "unlimited"}},
-       "engine_type": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 255},
-                  "min": 0, "max": 1}},
-       "engine_id": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 255},
-                  "min": 0, "max": 1}},
-       "add_id_to_interface": {
-         "type": "boolean"},
-       "active_timeout": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": -1}}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}}}},
-   "sFlow": {
-     "columns": {
-       "targets": {
-         "type": {"key": "string", "min": 1, "max": "unlimited"}},
-       "sampling": {
-         "type": {"key": "integer", "min": 0, "max": 1}},
-       "polling": {
-         "type": {"key": "integer", "min": 0, "max": 1}},
-       "header": {
-         "type": {"key": "integer", "min": 0, "max": 1}},
-       "agent": {
-         "type": {"key": "string", "min": 0, "max": 1}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}}}},
-   "IPFIX": {
-     "columns": {
-       "targets": {
-         "type": {"key": "string", "min": 0, "max": "unlimited"}},
-       "sampling": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 1,
-                          "maxInteger": 4294967295},
-                  "min": 0, "max": 1}},
-       "obs_domain_id": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4294967295},
-                  "min": 0, "max": 1}},
-       "obs_point_id": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4294967295},
-                  "min": 0, "max": 1}},
-       "cache_active_timeout": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4200},
-                  "min": 0, "max": 1}},
-       "cache_max_flows": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4294967295},
-                  "min": 0, "max": 1}},
-       "other_config": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}}}},
-   "Flow_Sample_Collector_Set": {
-     "columns": {
-       "id": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4294967295},
-                  "min": 1, "max": 1}},
-       "bridge": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "Bridge"},
-                  "min": 1, "max": 1}},
-       "ipfix": {
-         "type": {"key": {"type": "uuid",
-                          "refTable": "IPFIX"},
-                  "min": 0, "max": 1}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}}},
-     "isRoot": true,
-     "indexes": [["id", "bridge"]]},
-   "Controller": {
-     "columns": {
-       "target": {
-         "type": "string"},
-       "max_backoff": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 1000},
-                  "min": 0, "max": 1}},
-       "inactivity_probe": {
-         "type": {"key": "integer", "min": 0, "max": 1}},
-       "connection_mode": {
-         "type": {"key": {"type": "string",
-                  "enum": ["set", ["in-band", "out-of-band"]]},
-                  "min": 0, "max": 1}},
-       "local_ip": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1}},
-       "local_netmask": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1}},
-       "local_gateway": {
-         "type": {"key": {"type": "string"},
-                  "min": 0, "max": 1}},
-       "enable_async_messages": {
-         "type": {"key": {"type": "boolean"},
-                  "min": 0, "max": 1}},
-       "controller_rate_limit": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 100},
-                  "min": 0, "max": 1}},
-       "controller_burst_limit": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 25},
-                  "min": 0, "max": 1}},
-       "other_config": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}},
-       "is_connected": {
-         "type": "boolean",
-         "ephemeral": true},
-       "role": {
-         "type": {"key": {"type": "string",
-                          "enum": ["set", ["other", "master", "slave"]]},
-                  "min": 0, "max": 1},
-         "ephemeral": true},
-       "status": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"},
-         "ephemeral": true}}},
-   "Manager": {
-     "columns": {
-       "target": {
-         "type": "string"},
-       "max_backoff": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 1000},
-                  "min": 0, "max": 1}},
-       "inactivity_probe": {
-         "type": {"key": "integer", "min": 0, "max": 1}},
-       "connection_mode": {
-         "type": {"key": {"type": "string",
-                  "enum": ["set", ["in-band", "out-of-band"]]},
-                  "min": 0, "max": 1}},
-       "other_config": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"}},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}},
-       "is_connected": {
-         "type": "boolean",
-         "ephemeral": true},
-       "status": {
-         "type": {"key": "string", "value": "string", "min": 0, "max": "unlimited"},
-         "ephemeral": true}},
-     "indexes": [["target"]]},
-   "SSL": {
-     "columns": {
-       "private_key": {
-         "type": "string"},
-       "certificate": {
-         "type": "string"},
-       "ca_cert": {
-         "type": "string"},
-       "bootstrap_ca_cert": {
-         "type": "boolean"},
-       "external_ids": {
-         "type": {"key": "string", "value": "string",
-                  "min": 0, "max": "unlimited"}}},
-     "maxRows": 1},
-   "AutoAttach": {
-     "columns": {
-       "system_name": {
-         "type": "string"},
-       "system_description": {
-         "type": "string"},
-       "mappings": {
-         "type": {"key": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 16777215},
-                  "value": {"type": "integer",
-                          "minInteger": 0,
-                          "maxInteger": 4095},
-                  "min": 0, "max": "unlimited"}}}}}}
diff --git a/vswitchd/vswitch.xml b/vswitchd/vswitch.xml
deleted file mode 100644
index ce0dbc1..0000000
--- a/vswitchd/vswitch.xml
+++ /dev/null
@@ -1,4724 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<database name="ovs-vswitchd.conf.db" title="Open vSwitch Configuration Database">
-  <p>
-    A database with this schema holds the configuration for one Open
-    vSwitch daemon.  The top-level configuration for the daemon is the
-    <ref table="Open_vSwitch"/> table, which must have exactly one
-    record.  Records in other tables are significant only when they
-    can be reached directly or indirectly from the <ref
-    table="Open_vSwitch"/> table.  Records that are not reachable from
-    the <ref table="Open_vSwitch"/> table are automatically deleted
-    from the database, except for records in a few distinguished
-    ``root set'' tables.
-  </p>
-
-  <h2>Common Columns</h2>
-
-  <p>
-    Most tables contain two special columns, named <code>other_config</code>
-    and <code>external_ids</code>.  These columns have the same form and
-    purpose each place that they appear, so we describe them here to save space
-    later.
-  </p>
-
-  <dl>
-    <dt><code>other_config</code>: map of string-string pairs</dt>
-    <dd>
-      <p>
-        Key-value pairs for configuring rarely used features.  Supported keys,
-        along with the forms taken by their values, are documented individually
-        for each table.
-      </p>
-      <p>
-        A few tables do not have <code>other_config</code> columns because no
-        key-value pairs have yet been defined for them.
-      </p>
-    </dd>
-
-    <dt><code>external_ids</code>: map of string-string pairs</dt>
-    <dd>
-      Key-value pairs for use by external frameworks that integrate with Open
-      vSwitch, rather than by Open vSwitch itself.  System integrators should
-      either use the Open vSwitch development mailing list to coordinate on
-      common key-value definitions, or choose key names that are likely to be
-      unique.  In some cases, where key-value pairs have been defined that are
-      likely to be widely useful, they are documented individually for each
-      table.
-    </dd>
-  </dl>
-
-  <table name="Open_vSwitch" title="Open vSwitch configuration.">
-    Configuration for an Open vSwitch daemon.  There must be exactly
-    one record in the <ref table="Open_vSwitch"/> table.
-
-    <group title="Configuration">
-      <column name="bridges">
-        Set of bridges managed by the daemon.
-      </column>
-
-      <column name="ssl">
-        SSL used globally by the daemon.
-      </column>
-
-      <column name="external_ids" key="system-id">
-        A unique identifier for the Open vSwitch's physical host.
-        The form of the identifier depends on the type of the host.
-        On a Citrix XenServer, this will likely be the same as
-        <ref column="external_ids" key="xs-system-uuid"/>.
-      </column>
-
-      <column name="external_ids" key="xs-system-uuid">
-        The Citrix XenServer universally unique identifier for the physical
-        host as displayed by <code>xe host-list</code>.
-      </column>
-
-      <column name="other_config" key="stats-update-interval"
-              type='{"type": "integer", "minInteger": 5000}'>
-        <p>
-          Interval for updating statistics to the database, in milliseconds.
-          This option will affect the update of the <code>statistics</code>
-          column in the following tables: <code>Port</code>, <code>Interface
-          </code>, <code>Mirror</code>.
-        </p>
-        <p>
-          Default value is 5000 ms.
-        </p>
-        <p>
-          Getting statistics more frequently can be achieved via OpenFlow.
-        </p>
-      </column>
-
-      <column name="other_config" key="flow-restore-wait"
-              type='{"type": "boolean"}'>
-        <p>
-          When <code>ovs-vswitchd</code> starts up, it has an empty flow table
-          and therefore it handles all arriving packets in its default fashion
-          according to its configuration, by dropping them or sending them to
-          an OpenFlow controller or switching them as a standalone switch.
-          This behavior is ordinarily desirable.  However, if
-          <code>ovs-vswitchd</code> is restarting as part of a ``hot-upgrade,''
-          then this leads to a relatively long period during which packets are
-          mishandled.
-        </p>
-        <p>
-          This option allows for improvement.  When <code>ovs-vswitchd</code>
-          starts with this value set as <code>true</code>, it will neither
-          flush or expire previously set datapath flows nor will it send and
-          receive any packets to or from the datapath.  When this value is
-          later set to <code>false</code>, <code>ovs-vswitchd</code> will
-          start receiving packets from the datapath and re-setup the flows.
-        </p>
-        <p>
-          Thus, with this option, the procedure for a hot-upgrade of
-          <code>ovs-vswitchd</code> becomes roughly the following:
-        </p>
-        <ol>
-          <li>
-            Stop <code>ovs-vswitchd</code>.
-          </li>
-          <li>
-            Set <ref column="other_config" key="flow-restore-wait"/>
-            to <code>true</code>.
-          </li>
-          <li>
-            Start <code>ovs-vswitchd</code>.
-          </li>
-          <li>
-            Use <code>ovs-ofctl</code> (or some other program, such as an
-            OpenFlow controller) to restore the OpenFlow flow table
-            to the desired state.
-          </li>
-          <li>
-            Set <ref column="other_config" key="flow-restore-wait"/>
-            to <code>false</code> (or remove it entirely from the database).
-          </li>
-        </ol>
-        <p>
-          The <code>ovs-ctl</code>'s ``restart'' and ``force-reload-kmod''
-          functions use the above config option during hot upgrades.
-        </p>
-      </column>
-
-      <column name="other_config" key="flow-limit"
-              type='{"type": "integer", "minInteger": 0}'>
-        <p>
-          The maximum
-          number of flows allowed in the datapath flow table.  Internally OVS
-          will choose a flow limit which will likely be lower than this number,
-          based on real time network conditions. Tweaking this value is
-          discouraged unless you know exactly what you're doing.
-        </p>
-        <p>
-          The default is 200000.
-        </p>
-      </column>
-
-      <column name="other_config" key="max-idle"
-              type='{"type": "integer", "minInteger": 500}'>
-        <p>
-          The maximum time (in ms) that idle flows will remain cached in the
-          datapath. Internally OVS will check the validity and activity for
-          datapath flows regularly and may expire flows quicker than this
-          number, based on real time network conditions. Tweaking this
-          value is discouraged unless you know exactly what you're doing.
-        </p>
-        <p>
-          The default is 10000.
-        </p>
-      </column>
-
-      <column name="other_config" key="n-dpdk-rxqs"
-              type='{"type": "integer", "minInteger": 1}'>
-        <p>
-          Specifies the maximum number of rx queues to be created for each dpdk
-          interface.  If not specified or specified to 0, one rx queue will
-          be created for each dpdk interface by default.
-        </p>
-      </column>
-
-      <column name="other_config" key="pmd-cpu-mask">
-        <p>
-          Specifies CPU mask for setting the cpu affinity of PMD (Poll
-          Mode Driver) threads.  Value should be in the form of hex string,
-          similar to the dpdk EAL '-c COREMASK' option input or the 'taskset'
-          mask input.
-        </p>
-        <p>
-          The lowest order bit corresponds to the first CPU core.  A set bit
-          means the corresponding core is available and a pmd thread will be
-          created and pinned to it.  If the input does not cover all cores,
-          those uncovered cores are considered not set.
-        </p>
-        <p>
-          If not specified, one pmd thread will be created for each numa node
-          and pinned to any available core on the numa node by default.
-        </p>
-      </column>
-
-      <column name="other_config" key="n-handler-threads"
-              type='{"type": "integer", "minInteger": 1}'>
-        <p>
-          Specifies the number of threads for software datapaths to use for
-          handling new flows.  The default the number of online CPU cores minus
-          the number of revalidators.
-        </p>
-        <p>
-          This configuration is per datapath.  If you have more than one
-          software datapath (e.g. some <code>system</code> bridges and some
-          <code>netdev</code> bridges), then the total number of threads is
-          <code>n-handler-threads</code> times the number of software
-          datapaths.
-        </p>
-      </column>
-
-      <column name="other_config" key="n-revalidator-threads"
-              type='{"type": "integer", "minInteger": 1}'>
-        <p>
-          Specifies the number of threads for software datapaths to use for
-          revalidating flows in the datapath.  Typically, there is a direct
-          correlation between the number of revalidator threads, and the number
-          of flows allowed in the datapath.  The default is the number of cpu
-          cores divided by four plus one.  If <code>n-handler-threads</code> is
-          set, the default changes to the number of cpu cores minus the number
-          of handler threads.
-        </p>
-        <p>
-          This configuration is per datapath.  If you have more than one
-          software datapath (e.g. some <code>system</code> bridges and some
-          <code>netdev</code> bridges), then the total number of threads is
-          <code>n-handler-threads</code> times the number of software
-          datapaths.
-        </p>
-      </column>
-    </group>
-
-    <group title="Status">
-      <column name="next_cfg">
-        Sequence number for client to increment.  When a client modifies
-        any part of the database configuration and wishes to wait for
-        Open vSwitch to finish applying the changes, it may increment
-        this sequence number.
-      </column>
-
-      <column name="cur_cfg">
-        Sequence number that Open vSwitch sets to the current value of
-        <ref column="next_cfg"/> after it finishes applying a set of
-        configuration changes.
-      </column>
-
-      <group title="Statistics">
-        <p>
-          The <code>statistics</code> column contains key-value pairs that
-          report statistics about a system running an Open vSwitch.  These are
-          updated periodically (currently, every 5 seconds).  Key-value pairs
-          that cannot be determined or that do not apply to a platform are
-          omitted.
-        </p>
-
-        <column name="other_config" key="enable-statistics"
-                type='{"type": "boolean"}'>
-          Statistics are disabled by default to avoid overhead in the common
-          case when statistics gathering is not useful.  Set this value to
-          <code>true</code> to enable populating the <ref column="statistics"/>
-          column or to <code>false</code> to explicitly disable it.
-        </column>
-
-        <column name="statistics" key="cpu"
-                type='{"type": "integer", "minInteger": 1}'>
-          <p>
-            Number of CPU processors, threads, or cores currently online and
-            available to the operating system on which Open vSwitch is running,
-            as an integer.  This may be less than the number installed, if some
-            are not online or if they are not available to the operating
-            system.
-          </p>
-          <p>
-            Open vSwitch userspace processes are not multithreaded, but the
-            Linux kernel-based datapath is.
-          </p>
-        </column>
-
-        <column name="statistics" key="load_average">
-          A comma-separated list of three floating-point numbers,
-          representing the system load average over the last 1, 5, and 15
-          minutes, respectively.
-        </column>
-
-        <column name="statistics" key="memory">
-          <p>
-            A comma-separated list of integers, each of which represents a
-            quantity of memory in kilobytes that describes the operating
-            system on which Open vSwitch is running.  In respective order,
-            these values are:
-          </p>
-
-          <ol>
-            <li>Total amount of RAM allocated to the OS.</li>
-            <li>RAM allocated to the OS that is in use.</li>
-            <li>RAM that can be flushed out to disk or otherwise discarded
-            if that space is needed for another purpose.  This number is
-            necessarily less than or equal to the previous value.</li>
-            <li>Total disk space allocated for swap.</li>
-            <li>Swap space currently in use.</li>
-          </ol>
-
-          <p>
-            On Linux, all five values can be determined and are included.  On
-            other operating systems, only the first two values can be
-            determined, so the list will only have two values.
-          </p>
-        </column>
-
-        <column name="statistics" key="process_NAME">
-          <p>
-            One such key-value pair, with <code>NAME</code> replaced by
-            a process name, will exist for each running Open vSwitch
-            daemon process, with <var>name</var> replaced by the
-            daemon's name (e.g. <code>process_ovs-vswitchd</code>).  The
-            value is a comma-separated list of integers.  The integers
-            represent the following, with memory measured in kilobytes
-            and durations in milliseconds:
-          </p>
-
-          <ol>
-            <li>The process's virtual memory size.</li>
-            <li>The process's resident set size.</li>
-            <li>The amount of user and system CPU time consumed by the
-            process.</li>
-            <li>The number of times that the process has crashed and been
-            automatically restarted by the monitor.</li>
-            <li>The duration since the process was started.</li>
-            <li>The duration for which the process has been running.</li>
-          </ol>
-
-          <p>
-            The interpretation of some of these values depends on whether the
-            process was started with the <option>--monitor</option>.  If it
-            was not, then the crash count will always be 0 and the two
-            durations will always be the same.  If <option>--monitor</option>
-            was given, then the crash count may be positive; if it is, the
-            latter duration is the amount of time since the most recent crash
-            and restart.
-          </p>
-
-          <p>
-            There will be one key-value pair for each file in Open vSwitch's
-            ``run directory'' (usually <code>/var/run/openvswitch</code>)
-            whose name ends in <code>.pid</code>, whose contents are a
-            process ID, and which is locked by a running process.  The
-            <var>name</var> is taken from the pidfile's name.
-          </p>
-
-          <p>
-            Currently Open vSwitch is only able to obtain all of the above
-            detail on Linux systems.  On other systems, the same key-value
-            pairs will be present but the values will always be the empty
-            string.
-          </p>
-        </column>
-
-        <column name="statistics" key="file_systems">
-          <p>
-            A space-separated list of information on local, writable file
-            systems.  Each item in the list describes one file system and
-            consists in turn of a comma-separated list of the following:
-          </p>
-
-          <ol>
-            <li>Mount point, e.g. <code>/</code> or <code>/var/log</code>.
-            Any spaces or commas in the mount point are replaced by
-            underscores.</li>
-            <li>Total size, in kilobytes, as an integer.</li>
-            <li>Amount of storage in use, in kilobytes, as an integer.</li>
-          </ol>
-
-          <p>
-            This key-value pair is omitted if there are no local, writable
-            file systems or if Open vSwitch cannot obtain the needed
-            information.
-          </p>
-        </column>
-      </group>
-    </group>
-
-    <group title="Version Reporting">
-      <p>
-        These columns report the types and versions of the hardware and
-        software running Open vSwitch.  We recommend in general that software
-        should test whether specific features are supported instead of relying
-        on version number checks.  These values are primarily intended for
-        reporting to human administrators.
-      </p>
-
-      <column name="ovs_version">
-        The Open vSwitch version number, e.g. <code>1.1.0</code>.
-      </column>
-
-      <column name="db_version">
-        <p>
-          The database schema version number in the form
-          <code><var>major</var>.<var>minor</var>.<var>tweak</var></code>,
-          e.g. <code>1.2.3</code>.  Whenever the database schema is changed in
-          a non-backward compatible way (e.g. deleting a column or a table),
-          <var>major</var> is incremented.  When the database schema is changed
-          in a backward compatible way (e.g. adding a new column),
-          <var>minor</var> is incremented.  When the database schema is changed
-          cosmetically (e.g. reindenting its syntax), <var>tweak</var> is
-          incremented.
-        </p>
-
-        <p>
-          The schema version is part of the database schema, so it can also be
-          retrieved by fetching the schema using the Open vSwitch database
-          protocol.
-        </p>
-      </column>
-
-      <column name="system_type">
-        <p>
-          An identifier for the type of system on top of which Open vSwitch
-          runs, e.g. <code>XenServer</code> or <code>KVM</code>.
-        </p>
-        <p>
-          System integrators are responsible for choosing and setting an
-          appropriate value for this column.
-        </p>
-      </column>
-
-      <column name="system_version">
-        <p>
-          The version of the system identified by <ref column="system_type"/>,
-          e.g. <code>5.6.100-39265p</code> on XenServer 5.6.100 build 39265.
-        </p>
-        <p>
-          System integrators are responsible for choosing and setting an
-          appropriate value for this column.
-        </p>
-      </column>
-
-    </group>
-
-    <group title="Capabilities">
-      <p>
-        These columns report capabilities of the Open vSwitch instance.
-      </p>
-      <column name="datapath_types">
-        <p>
-          This column reports the different dpifs registered with the system.
-          These are the values that this instance supports in the <ref
-          column="datapath_type" table="Bridge"/> column of the <ref
-          table="Bridge"/> table.
-        </p>
-      </column>
-      <column name="iface_types">
-        <p>
-          This column reports the different netdevs registered with the system.
-          These are the values that this instance supports in the <ref
-          column="type" table="Interface"/> column of the <ref
-          table="Interface"/> table.
-        </p>
-      </column>
-    </group>
-
-    <group title="Database Configuration">
-      <p>
-        These columns primarily configure the Open vSwitch database
-        (<code>ovsdb-server</code>), not the Open vSwitch switch
-        (<code>ovs-vswitchd</code>).  The OVSDB database also uses the <ref
-        column="ssl"/> settings.
-      </p>
-
-      <p>
-        The Open vSwitch switch does read the database configuration to
-        determine remote IP addresses to which in-band control should apply.
-      </p>
-
-      <column name="manager_options">
-        Database clients to which the Open vSwitch database server should
-        connect or to which it should listen, along with options for how these
-        connection should be configured.  See the <ref table="Manager"/> table
-        for more information.
-      </column>
-    </group>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="other_config"/>
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="Bridge">
-    <p>
-      Configuration for a bridge within an
-      <ref table="Open_vSwitch"/>.
-    </p>
-    <p>
-      A <ref table="Bridge"/> record represents an Ethernet switch with one or
-      more ``ports,'' which are the <ref table="Port"/> records pointed to by
-      the <ref table="Bridge"/>'s <ref column="ports"/> column.
-    </p>
-
-    <group title="Core Features">
-      <column name="name">
-        Bridge identifier.  Should be alphanumeric and no more than about 8
-        bytes long.  Must be unique among the names of ports, interfaces, and
-        bridges on a host.
-      </column>
-
-      <column name="ports">
-        Ports included in the bridge.
-      </column>
-
-      <column name="mirrors">
-        Port mirroring configuration.
-      </column>
-
-      <column name="netflow">
-        NetFlow configuration.
-      </column>
-
-      <column name="sflow">
-        sFlow(R) configuration.
-      </column>
-
-      <column name="ipfix">
-        IPFIX configuration.
-      </column>
-
-      <column name="flood_vlans">
-        <p>
-          VLAN IDs of VLANs on which MAC address learning should be disabled,
-          so that packets are flooded instead of being sent to specific ports
-          that are believed to contain packets' destination MACs.  This should
-          ordinarily be used to disable MAC learning on VLANs used for
-          mirroring (RSPAN VLANs).  It may also be useful for debugging.
-        </p>
-        <p>
-          SLB bonding (see the <ref table="Port" column="bond_mode"/> column in
-          the <ref table="Port"/> table) is incompatible with
-          <code>flood_vlans</code>.  Consider using another bonding mode or
-          a different type of mirror instead.
-        </p>
-      </column>
-
-      <column name="auto_attach">
-        Auto Attach configuration.
-      </column>
-    </group>
-
-    <group title="OpenFlow Configuration">
-      <column name="controller">
-        <p>
-          OpenFlow controller set.  If unset, then no OpenFlow controllers
-          will be used.
-        </p>
-
-        <p>
-          If there are primary controllers, removing all of them clears the
-          flow table.  If there are no primary controllers, adding one also
-          clears the flow table.  Other changes to the set of controllers, such
-          as adding or removing a service controller, adding another primary
-          controller to supplement an existing primary controller, or removing
-          only one of two primary controllers, have no effect on the flow
-          table.
-        </p>
-      </column>
-
-      <column name="flow_tables">
-        Configuration for OpenFlow tables.  Each pair maps from an OpenFlow
-        table ID to configuration for that table.
-      </column>
-
-      <column name="fail_mode">
-        <p>When a controller is configured, it is, ordinarily, responsible
-        for setting up all flows on the switch.  Thus, if the connection to
-        the controller fails, no new network connections can be set up.
-        If the connection to the controller stays down long enough,
-        no packets can pass through the switch at all.  This setting
-        determines the switch's response to such a situation.  It may be set
-        to one of the following:
-        <dl>
-          <dt><code>standalone</code></dt>
-          <dd>If no message is received from the controller for three
-          times the inactivity probe interval
-          (see <ref column="inactivity_probe"/>), then Open vSwitch
-          will take over responsibility for setting up flows.  In
-          this mode, Open vSwitch causes the bridge to act like an
-          ordinary MAC-learning switch.  Open vSwitch will continue
-          to retry connecting to the controller in the background
-          and, when the connection succeeds, it will discontinue its
-          standalone behavior.</dd>
-          <dt><code>secure</code></dt>
-          <dd>Open vSwitch will not set up flows on its own when the
-          controller connection fails or when no controllers are
-          defined.  The bridge will continue to retry connecting to
-          any defined controllers forever.</dd>
-        </dl>
-        </p>
-        <p>
-          The default is <code>standalone</code> if the value is unset, but
-          future versions of Open vSwitch may change the default.
-        </p>
-        <p>
-          The <code>standalone</code> mode can create forwarding loops on a
-          bridge that has more than one uplink port unless STP is enabled.  To
-          avoid loops on such a bridge, configure <code>secure</code> mode or
-          enable STP (see <ref column="stp_enable"/>).
-        </p>
-        <p>When more than one controller is configured,
-        <ref column="fail_mode"/> is considered only when none of the
-        configured controllers can be contacted.</p>
-        <p>
-          Changing <ref column="fail_mode"/> when no primary controllers are
-          configured clears the flow table.
-        </p>
-      </column>
-
-      <column name="datapath_id">
-        Reports the OpenFlow datapath ID in use.  Exactly 16 hex digits.
-        (Setting this column has no useful effect.  Set <ref
-        column="other-config" key="datapath-id"/> instead.)
-      </column>
-
-      <column name="datapath_version">
-        <p>
-          Reports the version number of the Open vSwitch datapath in use.
-          This allows management software to detect and report discrepancies
-          between Open vSwitch userspace and datapath versions.  (The <ref
-          column="ovs_version" table="Open_vSwitch"/> column in the <ref
-          table="Open_vSwitch"/> reports the Open vSwitch userspace version.)
-          The version reported depends on the datapath in use:
-        </p>
-
-        <ul>
-          <li>
-            When the kernel module included in the Open vSwitch source tree is
-            used, this column reports the Open vSwitch version from which the
-            module was taken.
-          </li>
-
-          <li>
-            When the kernel module that is part of the upstream Linux kernel is
-            used, this column reports <code>&lt;unknown&gt;</code>.
-          </li>
-
-          <li>
-            When the datapath is built into the <code>ovs-vswitchd</code>
-            binary, this column reports <code>&lt;built-in&gt;</code>.  A
-            built-in datapath is by definition the same version as the rest of
-            the Open VSwitch userspace.
-          </li>
-
-          <li>
-            Other datapaths (such as the Hyper-V kernel datapath) currently
-            report <code>&lt;unknown&gt;</code>.
-          </li>
-        </ul>
-
-        <p>
-          A version discrepancy between <code>ovs-vswitchd</code> and the
-          datapath in use is not normally cause for alarm.  The Open vSwitch
-          kernel datapaths for Linux and Hyper-V, in particular, are designed
-          for maximum inter-version compatibility: any userspace version works
-          with with any kernel version.  Some reasons do exist to insist on
-          particular user/kernel pairings.  First, newer kernel versions add
-          new features, that can only be used by new-enough userspace, e.g.
-          VXLAN tunneling requires certain minimal userspace and kernel
-          versions.  Second, as an extension to the first reason, some newer
-          kernel versions add new features for enhancing performance that only
-          new-enough userspace versions can take advantage of.
-        </p>
-      </column>
-
-      <column name="other_config" key="datapath-id">
-        Exactly 16 hex digits to set the OpenFlow datapath ID to a specific
-        value.  May not be all-zero.
-      </column>
-
-      <column name="other_config" key="dp-desc">
-        Human readable description of datapath.  It it a maximum 256
-        byte-long free-form string to describe the datapath for
-        debugging purposes, e.g. <code>switch3 in room 3120</code>.
-      </column>
-
-      <column name="other_config" key="disable-in-band"
-              type='{"type": "boolean"}'>
-        If set to <code>true</code>, disable in-band control on the bridge
-        regardless of controller and manager settings.
-      </column>
-
-      <column name="other_config" key="in-band-queue"
-              type='{"type": "integer", "minInteger": 0, "maxInteger": 4294967295}'>
-        A queue ID as a nonnegative integer.  This sets the OpenFlow queue ID
-        that will be used by flows set up by in-band control on this bridge.
-        If unset, or if the port used by an in-band control flow does not have
-        QoS configured, or if the port does not have a queue with the specified
-        ID, the default queue is used instead.
-      </column>
-
-      <column name="protocols">
-        <p>
-          List of OpenFlow protocols that may be used when negotiating
-          a connection with a controller.  OpenFlow 1.0, 1.1, 1.2, and
-          1.3 are enabled by default if this column is empty.
-        </p>
-
-        <p>
-          OpenFlow 1.4 is not enabled by default because its implementation is
-          missing features.
-        </p>
-
-        <p>
-          OpenFlow 1.5 has the same risks as OpenFlow 1.4, but it is even more
-          experimental because the OpenFlow 1.5 specification is still under
-          development and thus subject to change.  Pass
-          <code>--enable-of15</code> to <code>ovs-vswitchd</code> to allow
-          OpenFlow 1.5 to be enabled.
-        </p>
-      </column>
-    </group>
-
-    <group title="Spanning Tree Configuration">
-      <p>
-        The IEEE 802.1D Spanning Tree Protocol (STP) is a network protocol
-        that ensures loop-free topologies.  It allows redundant links to
-        be included in the network to provide automatic backup paths if
-        the active links fails.
-      </p>
-
-      <p>
-        These settings configure the slower-to-converge but still widely
-        supported version of Spanning Tree Protocol, sometimes known as
-        802.1D-1998.  Open vSwitch also supports the newer Rapid Spanning Tree
-        Protocol (RSTP), documented later in the section titled <code>Rapid
-        Spanning Tree Configuration</code>.
-      </p>
-
-      <group title="STP Configuration">
-        <column name="stp_enable" type='{"type": "boolean"}'>
-          <p>
-            Enable spanning tree on the bridge.  By default, STP is disabled
-            on bridges.  Bond, internal, and mirror ports are not supported
-            and will not participate in the spanning tree.
-          </p>
-
-          <p>
-            STP and RSTP are mutually exclusive.  If both are enabled, RSTP
-            will be used.
-          </p>
-        </column>
-
-        <column name="other_config" key="stp-system-id">
-          The bridge's STP identifier (the lower 48 bits of the bridge-id)
-          in the form
-          <var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>.
-          By default, the identifier is the MAC address of the bridge.
-        </column>
-
-        <column name="other_config" key="stp-priority"
-                type='{"type": "integer", "minInteger": 0, "maxInteger": 65535}'>
-          The bridge's relative priority value for determining the root
-          bridge (the upper 16 bits of the bridge-id).  A bridge with the
-          lowest bridge-id is elected the root.  By default, the priority
-          is 0x8000.
-        </column>
-
-        <column name="other_config" key="stp-hello-time"
-                type='{"type": "integer", "minInteger": 1, "maxInteger": 10}'>
-          The interval between transmissions of hello messages by
-          designated ports, in seconds.  By default the hello interval is
-          2 seconds.
-        </column>
-
-        <column name="other_config" key="stp-max-age"
-                type='{"type": "integer", "minInteger": 6, "maxInteger": 40}'>
-          The maximum age of the information transmitted by the bridge
-          when it is the root bridge, in seconds.  By default, the maximum
-          age is 20 seconds.
-        </column>
-
-        <column name="other_config" key="stp-forward-delay"
-                type='{"type": "integer", "minInteger": 4, "maxInteger": 30}'>
-          The delay to wait between transitioning root and designated
-          ports to <code>forwarding</code>, in seconds.  By default, the
-          forwarding delay is 15 seconds.
-        </column>
-
-        <column name="other_config" key="mcast-snooping-aging-time"
-                type='{"type": "integer", "minInteger": 1}'>
-          <p>
-            The maximum number of seconds to retain a multicast snooping entry for
-            which no packets have been seen.  The default is currently 300
-            seconds (5 minutes).  The value, if specified, is forced into a
-            reasonable range, currently 15 to 3600 seconds.
-          </p>
-        </column>
-
-        <column name="other_config" key="mcast-snooping-table-size"
-                type='{"type": "integer", "minInteger": 1}'>
-          <p>
-            The maximum number of multicast snooping addresses to learn.  The
-            default is currently 2048.  The value, if specified, is forced into
-            a reasonable range, currently 10 to 1,000,000.
-          </p>
-        </column>
-        <column name="other_config" key="mcast-snooping-disable-flood-unregistered"
-                type='{"type": "boolean"}'>
-          <p>
-            If set to <code>false</code>, unregistered multicast packets are forwarded
-            to all ports.
-            If set to <code>true</code>, unregistered multicast packets are forwarded
-            to ports connected to multicast routers.
-          </p>
-        </column>
-      </group>
-
-      <group title="STP Status">
-        <p>
-          These key-value pairs report the status of 802.1D-1998.  They are
-          present only if STP is enabled (via the <ref column="stp_enable"/>
-          column).
-        </p>
-        <column name="status" key="stp_bridge_id">
-          The bridge ID used in spanning tree advertisements, in the form
-          <var>xxxx</var>.<var>yyyyyyyyyyyy</var> where the <var>x</var>s are
-          the STP priority, the <var>y</var>s are the STP system ID, and each
-          <var>x</var> and <var>y</var> is a hex digit.
-        </column>
-        <column name="status" key="stp_designated_root">
-          The designated root for this spanning tree, in the same form as <ref
-          column="status" key="stp_bridge_id"/>.  If this bridge is the root,
-          this will have the same value as <ref column="status"
-          key="stp_bridge_id"/>, otherwise it will differ.
-        </column>
-        <column name="status" key="stp_root_path_cost">
-          The path cost of reaching the designated bridge.  A lower number is
-          better.  The value is 0 if this bridge is the root, otherwise it is
-          higher.
-        </column>
-      </group>
-    </group>
-
-    <group title="Rapid Spanning Tree">
-      <p>
-        Rapid Spanning Tree Protocol (RSTP), like STP, is a network protocol
-        that ensures loop-free topologies.  RSTP superseded STP with the
-        publication of 802.1D-2004.  Compared to STP, RSTP converges more
-        quickly and recovers more quickly from failures.
-      </p>
-
-      <group title="RSTP Configuration">
-        <column name="rstp_enable" type='{"type": "boolean"}'>
-          <p>
-            Enable Rapid Spanning Tree on the bridge.  By default, RSTP is disabled
-            on bridges.  Bond, internal, and mirror ports are not supported
-            and will not participate in the spanning tree.
-          </p>
-
-          <p>
-            STP and RSTP are mutually exclusive.  If both are enabled, RSTP
-            will be used.
-          </p>
-        </column>
-
-        <column name="other_config" key="rstp-address">
-          The bridge's RSTP address (the lower 48 bits of the bridge-id)
-          in the form
-          <var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>.
-          By default, the address is the MAC address of the bridge.
-        </column>
-
-        <column name="other_config" key="rstp-priority"
-                type='{"type": "integer", "minInteger": 0, "maxInteger": 61440}'>
-          The bridge's relative priority value for determining the root
-          bridge (the upper 16 bits of the bridge-id).  A bridge with the
-          lowest bridge-id is elected the root.  By default, the priority
-          is 0x8000 (32768).  This value needs to be a multiple of 4096,
-          otherwise it's rounded to the nearest inferior one.
-        </column>
-
-        <column name="other_config" key="rstp-ageing-time"
-                type='{"type": "integer", "minInteger": 10, "maxInteger": 1000000}'>
-          The Ageing Time parameter for the Bridge.  The default value
-          is 300 seconds.
-        </column>
-
-        <column name="other_config" key="rstp-force-protocol-version"
-                type='{"type": "integer"}'>
-          The Force Protocol Version parameter for the Bridge.  This
-          can take the value 0 (STP Compatibility mode) or 2
-          (the default, normal operation).
-        </column>
-
-        <column name="other_config" key="rstp-max-age"
-                type='{"type": "integer", "minInteger": 6, "maxInteger": 40}'>
-          The maximum age of the information transmitted by the Bridge
-          when it is the Root Bridge.  The default value is 20.
-        </column>
-
-        <column name="other_config" key="rstp-forward-delay"
-                type='{"type": "integer", "minInteger": 4, "maxInteger": 30}'>
-          The delay used by STP Bridges to transition Root and Designated
-          Ports to Forwarding.  The default value is 15.
-        </column>
-
-        <column name="other_config" key="rstp-transmit-hold-count"
-                type='{"type": "integer", "minInteger": 1, "maxInteger": 10}'>
-          The Transmit Hold Count used by the Port Transmit state machine
-          to limit transmission rate.  The default value is 6.
-        </column>
-      </group>
-
-      <group title="RSTP Status">
-        <p>
-          These key-value pairs report the status of 802.1D-2004.  They are
-          present only if RSTP is enabled (via the <ref column="rstp_enable"/>
-          column).
-        </p>
-        <column name="rstp_status" key="rstp_bridge_id">
-          The bridge ID used in rapid spanning tree advertisements, in the form
-          <var>x</var>.<var>yyy</var>.<var>zzzzzzzzzzzz</var> where
-          <var>x</var> is the RSTP priority, the <var>y</var>s are a locally
-          assigned system ID extension, the <var>z</var>s are the STP system
-          ID, and each <var>x</var>, <var>y</var>, or <var>z</var> is a hex
-          digit.
-        </column>
-        <column name="rstp_status" key="rstp_root_id">
-          The root of this spanning tree, in the same form as <ref
-          column="rstp_status" key="rstp_bridge_id"/>.  If this bridge is the
-          root, this will have the same value as <ref column="rstp_status"
-          key="rstp_bridge_id"/>, otherwise it will differ.
-        </column>
-        <column name="rstp_status" key="rstp_root_path_cost"
-                type='{"type": "integer", "minInteger": 0}'>
-          The path cost of reaching the root.  A lower number is better.  The
-          value is 0 if this bridge is the root, otherwise it is higher.
-        </column>
-        <column name="rstp_status" key="rstp_designated_id">
-          The RSTP designated ID, in the same form as <ref column="rstp_status"
-          key="rstp_bridge_id"/>.
-        </column>
-        <column name="rstp_status" key="rstp_designated_port_id">
-          The RSTP designated port ID, as a 4-digit hex number.
-        </column>
-        <column name="rstp_status" key="rstp_bridge_port_id">
-          The RSTP bridge port ID, as a 4-digit hex number.
-        </column>
-      </group>
-    </group>
-
-    <group title="Multicast Snooping Configuration">
-      Multicast snooping (RFC 4541) monitors the Internet Group Management
-      Protocol (IGMP) and Multicast Listener Discovery traffic between hosts
-      and multicast routers.  The switch uses what IGMP and MLD snooping
-      learns to forward multicast traffic only to interfaces that are connected
-      to interested receivers.  Currently it supports IGMPv1, IGMPv2, IGMPv3,
-      MLDv1 and MLDv2 protocols.
-
-      <column name="mcast_snooping_enable">
-        Enable multicast snooping on the bridge. For now, the default
-        is disabled.
-      </column>
-    </group>
-
-    <group title="Other Features">
-      <column name="datapath_type">
-        Name of datapath provider.  The kernel datapath has type
-        <code>system</code>.  The userspace datapath has type
-        <code>netdev</code>.  A manager may refer to the <ref
-        table="Open_vSwitch" column="datapath_types"/> column of the <ref
-        table="Open_vSwitch"/> table for a list of the types accepted by this
-        Open vSwitch instance.
-      </column>
-
-      <column name="external_ids" key="bridge-id">
-        A unique identifier of the bridge.  On Citrix XenServer this will
-        commonly be the same as
-        <ref column="external_ids" key="xs-network-uuids"/>.
-      </column>
-
-      <column name="external_ids" key="xs-network-uuids">
-        Semicolon-delimited set of universally unique identifier(s) for the
-        network with which this bridge is associated on a Citrix XenServer
-        host.  The network identifiers are RFC 4122 UUIDs as displayed by,
-        e.g., <code>xe network-list</code>.
-      </column>
-
-      <column name="other_config" key="hwaddr">
-        An Ethernet address in the form
-        <var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>
-        to set the hardware address of the local port and influence the
-        datapath ID.
-      </column>
-
-      <column name="other_config" key="forward-bpdu"
-              type='{"type": "boolean"}'>
-
-        <p>
-          Controls forwarding of BPDUs and other network control frames when
-          NORMAL action is invoked.  When this option is <code>false</code> or
-          unset, frames with reserved Ethernet addresses (see table below) will
-          not be forwarded.  When this option is <code>true</code>, such frames
-          will not be treated specially.
-        </p>
-
-        <p>
-          The above general rule has the following exceptions:
-        </p>
-
-        <ul>
-          <li>
-            If STP is enabled on the bridge (see the <ref column="stp_enable"
-            table="Bridge"/> column in the <ref table="Bridge"/> table), the
-            bridge processes all received STP packets and never passes them to
-            OpenFlow or forwards them.  This is true even if STP is disabled on
-            an individual port.
-          </li>
-
-          <li>
-            If LLDP is enabled on an interface (see the <ref column="lldp"
-            table="Interface"/> column in the <ref table="Interface"/> table),
-            the interface processes received LLDP packets and never passes them
-            to OpenFlow or forwards them.
-          </li>
-        </ul>
-
-        <p>
-          Set this option to <code>true</code> if the Open vSwitch bridge
-          connects different Ethernet networks and is not configured to
-          participate in STP.
-        </p>
-
-        <p>
-          This option affects packets with the following destination MAC
-          addresses:
-        </p>
-
-        <dl>
-          <dt><code>01:80:c2:00:00:00</code></dt>
-          <dd>IEEE 802.1D Spanning Tree Protocol (STP).</dd>
-
-          <dt><code>01:80:c2:00:00:01</code></dt>
-          <dd>IEEE Pause frame.</dd>
-
-          <dt><code>01:80:c2:00:00:0<var>x</var></code></dt>
-          <dd>Other reserved protocols.</dd>
-
-          <dt><code>00:e0:2b:00:00:00</code></dt>
-          <dd>Extreme Discovery Protocol (EDP).</dd>
-
-          <dt>
-            <code>00:e0:2b:00:00:04</code> and <code>00:e0:2b:00:00:06</code>
-          </dt>
-          <dd>Ethernet Automatic Protection Switching (EAPS).</dd>
-
-          <dt><code>01:00:0c:cc:cc:cc</code></dt>
-          <dd>
-            Cisco Discovery Protocol (CDP), VLAN Trunking Protocol (VTP),
-            Dynamic Trunking Protocol (DTP), Port Aggregation Protocol (PAgP),
-            and others.
-          </dd>
-
-          <dt><code>01:00:0c:cc:cc:cd</code></dt>
-          <dd>Cisco Shared Spanning Tree Protocol PVSTP+.</dd>
-
-          <dt><code>01:00:0c:cd:cd:cd</code></dt>
-          <dd>Cisco STP Uplink Fast.</dd>
-
-          <dt><code>01:00:0c:00:00:00</code></dt>
-          <dd>Cisco Inter Switch Link.</dd>
-
-          <dt><code>01:00:0c:cc:cc:c<var>x</var></code></dt>
-          <dd>Cisco CFM.</dd>
-        </dl>
-      </column>
-
-      <column name="other_config" key="mac-aging-time"
-              type='{"type": "integer", "minInteger": 1}'>
-        <p>
-          The maximum number of seconds to retain a MAC learning entry for
-          which no packets have been seen.  The default is currently 300
-          seconds (5 minutes).  The value, if specified, is forced into a
-          reasonable range, currently 15 to 3600 seconds.
-        </p>
-
-        <p>
-          A short MAC aging time allows a network to more quickly detect that a
-          host is no longer connected to a switch port.  However, it also makes
-          it more likely that packets will be flooded unnecessarily, when they
-          are addressed to a connected host that rarely transmits packets.  To
-          reduce the incidence of unnecessary flooding, use a MAC aging time
-          longer than the maximum interval at which a host will ordinarily
-          transmit packets.
-        </p>
-      </column>
-
-      <column name="other_config" key="mac-table-size"
-              type='{"type": "integer", "minInteger": 1}'>
-        <p>
-          The maximum number of MAC addresses to learn.  The default is
-          currently 2048.  The value, if specified, is forced into a reasonable
-          range, currently 10 to 1,000,000.
-        </p>
-      </column>
-    </group>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="other_config"/>
-      <column name="external_ids"/>
-    </group>
-  </table>
-  
-  <table name="Port" table="Port or bond configuration.">
-    <p>A port within a <ref table="Bridge"/>.</p>
-    <p>Most commonly, a port has exactly one ``interface,'' pointed to by its
-    <ref column="interfaces"/> column.  Such a port logically
-    corresponds to a port on a physical Ethernet switch.  A port
-    with more than one interface is a ``bonded port'' (see
-    <ref group="Bonding Configuration"/>).</p>
-    <p>Some properties that one might think as belonging to a port are actually
-    part of the port's <ref table="Interface"/> members.</p>
-
-    <column name="name">
-      Port name.  Should be alphanumeric and no more than about 8
-      bytes long.  May be the same as the interface name, for
-      non-bonded ports.  Must otherwise be unique among the names of
-      ports, interfaces, and bridges on a host.
-    </column>
-
-    <column name="interfaces">
-      The port's interfaces.  If there is more than one, this is a
-      bonded Port.
-    </column>
-
-    <group title="VLAN Configuration">
-      <p>Bridge ports support the following types of VLAN configuration:</p>
-      <dl>
-        <dt>trunk</dt>
-        <dd>
-          <p>
-            A trunk port carries packets on one or more specified VLANs
-            specified in the <ref column="trunks"/> column (often, on every
-            VLAN).  A packet that ingresses on a trunk port is in the VLAN
-            specified in its 802.1Q header, or VLAN 0 if the packet has no
-            802.1Q header.  A packet that egresses through a trunk port will
-            have an 802.1Q header if it has a nonzero VLAN ID.
-          </p>
-
-          <p>
-            Any packet that ingresses on a trunk port tagged with a VLAN that
-            the port does not trunk is dropped.
-          </p>
-        </dd>
-
-        <dt>access</dt>
-        <dd>
-          <p>
-            An access port carries packets on exactly one VLAN specified in the
-            <ref column="tag"/> column.  Packets egressing on an access port
-            have no 802.1Q header.
-          </p>
-
-          <p>
-            Any packet with an 802.1Q header with a nonzero VLAN ID that
-            ingresses on an access port is dropped, regardless of whether the
-            VLAN ID in the header is the access port's VLAN ID.
-          </p>
-        </dd>
-
-        <dt>native-tagged</dt>
-        <dd>
-          A native-tagged port resembles a trunk port, with the exception that
-          a packet without an 802.1Q header that ingresses on a native-tagged
-          port is in the ``native VLAN'' (specified in the <ref column="tag"/>
-          column).
-        </dd>
-
-        <dt>native-untagged</dt>
-        <dd>
-          A native-untagged port resembles a native-tagged port, with the
-          exception that a packet that egresses on a native-untagged port in
-          the native VLAN will not have an 802.1Q header.
-        </dd>
-      </dl>
-      <p>
-        A packet will only egress through bridge ports that carry the VLAN of
-        the packet, as described by the rules above.
-      </p>
-
-      <column name="vlan_mode">
-        <p>
-          The VLAN mode of the port, as described above.  When this column is
-          empty, a default mode is selected as follows:
-        </p>
-        <ul>
-          <li>
-            If <ref column="tag"/> contains a value, the port is an access
-            port.  The <ref column="trunks"/> column should be empty.
-          </li>
-          <li>
-            Otherwise, the port is a trunk port.  The <ref column="trunks"/>
-            column value is honored if it is present.
-          </li>
-        </ul>
-      </column>
-
-      <column name="tag">
-        <p>
-          For an access port, the port's implicitly tagged VLAN.  For a
-          native-tagged or native-untagged port, the port's native VLAN.  Must
-          be empty if this is a trunk port.
-        </p>
-      </column>
-
-      <column name="trunks">
-        <p>
-          For a trunk, native-tagged, or native-untagged port, the 802.1Q VLAN
-          or VLANs that this port trunks; if it is empty, then the port trunks
-          all VLANs.  Must be empty if this is an access port.
-        </p>
-        <p>
-          A native-tagged or native-untagged port always trunks its native
-          VLAN, regardless of whether <ref column="trunks"/> includes that
-          VLAN.
-        </p>
-      </column>
-
-      <column name="other_config" key="priority-tags"
-              type='{"type": "boolean"}'>
-        <p>
-          An 802.1Q header contains two important pieces of information: a VLAN
-          ID and a priority.  A frame with a zero VLAN ID, called a
-          ``priority-tagged'' frame, is supposed to be treated the same way as
-          a frame without an 802.1Q header at all (except for the priority).
-        </p>
-
-        <p>
-          However, some network elements ignore any frame that has 802.1Q
-          header at all, even when the VLAN ID is zero.  Therefore, by default
-          Open vSwitch does not output priority-tagged frames, instead omitting
-          the 802.1Q header entirely if the VLAN ID is zero.  Set this key to
-          <code>true</code> to enable priority-tagged frames on a port.
-        </p>
-
-        <p>
-          Regardless of this setting, Open vSwitch omits the 802.1Q header on
-          output if both the VLAN ID and priority would be zero.
-        </p>
-
-        <p>
-          All frames output to native-tagged ports have a nonzero VLAN ID, so
-          this setting is not meaningful on native-tagged ports.
-        </p>
-      </column>
-    </group>
-
-    <group title="Bonding Configuration">
-      <p>A port that has more than one interface is a ``bonded port.'' Bonding
-      allows for load balancing and fail-over.</p>
-
-      <p>
-        The following types of bonding will work with any kind of upstream
-        switch.  On the upstream switch, do not configure the interfaces as a
-        bond:
-      </p>
-
-      <dl>
-        <dt><code>balance-slb</code></dt>
-        <dd>
-          Balances flows among slaves based on source MAC address and output
-          VLAN, with periodic rebalancing as traffic patterns change.
-        </dd>
-
-        <dt><code>active-backup</code></dt>
-        <dd>
-          Assigns all flows to one slave, failing over to a backup slave when
-          the active slave is disabled.  This is the only bonding mode in which
-          interfaces may be plugged into different upstream switches.
-        </dd>
-      </dl>
-
-      <p>
-        The following modes require the upstream switch to support 802.3ad with
-        successful LACP negotiation. If LACP negotiation fails and
-        other-config:lacp-fallback-ab is true, then <code>active-backup</code>
-        mode is used:
-      </p>
-
-      <dl>
-        <dt><code>balance-tcp</code></dt>
-        <dd>
-          Balances flows among slaves based on L2, L3, and L4 protocol
-          information such as destination MAC address, IP address, and TCP
-          port.
-        </dd>
-      </dl>
-
-      <p>These columns apply only to bonded ports.  Their values are
-      otherwise ignored.</p>
-
-      <column name="bond_mode">
-        <p>The type of bonding used for a bonded port.  Defaults to
-        <code>active-backup</code> if unset.
-        </p>
-      </column>
-
-      <column name="other_config" key="bond-hash-basis"
-              type='{"type": "integer"}'>
-        An integer hashed along with flows when choosing output slaves in load
-        balanced bonds.  When changed, all flows will be assigned different
-        hash values possibly causing slave selection decisions to change.  Does
-        not affect bonding modes which do not employ load balancing such as
-        <code>active-backup</code>.
-      </column>
-
-      <group title="Link Failure Detection">
-        <p>
-          An important part of link bonding is detecting that links are down so
-          that they may be disabled.  These settings determine how Open vSwitch
-          detects link failure.
-        </p>
-
-        <column name="other_config" key="bond-detect-mode"
-                type='{"type": "string", "enum": ["set", ["carrier", "miimon"]]}'>
-          The means used to detect link failures.  Defaults to
-          <code>carrier</code> which uses each interface's carrier to detect
-          failures.  When set to <code>miimon</code>, will check for failures
-          by polling each interface's MII.
-        </column>
-
-        <column name="other_config" key="bond-miimon-interval"
-                type='{"type": "integer"}'>
-          The interval, in milliseconds, between successive attempts to poll
-          each interface's MII.  Relevant only when <ref column="other_config"
-          key="bond-detect-mode"/> is <code>miimon</code>.
-        </column>
-
-        <column name="bond_updelay">
-          <p>
-            The number of milliseconds for which the link must stay up on an
-            interface before the interface is considered to be up.  Specify
-            <code>0</code> to enable the interface immediately.
-          </p>
-
-          <p>
-            This setting is honored only when at least one bonded interface is
-            already enabled.  When no interfaces are enabled, then the first
-            bond interface to come up is enabled immediately.
-          </p>
-        </column>
-
-        <column name="bond_downdelay">
-          The number of milliseconds for which the link must stay down on an
-          interface before the interface is considered to be down.  Specify
-          <code>0</code> to disable the interface immediately.
-        </column>
-      </group>
-
-      <group title="LACP Configuration">
-        <p>
-          LACP, the Link Aggregation Control Protocol, is an IEEE standard that
-          allows switches to automatically detect that they are connected by
-          multiple links and aggregate across those links.  These settings
-          control LACP behavior.
-        </p>
-
-        <column name="lacp">
-          Configures LACP on this port.  LACP allows directly connected
-          switches to negotiate which links may be bonded.  LACP may be enabled
-          on non-bonded ports for the benefit of any switches they may be
-          connected to.  <code>active</code> ports are allowed to initiate LACP
-          negotiations.  <code>passive</code> ports are allowed to participate
-          in LACP negotiations initiated by a remote switch, but not allowed to
-          initiate such negotiations themselves.  If LACP is enabled on a port
-          whose partner switch does not support LACP, the bond will be
-          disabled, unless other-config:lacp-fallback-ab is set to true.
-          Defaults to <code>off</code> if unset.
-        </column>
-
-        <column name="other_config" key="lacp-system-id">
-          The LACP system ID of this <ref table="Port"/>.  The system ID of a
-          LACP bond is used to identify itself to its partners.  Must be a
-          nonzero MAC address. Defaults to the bridge Ethernet address if
-          unset.
-        </column>
-
-        <column name="other_config" key="lacp-system-priority"
-                type='{"type": "integer", "minInteger": 1, "maxInteger": 65535}'>
-          The LACP system priority of this <ref table="Port"/>.  In LACP
-          negotiations, link status decisions are made by the system with the
-          numerically lower priority.
-        </column>
-
-        <column name="other_config" key="lacp-time"
-                type='{"type": "string", "enum": ["set", ["fast", "slow"]]}'>
-          <p>
-            The LACP timing which should be used on this <ref table="Port"/>.
-            By default <code>slow</code> is used.  When configured to be
-            <code>fast</code> LACP heartbeats are requested at a rate of once
-            per second causing connectivity problems to be detected more
-            quickly.  In <code>slow</code> mode, heartbeats are requested at a
-            rate of once every 30 seconds.
-          </p>
-        </column>
-
-        <column name="other_config" key="lacp-fallback-ab"
-                type='{"type": "boolean"}'>
-          <p>
-            Determines the behavior of openvswitch bond in LACP mode. If
-            the partner switch does not support LACP, setting this option
-            to <code>true</code> allows openvswitch to fallback to
-            active-backup. If the option is set to <code>false</code>, the
-            bond will be disabled. In both the cases, once the partner switch
-            is configured to LACP mode, the bond will use LACP.
-          </p>
-        </column>
-      </group>
-
-      <group title="Rebalancing Configuration">
-        <p>
-          These settings control behavior when a bond is in
-          <code>balance-slb</code> or <code>balance-tcp</code> mode.
-        </p>
-
-        <column name="other_config" key="bond-rebalance-interval"
-                type='{"type": "integer", "minInteger": 0, "maxInteger": 10000}'>
-          For a load balanced bonded port, the number of milliseconds between
-          successive attempts to rebalance the bond, that is, to move flows
-          from one interface on the bond to another in an attempt to keep usage
-          of each interface roughly equal.  If zero, load balancing is disabled
-          on the bond (link failure still cause flows to move).  If
-          less than 1000ms, the rebalance interval will be 1000ms.
-        </column>
-      </group>
-
-      <column name="bond_fake_iface">
-        For a bonded port, whether to create a fake internal interface with the
-        name of the port.  Use only for compatibility with legacy software that
-        requires this.
-      </column>
-    </group>
-
-    <group title="Spanning Tree Protocol">
-      <p>
-        The configuration here is only meaningful, and the status is only
-        populated, when 802.1D-1998 Spanning Tree Protocol is enabled on the
-        port's <ref column="Bridge"/> with its <ref column="stp_enable"/>
-        column.
-      </p>
-
-      <group title="STP Configuration">
-        <column name="other_config" key="stp-enable"
-                type='{"type": "boolean"}'>
-          When STP is enabled on a bridge, it is enabled by default on all of
-          the bridge's ports except bond, internal, and mirror ports (which do
-          not work with STP).  If this column's value is <code>false</code>,
-          STP is disabled on the port.
-        </column>
-
-        <column name="other_config" key="stp-port-num"
-                type='{"type": "integer", "minInteger": 1, "maxInteger": 255}'>
-          The port number used for the lower 8 bits of the port-id.  By
-          default, the numbers will be assigned automatically.  If any
-          port's number is manually configured on a bridge, then they
-          must all be.
-        </column>
-
-        <column name="other_config" key="stp-port-priority"
-                type='{"type": "integer", "minInteger": 0, "maxInteger": 255}'>
-          The port's relative priority value for determining the root
-          port (the upper 8 bits of the port-id).  A port with a lower
-          port-id will be chosen as the root port.  By default, the
-          priority is 0x80.
-        </column>
-
-        <column name="other_config" key="stp-path-cost"
-                type='{"type": "integer", "minInteger": 0, "maxInteger": 65535}'>
-          Spanning tree path cost for the port.  A lower number indicates
-          a faster link.  By default, the cost is based on the maximum
-          speed of the link.
-        </column>
-      </group>
-
-      <group title="STP Status">
-        <column name="status" key="stp_port_id">
-          The port ID used in spanning tree advertisements for this port, as 4
-          hex digits.  Configuring the port ID is described in the
-          <code>stp-port-num</code> and <code>stp-port-priority</code> keys of
-          the <code>other_config</code> section earlier.
-        </column>
-        <column name="status" key="stp_state"
-                type='{"type": "string", "enum": ["set",
-                      ["disabled", "listening", "learning",
-                      "forwarding", "blocking"]]}'>
-          STP state of the port.
-        </column>
-        <column name="status" key="stp_sec_in_state"
-                type='{"type": "integer", "minInteger": 0}'>
-          The amount of time this port has been in the current STP state, in
-          seconds.
-        </column>
-        <column name="status" key="stp_role"
-                type='{"type": "string", "enum": ["set",
-                      ["root", "designated", "alternate"]]}'>
-          STP role of the port.
-        </column>
-      </group>
-    </group>
-
-    <group title="Rapid Spanning Tree Protocol">
-      <p>
-        The configuration here is only meaningful, and the status and
-        statistics are only populated, when 802.1D-1998 Spanning Tree Protocol
-        is enabled on the port's <ref column="Bridge"/> with its <ref
-        column="stp_enable"/> column.
-      </p>
-
-      <group title="RSTP Configuration">
-        <column name="other_config" key="rstp-enable"
-                type='{"type": "boolean"}'>
-          When RSTP is enabled on a bridge, it is enabled by default on all of
-          the bridge's ports except bond, internal, and mirror ports (which do
-          not work with RSTP).  If this column's value is <code>false</code>,
-          RSTP is disabled on the port.
-        </column>
-
-        <column name="other_config" key="rstp-port-priority"
-                type='{"type": "integer", "minInteger": 0, "maxInteger": 240}'>
-          The port's relative priority value for determining the root port, in
-          multiples of 16.  By default, the port priority is 0x80 (128).  Any
-          value in the lower 4 bits is rounded off.  The significant upper 4
-          bits become the upper 4 bits of the port-id.  A port with the lowest
-          port-id is elected as the root.
-        </column>
-
-        <column name="other_config" key="rstp-port-num"
-                type='{"type": "integer", "minInteger": 1, "maxInteger": 4095}'>
-          The local RSTP port number, used as the lower 12 bits of the port-id.
-          By default the port numbers are assigned automatically, and typically
-          may not correspond to the OpenFlow port numbers.  A port with the
-          lowest port-id is elected as the root.
-        </column>
-
-        <column name="other_config" key="rstp-port-path-cost"
-                type='{"type": "integer"}'>
-          The port path cost.  The Port's contribution, when it is
-          the Root Port, to the Root Path Cost for the Bridge.  By default the
-          cost is automatically calculated from the port's speed.
-        </column>
-
-        <column name="other_config" key="rstp-port-admin-edge"
-                type='{"type": "boolean"}'>
-          The admin edge port parameter for the Port.  Default is
-          <code>false</code>.
-        </column>
-
-        <column name="other_config" key="rstp-port-auto-edge"
-                type='{"type": "boolean"}'>
-          The auto edge port parameter for the Port.  Default is
-          <code>true</code>.
-        </column>
-
-        <column name="other_config" key="rstp-port-mcheck"
-                type='{"type": "boolean"}'>
-          <p>
-            The mcheck port parameter for the Port.  Default is
-            <code>false</code>.  May be set to force the Port Protocol
-            Migration state machine to transmit RST BPDUs for a
-            MigrateTime period, to test whether all STP Bridges on the
-            attached LAN have been removed and the Port can continue to
-            transmit RSTP BPDUs.  Setting mcheck has no effect if the
-            Bridge is operating in STP Compatibility mode.
-          </p>
-          <p>
-            Changing the value from <code>true</code> to
-            <code>false</code> has no effect, but needs to be done if
-            this behavior is to be triggered again by subsequently
-            changing the value from <code>false</code> to
-            <code>true</code>.
-          </p>
-        </column>
-      </group>
-
-      <group title="RSTP Status">
-        <column name="rstp_status" key="rstp_port_id">
-          The port ID used in spanning tree advertisements for this port, as 4
-          hex digits.  Configuring the port ID is described in the
-          <code>rstp-port-num</code> and <code>rstp-port-priority</code> keys
-          of the <code>other_config</code> section earlier.
-        </column>
-        <column name="rstp_status" key="rstp_port_role"
-                type='{"type": "string", "enum": ["set",
-                      ["Root", "Designated", "Alternate", "Backup", "Disabled"]]}'>
-          RSTP role of the port.
-        </column>
-        <column name="rstp_status" key="rstp_port_state"
-                type='{"type": "string", "enum": ["set",
-                      ["Disabled", "Learning", "Forwarding", "Discarding"]]}'>
-          RSTP state of the port.
-        </column>
-        <column name="rstp_status" key="rstp_designated_bridge_id">
-          The port's RSTP designated bridge ID, in the same form as <ref
-          column="rstp_status" key="rstp_bridge_id"/> in the <ref
-          table="Bridge"/> table.
-        </column>
-        <column name="rstp_status" key="rstp_designated_port_id">
-          The port's RSTP designated port ID, as 4 hex digits.
-        </column>
-        <column name="rstp_status" key="rstp_designated_path_cost"
-                type='{"type": "integer"}'>
-          The port's RSTP designated path cost.  Lower is better.
-        </column>
-      </group>
-
-      <group title="RSTP Statistics">
-        <column name="rstp_statistics" key="rstp_tx_count">
-          Number of RSTP BPDUs transmitted through this port.
-        </column>
-        <column name="rstp_statistics" key="rstp_rx_count">
-          Number of valid RSTP BPDUs received by this port.
-        </column>
-        <column name="rstp_statistics" key="rstp_error_count">
-          Number of invalid RSTP BPDUs received by this port.
-        </column>
-        <column name="rstp_statistics" key="rstp_uptime">
-          The duration covered by the other RSTP statistics, in seconds.
-        </column>
-      </group>
-    </group>
-
-    <group title="Multicast Snooping">
-      <column name="other_config" key="mcast-snooping-flood"
-              type='{"type": "boolean"}'>
-        <p>
-          If set to <code>true</code>, multicast packets (except Reports) are
-          unconditionally forwarded to the specific port.
-        </p>
-      </column>
-      <column name="other_config" key="mcast-snooping-flood-reports"
-              type='{"type": "boolean"}'>
-        <p>
-          If set to <code>true</code>, multicast Reports are unconditionally
-          forwarded to the specific port.
-        </p>
-      </column>
-    </group>
-
-    <group title="Other Features">
-      <column name="qos">
-        Quality of Service configuration for this port.
-      </column>
-
-      <column name="mac">
-        The MAC address to use for this port for the purpose of choosing the
-        bridge's MAC address.  This column does not necessarily reflect the
-        port's actual MAC address, nor will setting it change the port's actual
-        MAC address.
-      </column>
-
-      <column name="fake_bridge">
-        Does this port represent a sub-bridge for its tagged VLAN within the
-        Bridge?  See ovs-vsctl(8) for more information.
-      </column>
-
-      <column name="external_ids" key="fake-bridge-id-*">
-        External IDs for a fake bridge (see the <ref column="fake_bridge"/>
-        column) are defined by prefixing a <ref table="Bridge"/> <ref
-        table="Bridge" column="external_ids"/> key with
-        <code>fake-bridge-</code>,
-        e.g. <code>fake-bridge-xs-network-uuids</code>.
-      </column>
-
-      <column name="other_config" key="transient"
-              type='{"type": "boolean"}'>
-        <p>
-          If set to <code>true</code>, the port will be removed when
-          <code>ovs-ctl start --delete-transient-ports</code> is used.
-        </p>
-      </column>
-    </group>
-
-    <column name="bond_active_slave">
-      For a bonded port, record the mac address of the current active slave.
-    </column>
-
-    <group title="Port Statistics">
-      <p>
-        Key-value pairs that report port statistics.  The update period
-        is controlled by <ref column="other_config"
-        key="stats-update-interval"/> in the <code>Open_vSwitch</code> table.
-      </p>
-      <group title="Statistics: STP transmit and receive counters">
-        <column name="statistics" key="stp_tx_count">
-          Number of STP BPDUs sent on this port by the spanning
-          tree library.
-        </column>
-        <column name="statistics" key="stp_rx_count">
-          Number of STP BPDUs received on this port and accepted by the
-          spanning tree library.
-        </column>
-        <column name="statistics" key="stp_error_count">
-          Number of bad STP BPDUs received on this port.  Bad BPDUs
-          include runt packets and those with an unexpected protocol ID.
-        </column>
-      </group>
-    </group>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="other_config"/>
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="Interface" title="One physical network device in a Port.">
-    An interface within a <ref table="Port"/>.
-
-    <group title="Core Features">
-      <column name="name">
-        Interface name.  Should be alphanumeric and no more than about 8 bytes
-        long.  May be the same as the port name, for non-bonded ports.  Must
-        otherwise be unique among the names of ports, interfaces, and bridges
-        on a host.
-      </column>
-
-      <column name="ifindex">
-        A positive interface index as defined for SNMP MIB-II in RFCs 1213 and
-        2863, if the interface has one, otherwise 0.  The ifindex is useful for
-        seamless integration with protocols such as SNMP and sFlow.
-      </column>
-
-      <column name="mac_in_use">
-        The MAC address in use by this interface.
-      </column>
-
-      <column name="mac">
-        <p>Ethernet address to set for this interface.  If unset then the
-        default MAC address is used:</p>
-        <ul>
-          <li>For the local interface, the default is the lowest-numbered MAC
-          address among the other bridge ports, either the value of the
-          <ref table="Port" column="mac"/> in its <ref table="Port"/> record,
-          if set, or its actual MAC (for bonded ports, the MAC of its slave
-          whose name is first in alphabetical order).  Internal ports and
-          bridge ports that are used as port mirroring destinations (see the
-          <ref table="Mirror"/> table) are ignored.</li>
-          <li>For other internal interfaces, the default MAC is randomly
-          generated.</li>
-          <li>External interfaces typically have a MAC address associated with
-          their hardware.</li>
-        </ul>
-        <p>Some interfaces may not have a software-controllable MAC
-        address.</p>
-      </column>
-
-      <column name="error">
-        If the configuration of the port failed, as indicated by -1 in <ref
-        column="ofport"/>, Open vSwitch sets this column to an error
-        description in human readable form.  Otherwise, Open vSwitch clears
-        this column.
-      </column>
-
-      <group title="OpenFlow Port Number">
-        <p>
-          When a client adds a new interface, Open vSwitch chooses an OpenFlow
-          port number for the new port.  If the client that adds the port fills
-          in <ref column="ofport_request"/>, then Open vSwitch tries to use its
-          value as the OpenFlow port number.  Otherwise, or if the requested
-          port number is already in use or cannot be used for another reason,
-          Open vSwitch automatically assigns a free port number.  Regardless of
-          how the port number was obtained, Open vSwitch then reports in <ref
-          column="ofport"/> the port number actually assigned.
-        </p>
-
-        <p>
-          Open vSwitch limits the port numbers that it automatically assigns to
-          the range 1 through 32,767, inclusive.  Controllers therefore have
-          free use of ports 32,768 and up.
-        </p>
-
-        <column name="ofport">
-          <p>
-            OpenFlow port number for this interface.  Open vSwitch sets this
-            column's value, so other clients should treat it as read-only.
-          </p>
-          <p>
-            The OpenFlow ``local'' port (<code>OFPP_LOCAL</code>) is 65,534.
-            The other valid port numbers are in the range 1 to 65,279,
-            inclusive.  Value -1 indicates an error adding the interface.
-          </p>
-        </column>
-
-        <column name="ofport_request"
-                type='{"type": "integer", "minInteger": 1, "maxInteger": 65279}'>
-          <p>
-            Requested OpenFlow port number for this interface.
-          </p>
-
-          <p>
-            A client should ideally set this column's value in the same
-            database transaction that it uses to create the interface.  Open
-            vSwitch version 2.1 and later will honor a later request for a
-            specific port number, althuogh it might confuse some controllers:
-            OpenFlow does not have a way to announce a port number change, so
-            Open vSwitch represents it over OpenFlow as a port deletion
-            followed immediately by a port addition.
-          </p>
-
-          <p>
-            If <ref column="ofport_request"/> is set or changed to some other
-            port's automatically assigned port number, Open vSwitch chooses a
-            new port number for the latter port.
-          </p>
-        </column>
-      </group>
-    </group>
-
-    <group title="System-Specific Details">
-      <column name="type">
-        <p>
-          The interface type.  The types supported by a particular instance of
-          Open vSwitch are listed in the <ref table="Open_vSwitch"
-          column="iface_types"/> column in the <ref table="Open_vSwitch"/>
-          table.  The following types are defined:
-        </p>
-
-        <dl>
-          <dt><code>system</code></dt>
-          <dd>An ordinary network device, e.g. <code>eth0</code> on Linux.
-          Sometimes referred to as ``external interfaces'' since they are
-          generally connected to hardware external to that on which the Open
-          vSwitch is running.  The empty string is a synonym for
-          <code>system</code>.</dd>
-
-          <dt><code>internal</code></dt>
-          <dd>A simulated network device that sends and receives traffic.  An
-          internal interface whose <ref column="name"/> is the same as its
-          bridge's <ref table="Open_vSwitch" column="name"/> is called the
-          ``local interface.''  It does not make sense to bond an internal
-          interface, so the terms ``port'' and ``interface'' are often used
-          imprecisely for internal interfaces.</dd>
-
-          <dt><code>tap</code></dt>
-          <dd>A TUN/TAP device managed by Open vSwitch.</dd>
-
-          <dt><code>geneve</code></dt>
-          <dd>
-            An Ethernet over Geneve (<code>http://tools.ietf.org/html/draft-ietf-nvo3-geneve-00</code>)
-            IPv4 tunnel.
-
-            A description of how to match and set Geneve options can be found
-            in the <code>ovs-ofctl</code> manual page.
-          </dd>
-
-          <dt><code>gre</code></dt>
-          <dd>
-            An Ethernet over RFC 2890 Generic Routing Encapsulation over IPv4
-            tunnel.
-          </dd>
-
-          <dt><code>ipsec_gre</code></dt>
-          <dd>
-            An Ethernet over RFC 2890 Generic Routing Encapsulation over IPv4
-            IPsec tunnel.
-          </dd>
-
-          <dt><code>vxlan</code></dt>
-          <dd>
-            <p>
-              An Ethernet tunnel over the UDP-based VXLAN protocol described in
-              RFC 7348.
-            </p>
-            <p>
-              Open vSwitch uses UDP destination port 4789.  The source port used for
-              VXLAN traffic varies on a per-flow basis and is in the ephemeral port
-              range.
-            </p>
-          </dd>
-
-          <dt><code>lisp</code></dt>
-          <dd>
-            <p>
-              A layer 3 tunnel over the experimental, UDP-based Locator/ID
-              Separation Protocol (RFC 6830).
-            </p>
-            <p>
-              Only IPv4 and IPv6 packets are supported by the protocol, and
-              they are sent and received without an Ethernet header.  Traffic
-              to/from LISP ports is expected to be configured explicitly, and
-              the ports are not intended to participate in learning based
-              switching.  As such, they are always excluded from packet
-              flooding.
-            </p>
-          </dd>
-
-          <dt><code>stt</code></dt>
-          <dd>
-            The Stateless TCP Tunnel (STT) is particularly useful when tunnel
-            endpoints are in end-systems, as it utilizes the capabilities of
-            standard network interface cards to improve performance.  STT utilizes
-            a TCP-like header inside the IP header. It is stateless, i.e., there is
-            no TCP connection state of any kind associated with the tunnel.  The
-            TCP-like header is used to leverage the capabilities of existing
-            network interface cards, but should not be interpreted as implying
-            any sort of connection state between endpoints.
-            Since the STT protocol does not engage in the usual TCP 3-way handshake,
-            so it will have difficulty traversing stateful firewalls.
-            The protocol is documented at
-            http://www.ietf.org/archive/id/draft-davie-stt-06.txt
-
-            All traffic uses a default destination port of 7471. STT is only
-            available in kernel datapath on kernel 3.5 or newer.
-          </dd>
-
-          <dt><code>patch</code></dt>
-          <dd>
-            A pair of virtual devices that act as a patch cable.
-          </dd>
-
-          <dt><code>null</code></dt>
-          <dd>An ignored interface. Deprecated and slated for removal in
-          February 2013.</dd>
-        </dl>
-      </column>
-    </group>
-
-    <group title="Tunnel Options">
-      <p>
-        These options apply to interfaces with <ref column="type"/> of
-        <code>geneve</code>, <code>gre</code>, <code>ipsec_gre</code>,
-        <code>vxlan</code>, <code>lisp</code> and <code>stt</code>.
-      </p>
-
-      <p>
-        Each tunnel must be uniquely identified by the combination of <ref
-        column="type"/>, <ref column="options" key="remote_ip"/>, <ref
-        column="options" key="local_ip"/>, and <ref column="options"
-        key="in_key"/>.  If two ports are defined that are the same except one
-        has an optional identifier and the other does not, the more specific
-        one is matched first.  <ref column="options" key="in_key"/> is
-        considered more specific than <ref column="options" key="local_ip"/> if
-        a port defines one and another port defines the other.
-      </p>
-
-      <column name="options" key="remote_ip">
-        <p>Required.  The remote tunnel endpoint, one of:</p>
-
-        <ul>
-          <li>
-            An IPv4 address (not a DNS name), e.g. <code>192.168.0.123</code>.
-            Only unicast endpoints are supported.
-          </li>
-          <li>
-            The word <code>flow</code>.  The tunnel accepts packets from any
-            remote tunnel endpoint.  To process only packets from a specific
-            remote tunnel endpoint, the flow entries may match on the
-            <code>tun_src</code> field.  When sending packets to a
-            <code>remote_ip=flow</code> tunnel, the flow actions must
-            explicitly set the <code>tun_dst</code> field to the IP address of
-            the desired remote tunnel endpoint, e.g. with a
-            <code>set_field</code> action.
-          </li>
-        </ul>
-
-        <p>
-          The remote tunnel endpoint for any packet received from a tunnel
-          is available in the <code>tun_src</code> field for matching in the
-          flow table.
-        </p>
-      </column>
-
-      <column name="options" key="local_ip">
-        <p>
-          Optional.  The tunnel destination IP that received packets must
-          match.  Default is to match all addresses.  If specified, may be one
-          of:
-        </p>
-
-        <ul>
-          <li>
-            An IPv4 address (not a DNS name), e.g. <code>192.168.12.3</code>.
-          </li>
-          <li>
-            The word <code>flow</code>.  The tunnel accepts packets sent to any
-            of the local IP addresses of the system running OVS.  To process
-            only packets sent to a specific IP address, the flow entries may
-            match on the <code>tun_dst</code> field.  When sending packets to a
-            <code>local_ip=flow</code> tunnel, the flow actions may
-            explicitly set the <code>tun_src</code> field to the desired IP
-            address, e.g. with a <code>set_field</code> action.  However, while
-            routing the tunneled packet out, the local system may override the
-            specified address with the local IP address configured for the
-            outgoing system interface.
-
-            <p>
-              This option is valid only for tunnels also configured with the
-              <code>remote_ip=flow</code> option.
-            </p>
-          </li>
-        </ul>
-
-        <p>
-          The tunnel destination IP address for any packet received from a
-          tunnel is available in the <code>tun_dst</code> field for matching in
-          the flow table.
-        </p>
-      </column>
-
-      <column name="options" key="in_key">
-        <p>Optional.  The key that received packets must contain, one of:</p>
-
-        <ul>
-          <li>
-            <code>0</code>.  The tunnel receives packets with no key or with a
-            key of 0.  This is equivalent to specifying no <ref column="options"
-            key="in_key"/> at all.
-          </li>
-          <li>
-            A positive 24-bit (for Geneve, VXLAN, and LISP), 32-bit (for GRE)
-            or 64-bit (for STT) number.  The tunnel receives only
-            packets with the specified key.
-          </li>
-          <li>
-            The word <code>flow</code>.  The tunnel accepts packets with any
-            key.  The key will be placed in the <code>tun_id</code> field for
-            matching in the flow table.  The <code>ovs-ofctl</code> manual page
-            contains additional information about matching fields in OpenFlow
-            flows.
-          </li>
-        </ul>
-
-        <p>
-        </p>
-      </column>
-
-      <column name="options" key="out_key">
-        <p>Optional.  The key to be set on outgoing packets, one of:</p>
-
-        <ul>
-          <li>
-            <code>0</code>.  Packets sent through the tunnel will have no key.
-            This is equivalent to specifying no <ref column="options"
-            key="out_key"/> at all.
-          </li>
-          <li>
-            A positive 24-bit (for Geneve, VXLAN and LISP), 32-bit (for GRE) or
-            64-bit (for STT) number.  Packets sent through the tunnel
-            will have the specified key.
-          </li>
-          <li>
-            The word <code>flow</code>.  Packets sent through the tunnel will
-            have the key set using the <code>set_tunnel</code> Nicira OpenFlow
-            vendor extension (0 is used in the absence of an action).  The
-            <code>ovs-ofctl</code> manual page contains additional information
-            about the Nicira OpenFlow vendor extensions.
-          </li>
-        </ul>
-      </column>
-
-      <column name="options" key="key">
-        Optional.  Shorthand to set <code>in_key</code> and
-        <code>out_key</code> at the same time.
-      </column>
-
-      <column name="options" key="tos">
-        Optional.  The value of the ToS bits to be set on the encapsulating
-        packet.  ToS is interpreted as DSCP and ECN bits, ECN part must be
-        zero.  It may also be the word <code>inherit</code>, in which case
-        the ToS will be copied from the inner packet if it is IPv4 or IPv6
-        (otherwise it will be 0).  The ECN fields are always inherited.
-        Default is 0.
-      </column>
-
-      <column name="options" key="ttl">
-        Optional.  The TTL to be set on the encapsulating packet.  It may also
-        be the word <code>inherit</code>, in which case the TTL will be copied
-        from the inner packet if it is IPv4 or IPv6 (otherwise it will be the
-        system default, typically 64).  Default is the system default TTL.
-      </column>
-
-      <column name="options" key="df_default"
-              type='{"type": "boolean"}'>
-        Optional.  If enabled, the Don't Fragment bit will be set on tunnel
-        outer headers to allow path MTU discovery. Default is enabled; set
-        to <code>false</code> to disable.
-      </column>
-
-      <group title="Tunnel Options: vxlan only">
-
-        <column name="options" key="exts">
-          <p>Optional.  Comma separated list of optional VXLAN extensions to
-          enable. The following extensions are supported:</p>
-
-          <ul>
-            <li>
-              <code>gbp</code>: VXLAN-GBP allows to transport the group policy
-              context of a packet across the VXLAN tunnel to other network
-              peers. See the field description of <code>tun_gbp_id</code> and
-              <code>tun_gbp_flags</code> in ovs-ofctl(8) for additional
-              information.
-              (<code>https://tools.ietf.org/html/draft-smith-vxlan-group-policy</code>)
-            </li>
-          </ul>
-        </column>
-
-      </group>
-
-      <group title="Tunnel Options: gre, ipsec_gre, geneve, and vxlan">
-        <p>
-          <code>gre</code>, <code>ipsec_gre</code>, <code>geneve</code>, and
-          <code>vxlan</code> interfaces support these options.
-        </p>
-
-        <column name="options" key="csum" type='{"type": "boolean"}'>
-          <p>
-            Optional.  Compute encapsulation header (either GRE or UDP) 
-            checksums on outgoing packets.  Default is disabled, set to
-            <code>true</code> to enable.  Checksums present on incoming
-            packets will be validated regardless of this setting.
-          </p>
-
-          <p>
-            When using the upstream Linux kernel module, computation of
-            checksums for <code>geneve</code> and <code>vxlan</code> requires
-            Linux kernel version 4.0 or higher. <code>gre</code> supports
-            checksums for all versions of Open vSwitch that support GRE.
-            The out of tree kernel module distributed as part of OVS
-            can compute all tunnel checksums on any kernel version that it
-            is compatible with.
-          </p>
-
-          <p>
-            This option is supported for <code>ipsec_gre</code>, but not useful
-            because GRE checksums are weaker than, and redundant with, IPsec
-            payload authentication.
-          </p>
-        </column>
-      </group>
-
-      <group title="Tunnel Options: ipsec_gre only">
-        <p>
-          Only <code>ipsec_gre</code> interfaces support these options.
-        </p>
-
-        <column name="options" key="peer_cert">
-          Required for certificate authentication.  A string containing the
-          peer's certificate in PEM format.  Additionally the host's
-          certificate must be specified with the <code>certificate</code>
-          option.
-        </column>
-
-        <column name="options" key="certificate">
-          Required for certificate authentication.  The name of a PEM file
-          containing a certificate that will be presented to the peer during
-          authentication.
-        </column>
-
-        <column name="options" key="private_key">
-          Optional for certificate authentication.  The name of a PEM file
-          containing the private key associated with <code>certificate</code>.
-          If <code>certificate</code> contains the private key, this option may
-          be omitted.
-        </column>
-
-        <column name="options" key="psk">
-          Required for pre-shared key authentication.  Specifies a pre-shared
-          key for authentication that must be identical on both sides of the
-          tunnel.
-        </column>
-      </group>
-    </group>
-
-    <group title="Patch Options">
-      <p>
-        Only <code>patch</code> interfaces support these options.
-      </p>
-
-      <column name="options" key="peer">
-        The <ref column="name"/> of the <ref table="Interface"/> for the other
-        side of the patch.  The named <ref table="Interface"/>'s own
-        <code>peer</code> option must specify this <ref table="Interface"/>'s
-        name.  That is, the two patch interfaces must have reversed <ref
-        column="name"/> and <code>peer</code> values.
-      </column>
-    </group>
-
-    <group title="Interface Status">
-      <p>
-        Status information about interfaces attached to bridges, updated every
-        5 seconds.  Not all interfaces have all of these properties; virtual
-        interfaces don't have a link speed, for example.  Non-applicable
-        columns will have empty values.
-      </p>
-      <column name="admin_state">
-        <p>
-          The administrative state of the physical network link.
-        </p>
-      </column>
-
-      <column name="link_state">
-        <p>
-          The observed state of the physical network link.  This is ordinarily
-          the link's carrier status.  If the interface's <ref table="Port"/> is
-          a bond configured for miimon monitoring, it is instead the network
-          link's miimon status.
-        </p>
-      </column>
-
-      <column name="link_resets">
-        <p>
-          The number of times Open vSwitch has observed the
-          <ref column="link_state"/> of this <ref table="Interface"/> change.
-        </p>
-      </column>
-
-      <column name="link_speed">
-        <p>
-          The negotiated speed of the physical network link.
-          Valid values are positive integers greater than 0.
-        </p>
-      </column>
-
-      <column name="duplex">
-        <p>
-          The duplex mode of the physical network link.
-        </p>
-      </column>
-
-      <column name="mtu">
-        <p>
-          The MTU (maximum transmission unit); i.e. the largest
-          amount of data that can fit into a single Ethernet frame.
-          The standard Ethernet MTU is 1500 bytes.  Some physical media
-          and many kinds of virtual interfaces can be configured with
-          higher MTUs.
-        </p>
-        <p>
-          This column will be empty for an interface that does not
-          have an MTU as, for example, some kinds of tunnels do not.
-        </p>
-      </column>
-
-      <column name="lacp_current">
-        Boolean value indicating LACP status for this interface.  If true, this
-        interface has current LACP information about its LACP partner.  This
-        information may be used to monitor the health of interfaces in a LACP
-        enabled port.  This column will be empty if LACP is not enabled.
-      </column>
-
-      <column name="status">
-        Key-value pairs that report port status.  Supported status values are
-        <ref column="type"/>-dependent; some interfaces may not have a valid
-        <ref column="status" key="driver_name"/>, for example.
-      </column>
-
-      <column name="status" key="driver_name">
-        The name of the device driver controlling the network adapter.
-      </column>
-
-      <column name="status" key="driver_version">
-        The version string of the device driver controlling the network
-        adapter.
-      </column>
-
-      <column name="status" key="firmware_version">
-        The version string of the network adapter's firmware, if available.
-      </column>
-
-      <column name="status" key="source_ip">
-        The source IP address used for an IPv4 tunnel end-point, such as
-        <code>gre</code>.
-      </column>
-
-      <column name="status" key="tunnel_egress_iface">
-        Egress interface for tunnels.  Currently only relevant for tunnels
-        on Linux systems, this column will show the name of the interface
-        which is responsible for routing traffic destined for the configured
-        <ref column="options" key="remote_ip"/>.  This could be an internal
-        interface such as a bridge port.
-      </column>
-
-      <column name="status" key="tunnel_egress_iface_carrier"
-              type='{"type": "string", "enum": ["set", ["down", "up"]]}'>
-        Whether carrier is detected on <ref column="status"
-        key="tunnel_egress_iface"/>.
-      </column>
-    </group>
-
-    <group title="Statistics">
-      <p>
-        Key-value pairs that report interface statistics.  The current
-        implementation updates these counters periodically.  The update period
-        is controlled by <ref column="other_config"
-        key="stats-update-interval"/> in the <code>Open_vSwitch</code> table.
-        Future implementations may update them when an interface is created,
-        when they are queried (e.g. using an OVSDB <code>select</code>
-        operation), and just before an interface is deleted due to virtual
-        interface hot-unplug or VM shutdown, and perhaps at other times, but
-        not on any regular periodic basis.
-      </p>
-      <p>
-        These are the same statistics reported by OpenFlow in its <code>struct
-        ofp_port_stats</code> structure.  If an interface does not support a
-        given statistic, then that pair is omitted.
-      </p>
-      <group title="Statistics: Successful transmit and receive counters">
-        <column name="statistics" key="rx_packets">
-          Number of received packets.
-        </column>
-        <column name="statistics" key="rx_bytes">
-          Number of received bytes.
-        </column>
-        <column name="statistics" key="tx_packets">
-          Number of transmitted packets.
-        </column>
-        <column name="statistics" key="tx_bytes">
-          Number of transmitted bytes.
-        </column>
-      </group>
-      <group title="Statistics: Receive errors">
-        <column name="statistics" key="rx_dropped">
-          Number of packets dropped by RX.
-        </column>
-        <column name="statistics" key="rx_frame_err">
-          Number of frame alignment errors.
-        </column>
-        <column name="statistics" key="rx_over_err">
-          Number of packets with RX overrun.
-        </column>
-        <column name="statistics" key="rx_crc_err">
-          Number of CRC errors.
-        </column>
-        <column name="statistics" key="rx_errors">
-          Total number of receive errors, greater than or equal to the sum of
-          the above.
-        </column>
-      </group>
-      <group title="Statistics: Transmit errors">
-        <column name="statistics" key="tx_dropped">
-          Number of packets dropped by TX.
-        </column>
-        <column name="statistics" key="collisions">
-          Number of collisions.
-        </column>
-        <column name="statistics" key="tx_errors">
-          Total number of transmit errors, greater than or equal to the sum of
-          the above.
-        </column>
-      </group>
-    </group>
-
-    <group title="Ingress Policing">
-      <p>
-        These settings control ingress policing for packets received on this
-        interface.  On a physical interface, this limits the rate at which
-        traffic is allowed into the system from the outside; on a virtual
-        interface (one connected to a virtual machine), this limits the rate at
-        which the VM is able to transmit.
-      </p>
-      <p>
-        Policing is a simple form of quality-of-service that simply drops
-        packets received in excess of the configured rate.  Due to its
-        simplicity, policing is usually less accurate and less effective than
-        egress QoS (which is configured using the <ref table="QoS"/> and <ref
-        table="Queue"/> tables).
-      </p>
-      <p>
-        Policing is currently implemented only on Linux.  The Linux
-        implementation uses a simple ``token bucket'' approach:
-      </p>
-      <ul>
-        <li>
-          The size of the bucket corresponds to <ref
-          column="ingress_policing_burst"/>.  Initially the bucket is full.
-        </li>
-        <li>
-          Whenever a packet is received, its size (converted to tokens) is
-          compared to the number of tokens currently in the bucket.  If the
-          required number of tokens are available, they are removed and the
-          packet is forwarded.  Otherwise, the packet is dropped.
-        </li>
-        <li>
-          Whenever it is not full, the bucket is refilled with tokens at the
-          rate specified by <ref column="ingress_policing_rate"/>.
-        </li>
-      </ul>
-      <p>
-        Policing interacts badly with some network protocols, and especially
-        with fragmented IP packets.  Suppose that there is enough network
-        activity to keep the bucket nearly empty all the time.  Then this token
-        bucket algorithm will forward a single packet every so often, with the
-        period depending on packet size and on the configured rate.  All of the
-        fragments of an IP packets are normally transmitted back-to-back, as a
-        group.  In such a situation, therefore, only one of these fragments
-        will be forwarded and the rest will be dropped.  IP does not provide
-        any way for the intended recipient to ask for only the remaining
-        fragments.  In such a case there are two likely possibilities for what
-        will happen next: either all of the fragments will eventually be
-        retransmitted (as TCP will do), in which case the same problem will
-        recur, or the sender will not realize that its packet has been dropped
-        and data will simply be lost (as some UDP-based protocols will do).
-        Either way, it is possible that no forward progress will ever occur.
-      </p>
-      <column name="ingress_policing_rate">
-        <p>
-          Maximum rate for data received on this interface, in kbps.  Data
-          received faster than this rate is dropped.  Set to <code>0</code>
-          (the default) to disable policing.
-        </p>
-      </column>
-
-      <column name="ingress_policing_burst">
-        <p>Maximum burst size for data received on this interface, in kb.  The
-        default burst size if set to <code>0</code> is 1000 kb.  This value
-        has no effect if <ref column="ingress_policing_rate"/>
-        is <code>0</code>.</p>
-        <p>
-          Specifying a larger burst size lets the algorithm be more forgiving,
-          which is important for protocols like TCP that react severely to
-          dropped packets.  The burst size should be at least the size of the
-          interface's MTU.  Specifying a value that is numerically at least as
-          large as 10% of <ref column="ingress_policing_rate"/> helps TCP come
-          closer to achieving the full rate.
-        </p>
-      </column>
-    </group>
-
-    <group title="Bidirectional Forwarding Detection (BFD)">
-      <p>
-        BFD, defined in RFC 5880 and RFC 5881, allows point-to-point
-        detection of connectivity failures by occasional transmission of
-        BFD control messages.  Open vSwitch implements BFD to serve
-        as a more popular and standards compliant alternative to CFM.
-      </p>
-
-      <p>
-        BFD operates by regularly transmitting BFD control messages at a rate
-        negotiated independently in each direction.  Each endpoint specifies
-        the rate at which it expects to receive control messages, and the rate
-        at which it is willing to transmit them.  Open vSwitch uses a detection
-        multiplier of three, meaning that an endpoint signals a connectivity
-        fault if three consecutive BFD control messages fail to arrive.  In the
-        case of a unidirectional connectivity issue, the system not receiving
-        BFD control messages signals the problem to its peer in the messages it
-        transmits.
-      </p>
-
-      <p>
-        The Open vSwitch implementation of BFD aims to comply faithfully
-        with RFC 5880 requirements.  Open vSwitch does not implement the
-        optional Authentication or ``Echo Mode'' features.
-      </p>
-
-      <group title="BFD Configuration">
-        <p>
-          A controller sets up key-value pairs in the <ref column="bfd"/>
-          column to enable and configure BFD.
-        </p>
-
-        <column name="bfd" key="enable" type='{"type": "boolean"}'>
-          True to enable BFD on this <ref table="Interface"/>.  If not
-          specified, BFD will not be enabled by default.
-        </column>
-
-        <column name="bfd" key="min_rx"
-                type='{"type": "integer", "minInteger": 1}'>
-          The shortest interval, in milliseconds, at which this BFD session
-          offers to receive BFD control messages.  The remote endpoint may
-          choose to send messages at a slower rate.  Defaults to
-          <code>1000</code>.
-        </column>
-
-        <column name="bfd" key="min_tx"
-                type='{"type": "integer", "minInteger": 1}'>
-          The shortest interval, in milliseconds, at which this BFD session is
-          willing to transmit BFD control messages.  Messages will actually be
-          transmitted at a slower rate if the remote endpoint is not willing to
-          receive as quickly as specified.  Defaults to <code>100</code>.
-        </column>
-
-        <column name="bfd" key="decay_min_rx" type='{"type": "integer"}'>
-          An alternate receive interval, in milliseconds, that must be greater
-          than or equal to <ref column="bfd" key="min_rx"/>.  The
-          implementation switches from <ref column="bfd" key="min_rx"/> to <ref
-          column="bfd" key="decay_min_rx"/> when there is no obvious incoming
-          data traffic at the interface, to reduce the CPU and bandwidth cost
-          of monitoring an idle interface.  This feature may be disabled by
-          setting a value of 0.  This feature is reset whenever <ref
-          column="bfd" key="decay_min_rx"/> or <ref column="bfd" key="min_rx"/>
-          changes.
-        </column>
-
-        <column name="bfd" key="forwarding_if_rx" type='{"type": "boolean"}'>
-          When <code>true</code>, traffic received on the
-          <ref table="Interface"/> is used to indicate the capability of packet
-          I/O.  BFD control packets are still transmitted and received.  At
-          least one BFD control packet must be received every 100 * <ref
-          column="bfd" key="min_rx"/> amount of time.  Otherwise, even if
-          traffic are received, the <ref column="bfd" key="forwarding"/>
-          will be <code>false</code>.
-        </column>
-
-        <column name="bfd" key="cpath_down" type='{"type": "boolean"}'>
-          Set to true to notify the remote endpoint that traffic should not be
-          forwarded to this system for some reason other than a connectivty
-          failure on the interface being monitored.  The typical underlying
-          reason is ``concatenated path down,'' that is, that connectivity
-          beyond the local system is down.  Defaults to false.
-        </column>
-
-        <column name="bfd" key="check_tnl_key" type='{"type": "boolean"}'>
-          Set to true to make BFD accept only control messages with a tunnel
-          key of zero.  By default, BFD accepts control messages with any
-          tunnel key.
-        </column>
-
-        <column name="bfd" key="bfd_local_src_mac">
-          Set to an Ethernet address in the form
-          <var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>
-          to set the MAC used as source for transmitted BFD packets.  The
-          default is the mac address of the BFD enabled interface.
-        </column>
-
-        <column name="bfd" key="bfd_local_dst_mac">
-          Set to an Ethernet address in the form
-          <var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>
-          to set the MAC used as destination for transmitted BFD packets.  The
-          default is <code>00:23:20:00:00:01</code>.
-        </column>
-
-        <column name="bfd" key="bfd_remote_dst_mac">
-          Set to an Ethernet address in the form
-          <var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>
-          to set the MAC used for checking the destination of received BFD packets.
-          Packets with different destination MAC will not be considered as BFD packets.
-          If not specified the destination MAC address of received BFD packets
-          are not checked.
-        </column>
-
-        <column name="bfd" key="bfd_src_ip">
-          Set to an IPv4 address to set the IP address used as source for
-          transmitted BFD packets.  The default is <code>169.254.1.1</code>.
-        </column>
-
-        <column name="bfd" key="bfd_dst_ip">
-          Set to an IPv4 address to set the IP address used as destination
-          for transmitted BFD packets.  The default is <code>169.254.1.0</code>.
-        </column>
-      </group>
-
-      <group title="BFD Status">
-        <p>
-          The switch sets key-value pairs in the <ref column="bfd_status"/>
-          column to report the status of BFD on this interface.  When BFD is
-          not enabled, with <ref column="bfd" key="enable"/>, the switch clears
-          all key-value pairs from <ref column="bfd_status"/>.
-        </p>
-
-        <column name="bfd_status" key="state"
-                type='{"type": "string",
-                      "enum": ["set", ["admin_down", "down", "init", "up"]]}'>
-          Reports the state of the BFD session.  The BFD session is fully
-          healthy and negotiated if <code>UP</code>.
-        </column>
-
-        <column name="bfd_status" key="forwarding" type='{"type": "boolean"}'>
-          Reports whether the BFD session believes this <ref
-          table="Interface"/> may be used to forward traffic.  Typically this
-          means the local session is signaling <code>UP</code>, and the remote
-          system isn't signaling a problem such as concatenated path down.
-        </column>
-
-        <column name="bfd_status" key="diagnostic">
-          A diagnostic code specifying the local system's reason for the
-          last change in session state. The error messages are defined in
-          section 4.1 of [RFC 5880].
-        </column>
-
-        <column name="bfd_status" key="remote_state"
-                type='{"type": "string",
-                      "enum": ["set", ["admin_down", "down", "init", "up"]]}'>
-          Reports the state of the remote endpoint's BFD session.
-        </column>
-
-        <column name="bfd_status" key="remote_diagnostic">
-          A diagnostic code specifying the remote system's reason for the
-          last change in session state. The error messages are defined in
-          section 4.1 of [RFC 5880].
-        </column>
-
-        <column name="bfd_status" key="flap_count"
-                type='{"type": "integer", "minInteger": 0}'>
-          Counts the number of <ref column="bfd_status" key="forwarding" />
-          flaps since start.  A flap is considered as a change of the
-          <ref column="bfd_status" key="forwarding" /> value.
-        </column>
-      </group>
-    </group>
-
-    <group title="Connectivity Fault Management">
-      <p>
-        802.1ag Connectivity Fault Management (CFM) allows a group of
-        Maintenance Points (MPs) called a Maintenance Association (MA) to
-        detect connectivity problems with each other.  MPs within a MA should
-        have complete and exclusive interconnectivity.  This is verified by
-        occasionally broadcasting Continuity Check Messages (CCMs) at a
-        configurable transmission interval.
-      </p>
-
-      <p>
-        According to the 802.1ag specification, each Maintenance Point should
-        be configured out-of-band with a list of Remote Maintenance Points it
-        should have connectivity to.  Open vSwitch differs from the
-        specification in this area.  It simply assumes the link is faulted if
-        no Remote Maintenance Points are reachable, and considers it not
-        faulted otherwise.
-      </p>
-
-      <p>
-        When operating over tunnels which have no <code>in_key</code>, or an
-        <code>in_key</code> of <code>flow</code>.  CFM will only accept CCMs
-        with a tunnel key of zero.
-      </p>
-
-      <column name="cfm_mpid">
-        <p>
-          A Maintenance Point ID (MPID) uniquely identifies each endpoint
-          within a Maintenance Association.  The MPID is used to identify this
-          endpoint to other Maintenance Points in the MA.  Each end of a link
-          being monitored should have a different MPID.  Must be configured to
-          enable CFM on this <ref table="Interface"/>.
-        </p>
-        <p>
-          According to the 802.1ag specification, MPIDs can only range between
-          [1, 8191].  However, extended mode (see <ref column="other_config"
-          key="cfm_extended"/>) supports eight byte MPIDs.
-        </p>
-      </column>
-
-      <column name="cfm_flap_count">
-        Counts the number of cfm fault flapps since boot.  A flap is
-        considered to be a change of the <ref column="cfm_fault"/> value.
-      </column>
-
-      <column name="cfm_fault">
-        <p>
-          Indicates a connectivity fault triggered by an inability to receive
-          heartbeats from any remote endpoint.  When a fault is triggered on
-          <ref table="Interface"/>s participating in bonds, they will be
-          disabled.
-        </p>
-        <p>
-          Faults can be triggered for several reasons.  Most importantly they
-          are triggered when no CCMs are received for a period of 3.5 times the
-          transmission interval. Faults are also triggered when any CCMs
-          indicate that a Remote Maintenance Point is not receiving CCMs but
-          able to send them.  Finally, a fault is triggered if a CCM is
-          received which indicates unexpected configuration.  Notably, this
-          case arises when a CCM is received which advertises the local MPID.
-        </p>
-      </column>
-
-      <column name="cfm_fault_status" key="recv">
-        Indicates a CFM fault was triggered due to a lack of CCMs received on
-        the <ref table="Interface"/>.
-      </column>
-
-      <column name="cfm_fault_status" key="rdi">
-        Indicates a CFM fault was triggered due to the reception of a CCM with
-        the RDI bit flagged.  Endpoints set the RDI bit in their CCMs when they
-        are not receiving CCMs themselves.  This typically indicates a
-        unidirectional connectivity failure.
-      </column>
-
-      <column name="cfm_fault_status" key="maid">
-        Indicates a CFM fault was triggered due to the reception of a CCM with
-        a MAID other than the one Open vSwitch uses.  CFM broadcasts are tagged
-        with an identification number in addition to the MPID called the MAID.
-        Open vSwitch only supports receiving CCM broadcasts tagged with the
-        MAID it uses internally.
-      </column>
-
-      <column name="cfm_fault_status" key="loopback">
-        Indicates a CFM fault was triggered due to the reception of a CCM
-        advertising the same MPID configured in the <ref column="cfm_mpid"/>
-        column of this <ref table="Interface"/>.  This may indicate a loop in
-        the network.
-      </column>
-
-      <column name="cfm_fault_status" key="overflow">
-        Indicates a CFM fault was triggered because the CFM module received
-        CCMs from more remote endpoints than it can keep track of.
-      </column>
-
-      <column name="cfm_fault_status" key="override">
-        Indicates a CFM fault was manually triggered by an administrator using
-        an <code>ovs-appctl</code> command.
-      </column>
-
-      <column name="cfm_fault_status" key="interval">
-        Indicates a CFM fault was triggered due to the reception of a CCM
-        frame having an invalid interval.
-      </column>
-
-      <column name="cfm_remote_opstate">
-        <p>When in extended mode, indicates the operational state of the
-        remote endpoint as either <code>up</code> or <code>down</code>.  See
-        <ref column="other_config" key="cfm_opstate"/>.
-        </p>
-      </column>
-
-      <column name="cfm_health">
-        <p>
-          Indicates the health of the interface as a percentage of CCM frames
-          received over 21 <ref column="other_config" key="cfm_interval"/>s.
-          The health of an interface is undefined if it is communicating with
-          more than one <ref column="cfm_remote_mpids"/>.  It reduces if
-          healthy heartbeats are not received at the expected rate, and
-          gradually improves as healthy heartbeats are received at the desired
-          rate. Every 21 <ref column="other_config" key="cfm_interval"/>s, the
-          health of the interface is refreshed.
-        </p>
-        <p>
-          As mentioned above, the faults can be triggered for several reasons.
-          The link health will deteriorate even if heartbeats are received but
-          they are reported to be unhealthy.  An unhealthy heartbeat in this
-          context is a heartbeat for which either some fault is set or is out
-          of sequence.  The interface health can be 100 only on receiving
-          healthy heartbeats at the desired rate.
-        </p>
-      </column>
-
-      <column name="cfm_remote_mpids">
-        When CFM is properly configured, Open vSwitch will occasionally
-        receive CCM broadcasts.  These broadcasts contain the MPID of the
-        sending Maintenance Point.  The list of MPIDs from which this
-        <ref table="Interface"/> is receiving broadcasts from is regularly
-        collected and written to this column.
-      </column>
-
-      <column name="other_config" key="cfm_interval"
-              type='{"type": "integer"}'>
-        <p>
-          The interval, in milliseconds, between transmissions of CFM
-          heartbeats.  Three missed heartbeat receptions indicate a
-          connectivity fault.
-        </p>
-
-        <p>
-          In standard operation only intervals of 3, 10, 100, 1,000, 10,000,
-          60,000, or 600,000 ms are supported.  Other values will be rounded
-          down to the nearest value on the list.  Extended mode (see <ref
-          column="other_config" key="cfm_extended"/>) supports any interval up
-          to 65,535 ms.  In either mode, the default is 1000 ms.
-        </p>
-
-        <p>We do not recommend using intervals less than 100 ms.</p>
-      </column>
-
-      <column name="other_config" key="cfm_extended"
-              type='{"type": "boolean"}'>
-        When <code>true</code>, the CFM module operates in extended mode. This
-        causes it to use a nonstandard destination address to avoid conflicting
-        with compliant implementations which may be running concurrently on the
-        network. Furthermore, extended mode increases the accuracy of the
-        <code>cfm_interval</code> configuration parameter by breaking wire
-        compatibility with 802.1ag compliant implementations.  And extended
-        mode allows eight byte MPIDs.  Defaults to <code>false</code>.
-      </column>
-
-      <column name="other_config" key="cfm_demand" type='{"type": "boolean"}'>
-        <p>
-          When <code>true</code>, and
-          <ref column="other_config" key="cfm_extended"/> is true, the CFM
-          module operates in demand mode.  When in demand mode, traffic
-          received on the <ref table="Interface"/> is used to indicate
-          liveness.  CCMs are still transmitted and received.  At least one
-          CCM must be received every 100 * <ref column="other_config"
-          key="cfm_interval"/> amount of time.  Otherwise, even if traffic
-          are received, the CFM module will raise the connectivity fault.
-        </p>
-
-        <p>
-          Demand mode has a couple of caveats:
-          <ul>
-            <li>
-              To ensure that ovs-vswitchd has enough time to pull statistics
-              from the datapath, the fault detection interval is set to
-              3.5 * MAX(<ref column="other_config" key="cfm_interval"/>, 500)
-              ms.
-            </li>
-
-            <li>
-              To avoid ambiguity, demand mode disables itself when there are
-              multiple remote maintenance points.
-            </li>
-
-            <li>
-              If the <ref table="Interface"/> is heavily congested, CCMs
-              containing the <ref column="other_config" key="cfm_opstate"/>
-              status may be dropped causing changes in the operational state to
-              be delayed.  Similarly, if CCMs containing the RDI bit are not
-              received, unidirectional link failures may not be detected.
-            </li>
-          </ul>
-        </p>
-      </column>
-
-      <column name="other_config" key="cfm_opstate"
-              type='{"type": "string", "enum": ["set", ["down", "up"]]}'>
-        When <code>down</code>, the CFM module marks all CCMs it generates as
-        operationally down without triggering a fault.  This allows remote
-        maintenance points to choose not to forward traffic to the
-        <ref table="Interface"/> on which this CFM module is running.
-        Currently, in Open vSwitch, the opdown bit of CCMs affects
-        <ref table="Interface"/>s participating in bonds, and the bundle
-        OpenFlow action. This setting is ignored when CFM is not in extended
-        mode.  Defaults to <code>up</code>.
-      </column>
-
-      <column name="other_config" key="cfm_ccm_vlan"
-              type='{"type": "integer", "minInteger": 1, "maxInteger": 4095}'>
-        When set, the CFM module will apply a VLAN tag to all CCMs it generates
-        with the given value.  May be the string <code>random</code> in which
-        case each CCM will be tagged with a different randomly generated VLAN.
-      </column>
-
-      <column name="other_config" key="cfm_ccm_pcp"
-              type='{"type": "integer", "minInteger": 1, "maxInteger": 7}'>
-        When set, the CFM module will apply a VLAN tag to all CCMs it generates
-        with the given PCP value, the VLAN ID of the tag is governed by the
-        value of <ref column="other_config" key="cfm_ccm_vlan"/>. If
-        <ref column="other_config" key="cfm_ccm_vlan"/> is unset, a VLAN ID of
-        zero is used.
-      </column>
-
-    </group>
-
-    <group title="Bonding Configuration">
-      <column name="other_config" key="lacp-port-id"
-              type='{"type": "integer", "minInteger": 1, "maxInteger": 65535}'>
-        The LACP port ID of this <ref table="Interface"/>.  Port IDs are
-        used in LACP negotiations to identify individual ports
-        participating in a bond.
-      </column>
-
-      <column name="other_config" key="lacp-port-priority"
-              type='{"type": "integer", "minInteger": 1, "maxInteger": 65535}'>
-        The LACP port priority of this <ref table="Interface"/>.  In LACP
-        negotiations <ref table="Interface"/>s with numerically lower
-        priorities are preferred for aggregation.
-      </column>
-
-      <column name="other_config" key="lacp-aggregation-key"
-              type='{"type": "integer", "minInteger": 1, "maxInteger": 65535}'>
-        The LACP aggregation key of this <ref table="Interface"/>.  <ref
-        table="Interface"/>s with different aggregation keys may not be active
-        within a given <ref table="Port"/> at the same time.
-      </column>
-    </group>
-
-    <group title="Virtual Machine Identifiers">
-      <p>
-        These key-value pairs specifically apply to an interface that
-        represents a virtual Ethernet interface connected to a virtual
-        machine.  These key-value pairs should not be present for other types
-        of interfaces.  Keys whose names end in <code>-uuid</code> have
-        values that uniquely identify the entity in question.  For a Citrix
-        XenServer hypervisor, these values are UUIDs in RFC 4122 format.
-        Other hypervisors may use other formats.
-      </p>
-
-      <column name="external_ids" key="attached-mac">
-        The MAC address programmed into the ``virtual hardware'' for this
-        interface, in the form
-        <var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>:<var>xx</var>.
-        For Citrix XenServer, this is the value of the <code>MAC</code> field
-        in the VIF record for this interface.
-      </column>
-
-      <column name="external_ids" key="iface-id">
-        A system-unique identifier for the interface.  On XenServer, this will
-        commonly be the same as <ref column="external_ids" key="xs-vif-uuid"/>.
-      </column>
-
-      <column name="external_ids" key="iface-status"
-              type='{"type": "string",
-                    "enum": ["set", ["active", "inactive"]]}'>
-        <p>
-          Hypervisors may sometimes have more than one interface associated
-          with a given <ref column="external_ids" key="iface-id"/>, only one of
-          which is actually in use at a given time.  For example, in some
-          circumstances XenServer has both a ``tap'' and a ``vif'' interface
-          for a single <ref column="external_ids" key="iface-id"/>, but only
-          uses one of them at a time.  A hypervisor that behaves this way must
-          mark the currently in use interface <code>active</code> and the
-          others <code>inactive</code>.  A hypervisor that never has more than
-          one interface for a given <ref column="external_ids" key="iface-id"/>
-          may mark that interface <code>active</code> or omit <ref
-          column="external_ids" key="iface-status"/> entirely.
-        </p>
-
-        <p>
-          During VM migration, a given <ref column="external_ids"
-          key="iface-id"/> might transiently be marked <code>active</code> on
-          two different hypervisors.  That is, <code>active</code> means that
-          this <ref column="external_ids" key="iface-id"/> is the active
-          instance within a single hypervisor, not in a broader scope.
-          There is one exception: some hypervisors support ``migration'' from a
-          given hypervisor to itself (most often for test purposes).  During
-          such a ``migration,'' two instances of a single <ref
-          column="external_ids" key="iface-id"/> might both be briefly marked
-          <code>active</code> on a single hypervisor.
-        </p>
-      </column>
-
-      <column name="external_ids" key="xs-vif-uuid">
-        The virtual interface associated with this interface.
-      </column>
-
-      <column name="external_ids" key="xs-network-uuid">
-        The virtual network to which this interface is attached.
-      </column>
-
-      <column name="external_ids" key="vm-id">
-        The VM to which this interface belongs. On XenServer, this will be the
-        same as <ref column="external_ids" key="xs-vm-uuid"/>.
-      </column>
-
-      <column name="external_ids" key="xs-vm-uuid">
-        The VM to which this interface belongs.
-      </column>
-    </group>
-
-    <group title="VLAN Splinters">
-      <p>
-        The ``VLAN splinters'' feature increases Open vSwitch compatibility
-        with buggy network drivers in old versions of Linux that do not
-        properly support VLANs when VLAN devices are not used, at some cost
-        in memory and performance.
-      </p>
-
-      <p>
-        When VLAN splinters are enabled on a particular interface, Open vSwitch
-        creates a VLAN device for each in-use VLAN.  For sending traffic tagged
-        with a VLAN on the interface, it substitutes the VLAN device.  Traffic
-        received on the VLAN device is treated as if it had been received on
-        the interface on the particular VLAN.
-      </p>
-
-      <p>
-        VLAN splinters consider a VLAN to be in use if:
-      </p>
-
-      <ul>
-        <li>
-          The VLAN is the <ref table="Port" column="tag"/> value in any <ref
-          table="Port"/> record.
-        </li>
-
-        <li>
-          The VLAN is listed within the <ref table="Port" column="trunks"/>
-          column of the <ref table="Port"/> record of an interface on which
-          VLAN splinters are enabled.
-
-          An empty <ref table="Port" column="trunks"/> does not influence the
-          in-use VLANs: creating 4,096 VLAN devices is impractical because it
-          will exceed the current 1,024 port per datapath limit.
-        </li>
-
-        <li>
-          An OpenFlow flow within any bridge matches the VLAN.
-        </li>
-      </ul>
-
-      <p>
-        The same set of in-use VLANs applies to every interface on which VLAN
-        splinters are enabled.  That is, the set is not chosen separately for
-        each interface but selected once as the union of all in-use VLANs based
-        on the rules above.
-      </p>
-
-      <p>
-        It does not make sense to enable VLAN splinters on an interface for an
-        access port, or on an interface that is not a physical port.
-      </p>
-
-      <p>
-        VLAN splinters are deprecated.  When broken device drivers are no
-        longer in widespread use, we will delete this feature.
-      </p>
-
-      <column name="other_config" key="enable-vlan-splinters"
-              type='{"type": "boolean"}'>
-        <p>
-          Set to <code>true</code> to enable VLAN splinters on this interface.
-          Defaults to <code>false</code>.
-        </p>
-
-        <p>
-          VLAN splinters increase kernel and userspace memory overhead, so do
-          not use them unless they are needed.
-        </p>
-
-        <p>
-          VLAN splinters do not support 802.1p priority tags.  Received
-          priorities will appear to be 0, regardless of their actual values,
-          and priorities on transmitted packets will also be cleared to 0.
-        </p>
-      </column>
-    </group>
-
-    <group title="Auto Attach Configuration">
-      <p>
-        Auto Attach configuration for a particular interface.
-      </p>
-
-      <column name="lldp" key="enable" type='{"type": "boolean"}'>
-        True to enable LLDP on this <ref table="Interface"/>.  If not
-        specified, LLDP will be disabled by default.
-      </column>
-    </group>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="other_config"/>
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="Flow_Table" title="OpenFlow table configuration">
-    <p>Configuration for a particular OpenFlow table.</p>
-
-    <column name="name">
-      The table's name.  Set this column to change the name that controllers
-      will receive when they request table statistics, e.g. <code>ovs-ofctl
-      dump-tables</code>.  The name does not affect switch behavior.
-    </column>
-
-    <group title="Eviction Policy">
-      <p>
-        Open vSwitch supports limiting the number of flows that may be
-        installed in a flow table, via the <ref column="flow_limit"/> column.
-        When adding a flow would exceed this limit, by default Open vSwitch
-        reports an error, but there are two ways to configure Open vSwitch to
-        instead delete (``evict'') a flow to make room for the new one:
-      </p>
-
-      <ul>
-        <li>
-          Set the <ref column="overflow_policy"/> column to <code>evict</code>.
-        </li>
-
-        <li>
-          Send an OpenFlow 1.4+ ``table mod request'' to enable eviction for
-          the flow table (e.g. <code>ovs-ofctl -O OpenFlow14 mod-table br0 0
-          evict</code> to enable eviction on flow table 0 of bridge
-          <code>br0</code>).
-        </li>
-      </ul>
-
-      <p>
-        When a flow must be evicted due to overflow, the flow to evict is
-        chosen through an approximation of the following algorithm.  This
-        algorithm is used regardless of how eviction was enabled:
-      </p>
-
-      <ol>
-        <li>
-          Divide the flows in the table into groups based on the values of the
-          fields or subfields specified in the <ref column="groups"/> column,
-          so that all of the flows in a given group have the same values for
-          those fields.  If a flow does not specify a given field, that field's
-          value is treated as 0.  If <ref column="groups"/> is empty, then all
-          of the flows in the flow table are treated as a single group.
-        </li>
-
-        <li>
-          Consider the flows in the largest group, that is, the group that
-          contains the greatest number of flows.  If two or more groups all
-          have the same largest number of flows, consider the flows in all of
-          those groups.
-        </li>
-
-        <li>
-          If the flows under consideration have different importance values,
-          eliminate from consideration any flows except those with the lowest
-          importance.  (``Importance,'' a 16-bit integer value attached to each
-          flow, was introduced in OpenFlow 1.4.  Flows inserted with older
-          versions of OpenFlow always have an importance of 0.)
-        </li>
-
-        <li>
-          Among the flows under consideration, choose the flow that expires
-          soonest for eviction.
-        </li>
-      </ol>
-
-      <p>
-        The eviction process only considers flows that have an idle timeout
-        or a hard timeout.  That is, eviction never deletes permanent flows.
-        (Permanent flows do count against <ref column="flow_limit"/>.)
-      </p>
-
-      <column name="flow_limit">
-        If set, limits the number of flows that may be added to the table.
-        Open vSwitch may limit the number of flows in a table for other
-        reasons, e.g. due to hardware limitations or for resource availability
-        or performance reasons.
-      </column>
-
-      <column name="overflow_policy">
-        <p>
-          Controls the switch's behavior when an OpenFlow flow table
-          modification request would add flows in excess of <ref
-          column="flow_limit"/>.  The supported values are:
-        </p>
-
-        <dl>
-          <dt><code>refuse</code></dt>
-          <dd>
-            Refuse to add the flow or flows.  This is also the default policy
-            when <ref column="overflow_policy"/> is unset.
-          </dd>
-
-          <dt><code>evict</code></dt>
-          <dd>
-            Delete a flow chosen according to the algorithm described above.
-          </dd>
-        </dl>
-      </column>
-
-      <column name="groups">
-        <p>
-          When <ref column="overflow_policy"/> is <code>evict</code>, this
-          controls how flows are chosen for eviction when the flow table would
-          otherwise exceed <ref column="flow_limit"/> flows.  Its value is a
-          set of NXM fields or sub-fields, each of which takes one of the forms
-          <code><var>field</var>[]</code> or
-          <code><var>field</var>[<var>start</var>..<var>end</var>]</code>,
-          e.g. <code>NXM_OF_IN_PORT[]</code>.  Please see
-          <code>nicira-ext.h</code> for a complete list of NXM field names.
-        </p>
-
-        <p>
-          Open vSwitch ignores any invalid or unknown field specifications.
-        </p>
-
-        <p>
-          When eviction is not enabled, via <ref column="overflow_policy"/> or
-          an OpenFlow 1.4+ ``table mod,'' this column has no effect.
-        </p>
-      </column>
-    </group>
-
-    <group title="Classifier Optimization">
-      <column name="prefixes">
-        <p>
-          This string set specifies which fields should be used for
-          address prefix tracking.  Prefix tracking allows the
-          classifier to skip rules with longer than necessary prefixes,
-          resulting in better wildcarding for datapath flows.
-        </p>
-        <p>
-          Prefix tracking may be beneficial when a flow table contains
-          matches on IP address fields with different prefix lengths.
-          For example, when a flow table contains IP address matches on
-          both full addresses and proper prefixes, the full address
-          matches will typically cause the datapath flow to un-wildcard
-          the whole address field (depending on flow entry priorities).
-          In this case each packet with a different address gets handed
-          to the userspace for flow processing and generates its own
-          datapath flow.  With prefix tracking enabled for the address
-          field in question packets with addresses matching shorter
-          prefixes would generate datapath flows where the irrelevant
-          address bits are wildcarded, allowing the same datapath flow
-          to handle all the packets within the prefix in question.  In
-          this case many userspace upcalls can be avoided and the
-          overall performance can be better.
-        </p>
-        <p>
-          This is a performance optimization only, so packets will
-          receive the same treatment with or without prefix tracking.
-        </p>
-        <p>
-          The supported fields are: <code>tun_id</code>,
-          <code>tun_src</code>, <code>tun_dst</code>,
-          <code>nw_src</code>, <code>nw_dst</code> (or aliases
-          <code>ip_src</code> and <code>ip_dst</code>),
-          <code>ipv6_src</code>, and <code>ipv6_dst</code>.  (Using this
-          feature for <code>tun_id</code> would only make sense if the
-          tunnel IDs have prefix structure similar to IP addresses.)
-        </p>
-
-        <p>
-          By default, the <code>prefixes=ip_dst,ip_src</code> are used
-          on each flow table.  This instructs the flow classifier to
-          track the IP destination and source addresses used by the
-          rules in this specific flow table.
-        </p>
-
-        <p>
-          The keyword <code>none</code> is recognized as an explicit
-          override of the default values, causing no prefix fields to be
-          tracked.
-        </p>
-
-        <p>
-          To set the prefix fields, the flow table record needs to
-          exist:
-        </p>
-
-        <dl>
-          <dt><code>ovs-vsctl set Bridge br0 flow_tables:0=@N1 -- --id=@N1 create Flow_Table name=table0</code></dt>
-          <dd>
-            Creates a flow table record for the OpenFlow table number 0.
-          </dd>
-
-          <dt><code>ovs-vsctl set Flow_Table table0 prefixes=ip_dst,ip_src</code></dt>
-          <dd>
-            Enables prefix tracking for IP source and destination
-            address fields.
-          </dd>
-        </dl>
-
-        <p>
-          There is a maximum number of fields that can be enabled for any
-          one flow table.  Currently this limit is 3.
-        </p>
-      </column>
-    </group>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="QoS" title="Quality of Service configuration">
-    <p>Quality of Service (QoS) configuration for each Port that
-    references it.</p>
-
-    <column name="type">
-      <p>The type of QoS to implement. The currently defined types are
-      listed below:</p>
-      <dl>
-        <dt><code>linux-htb</code></dt>
-        <dd>
-          Linux ``hierarchy token bucket'' classifier.  See tc-htb(8) (also at
-          <code>http://linux.die.net/man/8/tc-htb</code>) and the HTB manual
-          (<code>http://luxik.cdi.cz/~devik/qos/htb/manual/userg.htm</code>)
-          for information on how this classifier works and how to configure it.
-        </dd>
-      </dl>
-      <dl>
-        <dt><code>linux-hfsc</code></dt>
-        <dd>
-          Linux "Hierarchical Fair Service Curve" classifier.
-          See <code>http://linux-ip.net/articles/hfsc.en/</code> for
-          information on how this classifier works.
-        </dd>
-      </dl>
-      <dl>
-        <dt><code>linux-sfq</code></dt>
-        <dd>
-          Linux ``Stochastic Fairness Queueing'' classifier. See
-          <code>tc-sfq</code>(8) (also at
-          <code>http://linux.die.net/man/8/tc-sfq</code>) for information on
-          how this classifier works.
-        </dd>
-      </dl>
-      <dl>
-        <dt><code>linux-codel</code></dt>
-        <dd>
-          Linux ``Controlled Delay'' classifier. See <code>tc-codel</code>(8)
-          (also at
-          <code>http://man7.org/linux/man-pages/man8/tc-codel.8.html</code>)
-          for information on how this classifier works.
-        </dd>
-      </dl>
-      <dl>
-        <dt><code>linux-fq_codel</code></dt>
-        <dd>
-          Linux ``Fair Queuing with Controlled Delay'' classifier. See
-          <code>tc-fq_codel</code>(8) (also at
-          <code>http://man7.org/linux/man-pages/man8/tc-fq_codel.8.html</code>)
-          for information on how this classifier works.
-        </dd>
-      </dl>
-    </column>
-
-    <column name="queues">
-      <p>A map from queue numbers to <ref table="Queue"/> records.  The
-      supported range of queue numbers depend on <ref column="type"/>.  The
-      queue numbers are the same as the <code>queue_id</code> used in
-      OpenFlow in <code>struct ofp_action_enqueue</code> and other
-      structures.</p>
-
-      <p>
-        Queue 0 is the ``default queue.''  It is used by OpenFlow output
-        actions when no specific queue has been set.  When no configuration for
-        queue 0 is present, it is automatically configured as if a <ref
-        table="Queue"/> record with empty <ref table="Queue" column="dscp"/>
-        and <ref table="Queue" column="other_config"/> columns had been
-        specified.
-        (Before version 1.6, Open vSwitch would leave queue 0 unconfigured in
-        this case.  With some queuing disciplines, this dropped all packets
-        destined for the default queue.)
-      </p>
-    </column>
-
-    <group title="Configuration for linux-htb and linux-hfsc">
-      <p>
-        The <code>linux-htb</code> and <code>linux-hfsc</code> classes support
-        the following key-value pair:
-      </p>
-
-      <column name="other_config" key="max-rate" type='{"type": "integer"}'>
-        Maximum rate shared by all queued traffic, in bit/s.  Optional.  If not
-        specified, for physical interfaces, the default is the link rate.  For
-        other interfaces or if the link rate cannot be determined, the default
-        is currently 100 Mbps.
-      </column>
-    </group>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="other_config"/>
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="Queue" title="QoS output queue.">
-    <p>A configuration for a port output queue, used in configuring Quality of
-    Service (QoS) features.  May be referenced by <ref column="queues"
-    table="QoS"/> column in <ref table="QoS"/> table.</p>
-
-    <column name="dscp">
-      If set, Open vSwitch will mark all traffic egressing this
-      <ref table="Queue"/> with the given DSCP bits.  Traffic egressing the
-      default <ref table="Queue"/> is only marked if it was explicitly selected
-      as the <ref table="Queue"/> at the time the packet was output.  If unset,
-      the DSCP bits of traffic egressing this <ref table="Queue"/> will remain
-      unchanged.
-    </column>
-
-    <group title="Configuration for linux-htb QoS">
-      <p>
-        <ref table="QoS"/> <ref table="QoS" column="type"/>
-        <code>linux-htb</code> may use <code>queue_id</code>s less than 61440.
-        It has the following key-value pairs defined.
-      </p>
-
-      <column name="other_config" key="min-rate"
-              type='{"type": "integer", "minInteger": 1}'>
-        Minimum guaranteed bandwidth, in bit/s.
-      </column>
-
-      <column name="other_config" key="max-rate"
-              type='{"type": "integer", "minInteger": 1}'>
-        Maximum allowed bandwidth, in bit/s.  Optional.  If specified, the
-        queue's rate will not be allowed to exceed the specified value, even
-        if excess bandwidth is available.  If unspecified, defaults to no
-        limit.
-      </column>
-
-      <column name="other_config" key="burst"
-              type='{"type": "integer", "minInteger": 1}'>
-        Burst size, in bits.  This is the maximum amount of ``credits'' that a
-        queue can accumulate while it is idle.  Optional.  Details of the
-        <code>linux-htb</code> implementation require a minimum burst size, so
-        a too-small <code>burst</code> will be silently ignored.
-      </column>
-
-      <column name="other_config" key="priority"
-              type='{"type": "integer", "minInteger": 0, "maxInteger": 4294967295}'>
-        A queue with a smaller <code>priority</code> will receive all the
-        excess bandwidth that it can use before a queue with a larger value
-        receives any.  Specific priority values are unimportant; only relative
-        ordering matters.  Defaults to 0 if unspecified.
-      </column>
-    </group>
-
-    <group title="Configuration for linux-hfsc QoS">
-      <p>
-        <ref table="QoS"/> <ref table="QoS" column="type"/>
-        <code>linux-hfsc</code> may use <code>queue_id</code>s less than 61440.
-        It has the following key-value pairs defined.
-      </p>
-
-      <column name="other_config" key="min-rate"
-              type='{"type": "integer", "minInteger": 1}'>
-        Minimum guaranteed bandwidth, in bit/s.
-      </column>
-
-      <column name="other_config" key="max-rate"
-              type='{"type": "integer", "minInteger": 1}'>
-        Maximum allowed bandwidth, in bit/s.  Optional.  If specified, the
-        queue's rate will not be allowed to exceed the specified value, even if
-        excess bandwidth is available.  If unspecified, defaults to no
-        limit.
-      </column>
-    </group>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="other_config"/>
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="Mirror" title="Port mirroring.">
-    <p>A port mirror within a <ref table="Bridge"/>.</p>
-    <p>A port mirror configures a bridge to send selected frames to special
-    ``mirrored'' ports, in addition to their normal destinations.  Mirroring
-    traffic may also be referred to as SPAN or RSPAN, depending on how
-    the mirrored traffic is sent.</p>
-
-    <p>
-      When a packet enters an Open vSwitch bridge, it becomes eligible for
-      mirroring based on its ingress port and VLAN.  As the packet travels
-      through the flow tables, each time it is output to a port, it becomes
-      eligible for mirroring based on the egress port and VLAN.  In Open
-      vSwitch 2.5 and later, mirroring occurs just after a packet first becomes
-      eligible, using the packet as it exists at that point; in Open vSwitch
-      2.4 and earlier, mirroring occurs only after a packet has traversed all
-      the flow tables, using the original packet as it entered the bridge.
-      This makes a difference only when the flow table modifies the packet: in
-      Open vSwitch 2.4, the modifications are never visible to mirrors, whereas
-      in Open vSwitch 2.5 and later modifications made before the first output
-      that makes it eligible for mirroring to a particular destination are
-      visible.
-    </p>
-
-    <p>
-      A packet that enters an Open vSwitch bridge is mirrored to a particular
-      destination only once, even if it is eligible for multiple reasons.  For
-      example, a packet would be mirrored to a particular <ref
-      column="output_port"/> only once, even if it is selected for mirroring to
-      that port by <ref column="select_dst_port"/> and <ref
-      column="select_src_port"/> in the same or different <ref table="Mirror"/>
-      records.
-    </p>
-
-    <column name="name">
-      Arbitrary identifier for the <ref table="Mirror"/>.
-    </column>
-
-    <group title="Selecting Packets for Mirroring">
-      <p>
-        To be selected for mirroring, a given packet must enter or leave the
-        bridge through a selected port and it must also be in one of the
-        selected VLANs.
-      </p>
-
-      <column name="select_all">
-        If true, every packet arriving or departing on any port is
-        selected for mirroring.
-      </column>
-
-      <column name="select_dst_port">
-        Ports on which departing packets are selected for mirroring.
-      </column>
-
-      <column name="select_src_port">
-        Ports on which arriving packets are selected for mirroring.
-      </column>
-
-      <column name="select_vlan">
-        VLANs on which packets are selected for mirroring.  An empty set
-        selects packets on all VLANs.
-      </column>
-    </group>
-
-    <group title="Mirroring Destination Configuration">
-      <p>
-        These columns are mutually exclusive.  Exactly one of them must be
-        nonempty.
-      </p>
-
-      <column name="output_port">
-        <p>Output port for selected packets, if nonempty.</p>
-        <p>Specifying a port for mirror output reserves that port exclusively
-        for mirroring.  No frames other than those selected for mirroring
-        via this column
-        will be forwarded to the port, and any frames received on the port
-        will be discarded.</p>
-        <p>
-          The output port may be any kind of port supported by Open vSwitch.
-          It may be, for example, a physical port (sometimes called SPAN) or a
-          GRE tunnel.
-        </p>
-      </column>
-
-      <column name="output_vlan">
-        <p>Output VLAN for selected packets, if nonempty.</p>
-        <p>The frames will be sent out all ports that trunk
-        <ref column="output_vlan"/>, as well as any ports with implicit VLAN
-        <ref column="output_vlan"/>.  When a mirrored frame is sent out a
-        trunk port, the frame's VLAN tag will be set to
-        <ref column="output_vlan"/>, replacing any existing tag; when it is
-        sent out an implicit VLAN port, the frame will not be tagged.  This
-        type of mirroring is sometimes called RSPAN.</p>
-        <p>
-          See the documentation for
-          <ref column="other_config" key="forward-bpdu"/> in the
-          <ref table="Interface"/> table for a list of destination MAC
-          addresses which will not be mirrored to a VLAN to avoid confusing
-          switches that interpret the protocols that they represent.
-        </p>
-        <p><em>Please note:</em> Mirroring to a VLAN can disrupt a network that
-        contains unmanaged switches.  Consider an unmanaged physical switch
-        with two ports: port 1, connected to an end host, and port 2,
-        connected to an Open vSwitch configured to mirror received packets
-        into VLAN 123 on port 2.  Suppose that the end host sends a packet on
-        port 1 that the physical switch forwards to port 2.  The Open vSwitch
-        forwards this packet to its destination and then reflects it back on
-        port 2 in VLAN 123.  This reflected packet causes the unmanaged
-        physical switch to replace the MAC learning table entry, which
-        correctly pointed to port 1, with one that incorrectly points to port
-        2.  Afterward, the physical switch will direct packets destined for
-        the end host to the Open vSwitch on port 2, instead of to the end
-        host on port 1, disrupting connectivity.  If mirroring to a VLAN is
-        desired in this scenario, then the physical switch must be replaced
-        by one that learns Ethernet addresses on a per-VLAN basis.  In
-        addition, learning should be disabled on the VLAN containing mirrored
-        traffic. If this is not done then intermediate switches will learn
-        the MAC address of each end host from the mirrored traffic.  If
-        packets being sent to that end host are also mirrored, then they will
-        be dropped since the switch will attempt to send them out the input
-        port. Disabling learning for the VLAN will cause the switch to
-        correctly send the packet out all ports configured for that VLAN.  If
-        Open vSwitch is being used as an intermediate switch, learning can be
-        disabled by adding the mirrored VLAN to <ref column="flood_vlans"/>
-        in the appropriate <ref table="Bridge"/> table or tables.</p>
-        <p>
-          Mirroring to a GRE tunnel has fewer caveats than mirroring to a
-          VLAN and should generally be preferred.
-        </p>
-      </column>
-    </group>
-
-    <group title="Statistics: Mirror counters">
-      <p>
-        Key-value pairs that report mirror statistics.  The update period
-        is controlled by <ref column="other_config"
-        key="stats-update-interval"/> in the <code>Open_vSwitch</code> table.
-      </p>
-      <column name="statistics" key="tx_packets">
-        Number of packets transmitted through this mirror.
-      </column>
-      <column name="statistics" key="tx_bytes">
-        Number of bytes transmitted through this mirror.
-      </column>
-    </group>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="Controller" title="OpenFlow controller configuration.">
-    <p>An OpenFlow controller.</p>
-
-    <p>
-      Open vSwitch supports two kinds of OpenFlow controllers:
-    </p>
-
-    <dl>
-      <dt>Primary controllers</dt>
-      <dd>
-        <p>
-          This is the kind of controller envisioned by the OpenFlow 1.0
-          specification.  Usually, a primary controller implements a network
-          policy by taking charge of the switch's flow table.
-        </p>
-
-        <p>
-          Open vSwitch initiates and maintains persistent connections to
-          primary controllers, retrying the connection each time it fails or
-          drops.  The <ref table="Bridge" column="fail_mode"/> column in the
-          <ref table="Bridge"/> table applies to primary controllers.
-        </p>
-
-        <p>
-          Open vSwitch permits a bridge to have any number of primary
-          controllers.  When multiple controllers are configured, Open
-          vSwitch connects to all of them simultaneously.  Because
-          OpenFlow 1.0 does not specify how multiple controllers
-          coordinate in interacting with a single switch, more than
-          one primary controller should be specified only if the
-          controllers are themselves designed to coordinate with each
-          other.  (The Nicira-defined <code>NXT_ROLE</code> OpenFlow
-          vendor extension may be useful for this.)
-        </p>
-      </dd>
-      <dt>Service controllers</dt>
-      <dd>
-        <p>
-          These kinds of OpenFlow controller connections are intended for
-          occasional support and maintenance use, e.g. with
-          <code>ovs-ofctl</code>.  Usually a service controller connects only
-          briefly to inspect or modify some of a switch's state.
-        </p>
-
-        <p>
-          Open vSwitch listens for incoming connections from service
-          controllers.  The service controllers initiate and, if necessary,
-          maintain the connections from their end.  The <ref table="Bridge"
-          column="fail_mode"/> column in the <ref table="Bridge"/> table does
-          not apply to service controllers.
-        </p>
-
-        <p>
-          Open vSwitch supports configuring any number of service controllers.
-        </p>
-      </dd>
-    </dl>
-
-    <p>
-      The <ref column="target"/> determines the type of controller.
-    </p>
-
-    <group title="Core Features">
-      <column name="target">
-        <p>Connection method for controller.</p>
-        <p>
-          The following connection methods are currently supported for primary
-          controllers:
-        </p>
-        <dl>
-          <dt><code>ssl:<var>ip</var></code>[<code>:<var>port</var></code>]</dt>
-          <dd>
-            <p>The specified SSL <var>port</var> on the host at the
-            given <var>ip</var>, which must be expressed as an IP
-            address (not a DNS name).  The <ref table="Open_vSwitch"
-            column="ssl"/> column in the <ref table="Open_vSwitch"/>
-            table must point to a valid SSL configuration when this form
-            is used.</p>
-            <p>If <var>port</var> is not specified, it defaults to 6653.</p>
-            <p>SSL support is an optional feature that is not always built as
-            part of Open vSwitch.</p>
-          </dd>
-          <dt><code>tcp:<var>ip</var></code>[<code>:<var>port</var></code>]</dt>
-          <dd>
-            <p>
-              The specified TCP <var>port</var> on the host at the given
-              <var>ip</var>, which must be expressed as an IP address (not a
-              DNS name), where <var>ip</var> can be IPv4 or IPv6 address.  If
-              <var>ip</var> is an IPv6 address, wrap it in square brackets,
-              e.g. <code>tcp:[::1]:6653</code>.
-            </p>
-            <p>
-              If <var>port</var> is not specified, it defaults to 6653.
-            </p>
-          </dd>
-        </dl>
-        <p>
-          The following connection methods are currently supported for service
-          controllers:
-        </p>
-        <dl>
-          <dt><code>pssl:</code>[<var>port</var>][<code>:<var>ip</var></code>]</dt>
-          <dd>
-            <p>
-              Listens for SSL connections on the specified TCP <var>port</var>.
-              If <var>ip</var>, which must be expressed as an IP address (not a
-              DNS name), is specified, then connections are restricted to the
-              specified local IP address (either IPv4 or IPv6).  If
-              <var>ip</var> is an IPv6 address, wrap it in square brackets,
-              e.g. <code>pssl:6653:[::1]</code>.
-            </p>
-            <p>
-              If <var>port</var> is not specified, it defaults to
-              6653.  If <var>ip</var> is not specified then it listens only on
-              IPv4 (but not IPv6) addresses.  The
-              <ref table="Open_vSwitch" column="ssl"/>
-              column in the <ref table="Open_vSwitch"/> table must point to a
-              valid SSL configuration when this form is used.
-            </p>
-            <p>
-              If <var>port</var> is not specified, it currently to 6653.
-            </p>
-            <p>
-              SSL support is an optional feature that is not always built as
-              part of Open vSwitch.
-            </p>
-          </dd>
-          <dt><code>ptcp:</code>[<var>port</var>][<code>:<var>ip</var></code>]</dt>
-          <dd>
-            <p>
-              Listens for connections on the specified TCP <var>port</var>.  If
-              <var>ip</var>, which must be expressed as an IP address (not a
-              DNS name), is specified, then connections are restricted to the
-              specified local IP address (either IPv4 or IPv6).  If
-              <var>ip</var> is an IPv6 address, wrap it in square brackets,
-              e.g. <code>ptcp:6653:[::1]</code>. If <var>ip</var> is not
-              specified then it listens only on IPv4 addresses.
-            </p>
-            <p>
-              If <var>port</var> is not specified, it defaults to 6653.
-            </p>
-          </dd>
-        </dl>
-        <p>When multiple controllers are configured for a single bridge, the
-        <ref column="target"/> values must be unique.  Duplicate
-        <ref column="target"/> values yield unspecified results.</p>
-      </column>
-
-      <column name="connection_mode">
-        <p>If it is specified, this setting must be one of the following
-        strings that describes how Open vSwitch contacts this OpenFlow
-        controller over the network:</p>
-
-        <dl>
-          <dt><code>in-band</code></dt>
-          <dd>In this mode, this controller's OpenFlow traffic travels over the
-          bridge associated with the controller.  With this setting, Open
-          vSwitch allows traffic to and from the controller regardless of the
-          contents of the OpenFlow flow table.  (Otherwise, Open vSwitch
-          would never be able to connect to the controller, because it did
-          not have a flow to enable it.)  This is the most common connection
-          mode because it is not necessary to maintain two independent
-          networks.</dd>
-          <dt><code>out-of-band</code></dt>
-          <dd>In this mode, OpenFlow traffic uses a control network separate
-          from the bridge associated with this controller, that is, the
-          bridge does not use any of its own network devices to communicate
-          with the controller.  The control network must be configured
-          separately, before or after <code>ovs-vswitchd</code> is started.
-          </dd>
-        </dl>
-
-        <p>If not specified, the default is implementation-specific.</p>
-      </column>
-    </group>
-
-    <group title="Controller Failure Detection and Handling">
-      <column name="max_backoff">
-        Maximum number of milliseconds to wait between connection attempts.
-        Default is implementation-specific.
-      </column>
-
-      <column name="inactivity_probe">
-        Maximum number of milliseconds of idle time on connection to
-        controller before sending an inactivity probe message.  If Open
-        vSwitch does not communicate with the controller for the specified
-        number of seconds, it will send a probe.  If a response is not
-        received for the same additional amount of time, Open vSwitch
-        assumes the connection has been broken and attempts to reconnect.
-        Default is implementation-specific.  A value of 0 disables
-        inactivity probes.
-      </column>
-    </group>
-
-    <group title="Asynchronous Messages">
-      <p>
-        OpenFlow switches send certain messages to controllers spontanenously,
-        that is, not in response to any request from the controller.  These
-        messages are called ``asynchronous messages.''  These columns allow
-        asynchronous messages to be limited or disabled to ensure the best use
-        of network resources.
-      </p>
-
-      <column name="enable_async_messages">
-        The OpenFlow protocol enables asynchronous messages at time of
-        connection establishment, which means that a controller can receive
-        asynchronous messages, potentially many of them, even if it turns them
-        off immediately after connecting.  Set this column to
-        <code>false</code> to change Open vSwitch behavior to disable, by
-        default, all asynchronous messages.  The controller can use the
-        <code>NXT_SET_ASYNC_CONFIG</code> Nicira extension to OpenFlow to turn
-        on any messages that it does want to receive, if any.
-      </column>
-
-      <group title="Controller Rate Limiting">
-        <p>
-          A switch can forward packets to a controller over the OpenFlow
-          protocol.  Forwarding packets this way at too high a rate can
-          overwhelm a controller, frustrate use of the OpenFlow connection for
-          other purposes, increase the latency of flow setup, and use an
-          unreasonable amount of bandwidth.  Therefore, Open vSwitch supports
-          limiting the rate of packet forwarding to a controller.
-        </p>
-
-        <p>
-          There are two main reasons in OpenFlow for a packet to be sent to a
-          controller: either the packet ``misses'' in the flow table, that is,
-          there is no matching flow, or a flow table action says to send the
-          packet to the controller.  Open vSwitch limits the rate of each kind
-          of packet separately at the configured rate.  Therefore, the actual
-          rate that packets are sent to the controller can be up to twice the
-          configured rate, when packets are sent for both reasons.
-        </p>
-
-        <p>
-          This feature is specific to forwarding packets over an OpenFlow
-          connection.  It is not general-purpose QoS.  See the <ref
-          table="QoS"/> table for quality of service configuration, and <ref
-          column="ingress_policing_rate" table="Interface"/> in the <ref
-          table="Interface"/> table for ingress policing configuration.
-        </p>
-
-        <column name="controller_rate_limit">
-          <p>
-            The maximum rate at which the switch will forward packets to the
-            OpenFlow controller, in packets per second.  If no value is
-            specified, rate limiting is disabled.
-          </p>
-        </column>
-
-        <column name="controller_burst_limit">
-          <p>
-            When a high rate triggers rate-limiting, Open vSwitch queues
-            packets to the controller for each port and transmits them to the
-            controller at the configured rate.  This value limits the number of
-            queued packets.  Ports on a bridge share the packet queue fairly.
-          </p>
-
-          <p>
-            This value has no effect unless <ref
-            column="controller_rate_limit"/> is configured.  The current
-            default when this value is not specified is one-quarter of <ref
-            column="controller_rate_limit"/>, meaning that queuing can delay
-            forwarding a packet to the controller by up to 250 ms.
-          </p>
-        </column>
-
-        <group title="Controller Rate Limiting Statistics">
-          <p>
-            These values report the effects of rate limiting.  Their values are
-            relative to establishment of the most recent OpenFlow connection,
-            or since rate limiting was enabled, whichever happened more
-            recently.  Each consists of two values, one with <code>TYPE</code>
-            replaced by <code>miss</code> for rate limiting flow table misses,
-            and the other with <code>TYPE</code> replaced by
-            <code>action</code> for rate limiting packets sent by OpenFlow
-            actions.
-          </p>
-
-          <p>
-            These statistics are reported only when controller rate limiting is
-            enabled.
-          </p>
-
-          <column name="status" key="packet-in-TYPE-bypassed"
-                  type='{"type": "integer", "minInteger": 0}'>
-            Number of packets sent directly to the controller, without queuing,
-            because the rate did not exceed the configured maximum.
-          </column>
-
-          <column name="status" key="packet-in-TYPE-queued"
-                  type='{"type": "integer", "minInteger": 0}'>
-            Number of packets added to the queue to send later.
-          </column>
-
-          <column name="status" key="packet-in-TYPE-dropped"
-                  type='{"type": "integer", "minInteger": 0}'>
-            Number of packets added to the queue that were later dropped due to
-            overflow.  This value is less than or equal to <ref column="status"
-            key="packet-in-TYPE-queued"/>.
-          </column>
-
-          <column name="status" key="packet-in-TYPE-backlog"
-                  type='{"type": "integer", "minInteger": 0}'>
-            Number of packets currently queued.  The other statistics increase
-            monotonically, but this one fluctuates between 0 and the <ref
-            column="controller_burst_limit"/> as conditions change.
-          </column>
-        </group>
-      </group>
-    </group>
-
-    <group title="Additional In-Band Configuration">
-      <p>These values are considered only in in-band control mode (see
-      <ref column="connection_mode"/>).</p>
-
-      <p>When multiple controllers are configured on a single bridge, there
-      should be only one set of unique values in these columns.  If different
-      values are set for these columns in different controllers, the effect
-      is unspecified.</p>
-
-      <column name="local_ip">
-        The IP address to configure on the local port,
-        e.g. <code>192.168.0.123</code>.  If this value is unset, then
-        <ref column="local_netmask"/> and <ref column="local_gateway"/> are
-        ignored.
-      </column>
-
-      <column name="local_netmask">
-        The IP netmask to configure on the local port,
-        e.g. <code>255.255.255.0</code>.  If <ref column="local_ip"/> is set
-        but this value is unset, then the default is chosen based on whether
-        the IP address is class A, B, or C.
-      </column>
-
-      <column name="local_gateway">
-        The IP address of the gateway to configure on the local port, as a
-        string, e.g. <code>192.168.0.1</code>.  Leave this column unset if
-        this network has no gateway.
-      </column>
-    </group>
-
-    <group title="Controller Status">
-      <column name="is_connected">
-        <code>true</code> if currently connected to this controller,
-        <code>false</code> otherwise.
-      </column>
-
-      <column name="role"
-              type='{"type": "string", "enum": ["set", ["other", "master", "slave"]]}'>
-        <p>The level of authority this controller has on the associated
-        bridge. Possible values are:</p>
-        <dl>
-          <dt><code>other</code></dt>
-          <dd>Allows the controller access to all OpenFlow features.</dd>
-          <dt><code>master</code></dt>
-          <dd>Equivalent to <code>other</code>, except that there may be at
-          most one master controller at a time.  When a controller configures
-          itself as <code>master</code>, any existing master is demoted to
-          the <code>slave</code> role.</dd>
-          <dt><code>slave</code></dt>
-          <dd>Allows the controller read-only access to OpenFlow features.
-          Attempts to modify the flow table will be rejected with an
-          error.  Slave controllers do not receive OFPT_PACKET_IN or
-          OFPT_FLOW_REMOVED messages, but they do receive OFPT_PORT_STATUS
-          messages.</dd>
-        </dl>
-      </column>
-
-      <column name="status" key="last_error">
-        A human-readable description of the last error on the connection
-        to the controller; i.e. <code>strerror(errno)</code>.  This key
-        will exist only if an error has occurred.
-      </column>
-
-      <column name="status" key="state"
-              type='{"type": "string", "enum": ["set", ["VOID", "BACKOFF", "CONNECTING", "ACTIVE", "IDLE"]]}'>
-        <p>
-          The state of the connection to the controller:
-        </p>
-        <dl>
-          <dt><code>VOID</code></dt>
-          <dd>Connection is disabled.</dd>
-
-          <dt><code>BACKOFF</code></dt>
-          <dd>Attempting to reconnect at an increasing period.</dd>
-
-          <dt><code>CONNECTING</code></dt>
-          <dd>Attempting to connect.</dd>
-
-          <dt><code>ACTIVE</code></dt>
-          <dd>Connected, remote host responsive.</dd>
-
-          <dt><code>IDLE</code></dt>
-          <dd>Connection is idle.  Waiting for response to keep-alive.</dd>
-        </dl>
-        <p>
-          These values may change in the future.  They are provided only for
-          human consumption.
-        </p>
-      </column>
-
-      <column name="status" key="sec_since_connect"
-              type='{"type": "integer", "minInteger": 0}'>
-        The amount of time since this controller last successfully connected to
-        the switch (in seconds).  Value is empty if controller has never
-        successfully connected.
-      </column>
-
-      <column name="status" key="sec_since_disconnect"
-              type='{"type": "integer", "minInteger": 1}'>
-        The amount of time since this controller last disconnected from
-        the switch (in seconds). Value is empty if controller has never
-        disconnected.
-      </column>
-    </group>
-
-    <group title="Connection Parameters">
-      <p>
-        Additional configuration for a connection between the controller
-        and the Open vSwitch.
-      </p>
-
-      <column name="other_config" key="dscp"
-              type='{"type": "integer"}'>
-        The Differentiated Service Code Point (DSCP) is specified using 6 bits
-        in the Type of Service (TOS) field in the IP header. DSCP provides a
-        mechanism to classify the network traffic and provide Quality of
-        Service (QoS) on IP networks.
-
-        The DSCP value specified here is used when establishing the connection
-        between the controller and the Open vSwitch.  If no value is specified,
-        a default value of 48 is chosen.  Valid DSCP values must be in the
-        range 0 to 63.
-      </column>
-    </group>
-
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="external_ids"/>
-      <column name="other_config"/>
-    </group>
-  </table>
-
-  <table name="Manager" title="OVSDB management connection.">
-    <p>
-      Configuration for a database connection to an Open vSwitch database
-      (OVSDB) client.
-    </p>
-
-    <p>
-      This table primarily configures the Open vSwitch database
-      (<code>ovsdb-server</code>), not the Open vSwitch switch
-      (<code>ovs-vswitchd</code>).  The switch does read the table to determine
-      what connections should be treated as in-band.
-    </p>
-
-    <p>
-      The Open vSwitch database server can initiate and maintain active
-      connections to remote clients.  It can also listen for database
-      connections.
-    </p>
-
-    <group title="Core Features">
-      <column name="target">
-        <p>Connection method for managers.</p>
-        <p>
-          The following connection methods are currently supported:
-        </p>
-        <dl>
-          <dt><code>ssl:<var>ip</var></code>[<code>:<var>port</var></code>]</dt>
-          <dd>
-            <p>
-              The specified SSL <var>port</var> on the host at the given
-              <var>ip</var>, which must be expressed as an IP address
-              (not a DNS name).  The <ref table="Open_vSwitch"
-              column="ssl"/> column in the <ref table="Open_vSwitch"/>
-              table must point to a valid SSL configuration when this
-              form is used.
-            </p>
-            <p>
-              If <var>port</var> is not specified, it defaults to 6640.
-            </p>
-            <p>
-              SSL support is an optional feature that is not always
-              built as part of Open vSwitch.
-            </p>
-          </dd>
-
-          <dt><code>tcp:<var>ip</var></code>[<code>:<var>port</var></code>]</dt>
-          <dd>
-            <p>
-              The specified TCP <var>port</var> on the host at the given
-              <var>ip</var>, which must be expressed as an IP address (not a
-              DNS name), where <var>ip</var> can be IPv4 or IPv6 address.  If
-              <var>ip</var> is an IPv6 address, wrap it in square brackets,
-              e.g. <code>tcp:[::1]:6640</code>.
-            </p>
-            <p>
-              If <var>port</var> is not specified, it defaults to 6640.
-            </p>
-          </dd>
-          <dt><code>pssl:</code>[<var>port</var>][<code>:<var>ip</var></code>]</dt>
-          <dd>
-            <p>
-              Listens for SSL connections on the specified TCP <var>port</var>.
-              Specify 0 for <var>port</var> to have the kernel automatically
-              choose an available port.  If <var>ip</var>, which must be
-              expressed as an IP address (not a DNS name), is specified, then
-              connections are restricted to the specified local IP address
-              (either IPv4 or IPv6 address).  If <var>ip</var> is an IPv6
-              address, wrap in square brackets,
-              e.g. <code>pssl:6640:[::1]</code>.  If <var>ip</var> is not
-              specified then it listens only on IPv4 (but not IPv6) addresses.
-              The <ref table="Open_vSwitch" column="ssl"/> column in the <ref
-              table="Open_vSwitch"/> table must point to a valid SSL
-              configuration when this form is used.
-            </p>
-            <p>
-              If <var>port</var> is not specified, it defaults to 6640.
-            </p>
-            <p>
-              SSL support is an optional feature that is not always built as
-              part of Open vSwitch.
-            </p>
-          </dd>
-          <dt><code>ptcp:</code>[<var>port</var>][<code>:<var>ip</var></code>]</dt>
-          <dd>
-            <p>
-              Listens for connections on the specified TCP <var>port</var>.
-              Specify 0 for <var>port</var> to have the kernel automatically
-              choose an available port.  If <var>ip</var>, which must be
-              expressed as an IP address (not a DNS name), is specified, then
-              connections are restricted to the specified local IP address
-              (either IPv4 or IPv6 address).  If <var>ip</var> is an IPv6
-              address, wrap it in square brackets,
-              e.g. <code>ptcp:6640:[::1]</code>.  If <var>ip</var> is not
-              specified then it listens only on IPv4 addresses.
-            </p>
-            <p>
-              If <var>port</var> is not specified, it defaults to 6640.
-            </p>
-          </dd>
-        </dl>
-        <p>When multiple managers are configured, the <ref column="target"/>
-        values must be unique.  Duplicate <ref column="target"/> values yield
-        unspecified results.</p>
-      </column>
-
-      <column name="connection_mode">
-        <p>
-          If it is specified, this setting must be one of the following strings
-          that describes how Open vSwitch contacts this OVSDB client over the
-          network:
-        </p>
-
-        <dl>
-          <dt><code>in-band</code></dt>
-          <dd>
-            In this mode, this connection's traffic travels over a bridge
-            managed by Open vSwitch.  With this setting, Open vSwitch allows
-            traffic to and from the client regardless of the contents of the
-            OpenFlow flow table.  (Otherwise, Open vSwitch would never be able
-            to connect to the client, because it did not have a flow to enable
-            it.)  This is the most common connection mode because it is not
-            necessary to maintain two independent networks.
-          </dd>
-          <dt><code>out-of-band</code></dt>
-          <dd>
-            In this mode, the client's traffic uses a control network separate
-            from that managed by Open vSwitch, that is, Open vSwitch does not
-            use any of its own network devices to communicate with the client.
-            The control network must be configured separately, before or after
-            <code>ovs-vswitchd</code> is started.
-          </dd>
-        </dl>
-
-        <p>
-          If not specified, the default is implementation-specific.
-        </p>
-      </column>
-    </group>
-
-    <group title="Client Failure Detection and Handling">
-      <column name="max_backoff">
-        Maximum number of milliseconds to wait between connection attempts.
-        Default is implementation-specific.
-      </column>
-
-      <column name="inactivity_probe">
-        Maximum number of milliseconds of idle time on connection to the client
-        before sending an inactivity probe message.  If Open vSwitch does not
-        communicate with the client for the specified number of seconds, it
-        will send a probe.  If a response is not received for the same
-        additional amount of time, Open vSwitch assumes the connection has been
-        broken and attempts to reconnect.  Default is implementation-specific.
-        A value of 0 disables inactivity probes.
-      </column>
-    </group>
-
-    <group title="Status">
-      <column name="is_connected">
-        <code>true</code> if currently connected to this manager,
-        <code>false</code> otherwise.
-      </column>
-
-      <column name="status" key="last_error">
-        A human-readable description of the last error on the connection
-        to the manager; i.e. <code>strerror(errno)</code>.  This key
-        will exist only if an error has occurred.
-      </column>
-
-      <column name="status" key="state"
-              type='{"type": "string", "enum": ["set", ["VOID", "BACKOFF", "CONNECTING", "ACTIVE", "IDLE"]]}'>
-        <p>
-          The state of the connection to the manager:
-        </p>
-        <dl>
-          <dt><code>VOID</code></dt>
-          <dd>Connection is disabled.</dd>
-
-          <dt><code>BACKOFF</code></dt>
-          <dd>Attempting to reconnect at an increasing period.</dd>
-
-          <dt><code>CONNECTING</code></dt>
-          <dd>Attempting to connect.</dd>
-
-          <dt><code>ACTIVE</code></dt>
-          <dd>Connected, remote host responsive.</dd>
-
-          <dt><code>IDLE</code></dt>
-          <dd>Connection is idle.  Waiting for response to keep-alive.</dd>
-        </dl>
-        <p>
-          These values may change in the future.  They are provided only for
-          human consumption.
-        </p>
-      </column>
-
-      <column name="status" key="sec_since_connect"
-              type='{"type": "integer", "minInteger": 0}'>
-        The amount of time since this manager last successfully connected
-        to the database (in seconds). Value is empty if manager has never
-        successfully connected.
-      </column>
-
-      <column name="status" key="sec_since_disconnect"
-              type='{"type": "integer", "minInteger": 0}'>
-        The amount of time since this manager last disconnected from the
-        database (in seconds). Value is empty if manager has never
-        disconnected.
-      </column>
-
-      <column name="status" key="locks_held">
-        Space-separated list of the names of OVSDB locks that the connection
-        holds.  Omitted if the connection does not hold any locks.
-      </column>
-
-      <column name="status" key="locks_waiting">
-        Space-separated list of the names of OVSDB locks that the connection is
-        currently waiting to acquire.  Omitted if the connection is not waiting
-        for any locks.
-      </column>
-
-      <column name="status" key="locks_lost">
-        Space-separated list of the names of OVSDB locks that the connection
-        has had stolen by another OVSDB client.  Omitted if no locks have been
-        stolen from this connection.
-      </column>
-
-      <column name="status" key="n_connections"
-              type='{"type": "integer", "minInteger": 2}'>
-        <p>
-          When <ref column="target"/> specifies a connection method that
-          listens for inbound connections (e.g. <code>ptcp:</code> or
-          <code>pssl:</code>) and more than one connection is actually active,
-          the value is the number of active connections.  Otherwise, this
-          key-value pair is omitted.
-        </p>
-        <p>
-          When multiple connections are active, status columns and key-value
-          pairs (other than this one) report the status of one arbitrarily
-          chosen connection.
-        </p>
-      </column>
-
-      <column name="status" key="bound_port" type='{"type": "integer"}'>
-        When <ref column="target"/> is <code>ptcp:</code> or
-        <code>pssl:</code>, this is the TCP port on which the OVSDB server is
-        listening.  (This is is particularly useful when <ref
-        column="target"/> specifies a port of 0, allowing the kernel to
-        choose any available port.)
-      </column>
-    </group>
-
-    <group title="Connection Parameters">
-      <p>
-        Additional configuration for a connection between the manager
-        and the Open vSwitch Database.
-      </p>
-
-      <column name="other_config" key="dscp"
-              type='{"type": "integer"}'>
-        The Differentiated Service Code Point (DSCP) is specified using 6 bits
-        in the Type of Service (TOS) field in the IP header. DSCP provides a
-        mechanism to classify the network traffic and provide Quality of
-        Service (QoS) on IP networks.
-
-        The DSCP value specified here is used when establishing the connection
-        between the manager and the Open vSwitch.  If no value is specified, a
-        default value of 48 is chosen.  Valid DSCP values must be in the range
-        0 to 63.
-      </column>
-    </group>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="external_ids"/>
-      <column name="other_config"/>
-    </group>
-  </table>
-
-  <table name="NetFlow">
-    A NetFlow target.  NetFlow is a protocol that exports a number of
-    details about terminating IP flows, such as the principals involved
-    and duration.
-
-    <column name="targets">
-      NetFlow targets in the form
-      <code><var>ip</var>:<var>port</var></code>.  The <var>ip</var>
-      must be specified numerically, not as a DNS name.
-    </column>
-
-    <column name="engine_id">
-      Engine ID to use in NetFlow messages.  Defaults to datapath index
-      if not specified.
-    </column>
-
-    <column name="engine_type">
-      Engine type to use in NetFlow messages.  Defaults to datapath
-      index if not specified.
-    </column>
-
-    <column name="active_timeout">
-      <p>
-        The interval at which NetFlow records are sent for flows that
-        are still active, in seconds.  A value of <code>0</code>
-        requests the default timeout (currently 600 seconds); a value
-        of <code>-1</code> disables active timeouts.
-      </p>
-
-      <p>
-        The NetFlow passive timeout, for flows that become inactive,
-        is not configurable.  It will vary depending on the Open
-        vSwitch version, the forms and contents of the OpenFlow flow
-        tables, CPU and memory usage, and network activity.  A typical
-        passive timeout is about a second.
-      </p>
-    </column>
-
-    <column name="add_id_to_interface">
-      <p>If this column's value is <code>false</code>, the ingress and egress
-      interface fields of NetFlow flow records are derived from OpenFlow port
-      numbers.  When it is <code>true</code>, the 7 most significant bits of
-      these fields will be replaced by the least significant 7 bits of the
-      engine id.  This is useful because many NetFlow collectors do not
-      expect multiple switches to be sending messages from the same host, so
-      they do not store the engine information which could be used to
-      disambiguate the traffic.</p>
-      <p>When this option is enabled, a maximum of 508 ports are supported.</p>
-    </column>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="SSL">
-    SSL configuration for an Open_vSwitch.
-
-    <column name="private_key">
-      Name of a PEM file containing the private key used as the switch's
-      identity for SSL connections to the controller.
-    </column>
-
-    <column name="certificate">
-      Name of a PEM file containing a certificate, signed by the
-      certificate authority (CA) used by the controller and manager,
-      that certifies the switch's private key, identifying a trustworthy
-      switch.
-    </column>
-
-    <column name="ca_cert">
-      Name of a PEM file containing the CA certificate used to verify
-      that the switch is connected to a trustworthy controller.
-    </column>
-
-    <column name="bootstrap_ca_cert">
-      If set to <code>true</code>, then Open vSwitch will attempt to
-      obtain the CA certificate from the controller on its first SSL
-      connection and save it to the named PEM file. If it is successful,
-      it will immediately drop the connection and reconnect, and from then
-      on all SSL connections must be authenticated by a certificate signed
-      by the CA certificate thus obtained.  <em>This option exposes the
-      SSL connection to a man-in-the-middle attack obtaining the initial
-      CA certificate.</em>  It may still be useful for bootstrapping.
-    </column>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="sFlow">
-    <p>A set of sFlow(R) targets.  sFlow is a protocol for remote
-    monitoring of switches.</p>
-
-    <column name="agent">
-      Name of the network device whose IP address should be reported as the
-      ``agent address'' to collectors.  If not specified, the agent device is
-      figured from the first target address and the routing table.  If the
-      routing table does not contain a route to the target, the IP address
-      defaults to the <ref table="Controller" column="local_ip"/> in the
-      collector's <ref table="Controller"/>.  If an agent IP address cannot be
-      determined any of these ways, sFlow is disabled.
-    </column>
-
-    <column name="header">
-      Number of bytes of a sampled packet to send to the collector.
-      If not specified, the default is 128 bytes.
-    </column>
-
-    <column name="polling">
-      Polling rate in seconds to send port statistics to the collector.
-      If not specified, defaults to 30 seconds.
-    </column>
-
-    <column name="sampling">
-      Rate at which packets should be sampled and sent to the collector.
-      If not specified, defaults to 400, which means one out of 400
-      packets, on average, will be sent to the collector.
-    </column>
-
-    <column name="targets">
-      sFlow targets in the form
-      <code><var>ip</var>:<var>port</var></code>.
-    </column>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="IPFIX">
-    <p>Configuration for sending packets to IPFIX collectors.</p>
-
-    <p>
-      IPFIX is a protocol that exports a number of details about flows.  The
-      IPFIX implementation in Open vSwitch samples packets at a configurable
-      rate, extracts flow information from those packets, optionally caches and
-      aggregates the flow information, and sends the result to one or more
-      collectors.
-    </p>
-
-    <p>
-      IPFIX in Open vSwitch can be configured two different ways:
-    </p>
-
-    <ul>
-      <li>
-        With <em>per-bridge sampling</em>, Open vSwitch performs IPFIX sampling
-        automatically on all packets that pass through a bridge.  To configure
-        per-bridge sampling, create an <ref table="IPFIX"/> record and point a
-        <ref table="Bridge"/> table's <ref table="Bridge" column="ipfix"/>
-        column to it.  The <ref table="Flow_Sample_Collector_Set"/> table is
-        not used for per-bridge sampling.
-      </li>
-
-      <li>
-        <p>
-          With <em>flow-based sampling</em>, <code>sample</code> actions in the
-          OpenFlow flow table drive IPFIX sampling.  See
-          <code>ovs-ofctl</code>(8) for a description of the
-          <code>sample</code> action.
-        </p>
-
-        <p>
-          Flow-based sampling also requires database configuration: create a
-          <ref table="IPFIX"/> record that describes the IPFIX configuration
-          and a <ref table="Flow_Sample_Collector_Set"/> record that points to
-          the <ref table="Bridge"/> whose flow table holds the
-          <code>sample</code> actions and to <ref table="IPFIX"/> record.  The
-          <ref table="Bridge" column="ipfix"/> in the <ref table="Bridge"/>
-          table is not used for flow-based sampling.
-        </p>
-      </li>
-    </ul>
-
-    <column name="targets">
-      IPFIX target collectors in the form
-      <code><var>ip</var>:<var>port</var></code>.
-    </column>
-
-    <column name="cache_active_timeout">
-      The maximum period in seconds for which an IPFIX flow record is
-      cached and aggregated before being sent.  If not specified,
-      defaults to 0.  If 0, caching is disabled.
-    </column>
-
-    <column name="cache_max_flows">
-      The maximum number of IPFIX flow records that can be cached at a
-      time.  If not specified, defaults to 0.  If 0, caching is
-      disabled.
-    </column>
-
-    <group title="Per-Bridge Sampling">
-      <p>
-        These values affect only per-bridge sampling.  See above for a
-        description of the differences between per-bridge and flow-based
-        sampling.
-      </p>
-
-      <column name="sampling">
-        The rate at which packets should be sampled and sent to each target
-        collector.  If not specified, defaults to 400, which means one out of
-        400 packets, on average, will be sent to each target collector.
-      </column>
-
-      <column name="obs_domain_id">
-        The IPFIX Observation Domain ID sent in each IPFIX packet.  If not
-        specified, defaults to 0.
-      </column>
-
-      <column name="obs_point_id">
-        The IPFIX Observation Point ID sent in each IPFIX flow record.  If not
-        specified, defaults to 0.
-      </column>
-
-      <column name="other_config" key="enable-tunnel-sampling"
-              type='{"type": "boolean"}'>
-        <p>
-          Set to <code>true</code> to enable sampling and reporting tunnel
-          header 7-tuples in IPFIX flow records.  Tunnel sampling is disabled
-          by default.
-        </p>
-
-        <p>
-          The following enterprise entities report the sampled tunnel info:
-        </p>
-
-        <dl>
-          <dt>tunnelType:</dt>
-          <dd>
-            <p>ID: 891, and enterprise ID 6876 (VMware).</p>
-            <p>type: unsigned 8-bit integer.</p>
-            <p>data type semantics: identifier.</p>
-            <p>description: Identifier of the layer 2 network overlay network
-            encapsulation type: 0x01 VxLAN, 0x02 GRE, 0x03 LISP, 0x05 IPsec+GRE,
-            0x07 GENEVE.</p>
-          </dd>
-          <dt>tunnelKey:</dt>
-          <dd>
-            <p>ID: 892, and enterprise ID 6876 (VMware).</p>
-            <p>type: variable-length octetarray.</p>
-            <p>data type semantics: identifier.</p>
-            <p>description: Key which is used for identifying an individual
-            traffic flow within a VxLAN (24-bit VNI), GENEVE (24-bit VNI),
-            GRE (32-bit key), or LISP (24-bit instance ID) tunnel. The
-            key is encoded in this octetarray as a 3-, 4-, or 8-byte integer
-            ID in network byte order.</p>
-          </dd>
-          <dt>tunnelSourceIPv4Address:</dt>
-          <dd>
-            <p>ID: 893, and enterprise ID 6876 (VMware).</p>
-            <p>type: unsigned 32-bit integer.</p>
-            <p>data type semantics: identifier.</p>
-            <p>description: The IPv4 source address in the tunnel IP packet
-            header.</p>
-          </dd>
-          <dt>tunnelDestinationIPv4Address:</dt>
-          <dd>
-            <p>ID: 894, and enterprise ID 6876 (VMware).</p>
-            <p>type: unsigned 32-bit integer.</p>
-            <p>data type semantics: identifier.</p>
-            <p>description: The IPv4 destination address in the tunnel IP
-            packet header.</p>
-          </dd>
-          <dt>tunnelProtocolIdentifier:</dt>
-          <dd>
-            <p>ID: 895, and enterprise ID 6876 (VMware).</p>
-            <p>type: unsigned 8-bit integer.</p>
-            <p>data type semantics: identifier.</p>
-            <p>description: The value of the protocol number in the tunnel
-            IP packet header. The protocol number identifies the tunnel IP
-            packet payload type.</p>
-          </dd>
-          <dt>tunnelSourceTransportPort:</dt>
-          <dd>
-            <p>ID: 896, and enterprise ID 6876 (VMware).</p>
-            <p>type: unsigned 16-bit integer.</p>
-            <p>data type semantics: identifier.</p>
-            <p>description: The source port identifier in the tunnel transport
-            header. For the transport protocols UDP, TCP, and SCTP, this is
-            the source port number given in the respective header.</p>
-          </dd>
-          <dt>tunnelDestinationTransportPort:</dt>
-          <dd>
-            <p>ID: 897, and enterprise ID 6876 (VMware).</p>
-            <p>type: unsigned 16-bit integer.</p>
-            <p>data type semantics: identifier.</p>
-            <p>description: The destination port identifier in the tunnel
-            transport header. For the transport protocols UDP, TCP, and SCTP,
-            this is the destination port number given in the respective header.
-            </p>
-          </dd>
-        </dl>
-      </column>
-
-      <column name="other_config" key="enable-input-sampling"
-              type='{"type": "boolean"}'>
-        By default, Open vSwitch samples and reports flows at bridge port input
-        in IPFIX flow records.  Set this column to <code>false</code> to
-        disable input sampling.
-      </column>
-
-      <column name="other_config" key="enable-output-sampling"
-              type='{"type": "boolean"}'>
-        By default, Open vSwitch samples and reports flows at bridge port
-        output in IPFIX flow records.  Set this column to <code>false</code> to
-        disable output sampling.
-      </column>
-    </group>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="Flow_Sample_Collector_Set">
-    <p>
-      A set of IPFIX collectors of packet samples generated by OpenFlow
-      <code>sample</code> actions.  This table is used only for IPFIX
-      flow-based sampling, not for per-bridge sampling (see the <ref
-      table="IPFIX"/> table for a description of the two forms).
-    </p>
-
-    <column name="id">
-      The ID of this collector set, unique among the bridge's
-      collector sets, to be used as the <code>collector_set_id</code>
-      in OpenFlow <code>sample</code> actions.
-    </column>
-
-    <column name="bridge">
-      The bridge into which OpenFlow <code>sample</code> actions can
-      be added to send packet samples to this set of IPFIX collectors.
-    </column>
-
-    <column name="ipfix">
-      Configuration of the set of IPFIX collectors to send one flow
-      record per sampled packet to.
-    </column>
-
-    <group title="Common Columns">
-      The overall purpose of these columns is described under <code>Common
-      Columns</code> at the beginning of this document.
-
-      <column name="external_ids"/>
-    </group>
-  </table>
-
-  <table name="AutoAttach">
-    <p>
-      Auto Attach configuration within a bridge.  The IETF Auto-Attach SPBM
-      draft standard describes a compact method of using IEEE 802.1AB Link
-      Layer Discovery Protocol (LLDP) together with a IEEE 802.1aq Shortest
-      Path Bridging (SPB) network to automatically attach network devices
-      to individual services in a SPB network.  The intent here is to allow
-      network applications and devices using OVS to be able to easily take
-      advantage of features offered by industry standard SPB networks.
-    </p>
-
-    <p>
-      Auto Attach (AA) uses LLDP to communicate between a directly connected
-      Auto Attach Client (AAC) and Auto Attach Server (AAS). The LLDP protocol
-      is extended to add two new Type-Length-Value tuples (TLVs). The first
-      new TLV supports the ongoing discovery of directly connected AA
-      correspondents. Auto Attach operates by regularly transmitting AA
-      discovery TLVs between the AA client and AA server. By exchanging these
-      discovery messages, both the AAC and AAS learn the system name and
-      system description of their peer. In the OVS context, OVS operates as
-      the AA client and the AA server resides on a switch at the edge of the
-      SPB network.
-    </p>
-
-    <p>
-      Once AA discovery has been completed the AAC then uses the second new TLV
-      to deliver identifier mappings from the AAC to the AAS. A primary feature
-      of Auto Attach is to facilitate the mapping of VLANs defined outside the
-      SPB network onto service ids (ISIDs) defined within the SPM network. By
-      doing so individual external VLANs can be mapped onto specific SPB
-      network services. These VLAN id to ISID mappings can be configured and
-      managed locally using new options added to the ovs-vsctl command.
-    </p>
-
-    <p>
-      The Auto Attach OVS feature does not provide a full implementation of
-      the LLDP protocol. Support for the mandatory TLVs as defined by the LLDP
-      standard and support for the AA TLV extensions is provided. LLDP
-      protocol support in OVS can be enabled or disabled on a port by port
-      basis. LLDP support is disabled by default.
-    </p>
-
-    <column name="system_name">
-      The system_name string is exported in LLDP messages.  It should uniquely
-      identify the bridge in the network.
-    </column>
-
-    <column name="system_description">
-      The system_description string is exported in LLDP messages.  It should
-      describe the type of software and hardware.
-    </column>
-
-    <column name="mappings">
-      A mapping from SPB network Individual Service Identifier (ISID) to VLAN
-      id.
-    </column>
-  </table>
-</database>
diff --git a/vtep/automake.mk b/vtep/automake.mk
index de028b6..b8c6f5a 100644
--- a/vtep/automake.mk
+++ b/vtep/automake.mk
@@ -33,7 +33,7 @@ DISTCLEANFILES += \
 man_MANS += \
    vtep/vtep-ctl.8
 
-vtep_vtep_ctl_SOURCES = vtep/vtep-ctl.c
+vtep_vtep_ctl_SOURCES = $(srcdir)/vtep/vtep-ctl.c
 vtep_vtep_ctl_LDADD = vtep/libvtep.la lib/libopenvswitch.la
 
 # ovs-vtep
-- 
2.7.4

